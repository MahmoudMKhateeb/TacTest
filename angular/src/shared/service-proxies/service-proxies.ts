/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/IsTenantAvailable';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(<any>response_);
            } catch (e) {
              return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<IsTenantAvailableOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
    let url_ = this.baseUrl + '/api/services/app/Account/ResolveTenantId';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResolveTenantId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResolveTenantId(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterInput | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<RegisterOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<RegisterOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RegisterOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Account/SendPasswordResetCode';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendPasswordResetCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendPasswordResetCode(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/ResetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_);
            } catch (e) {
              return <Observable<ResetPasswordOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ResetPasswordOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResetPasswordOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ResetPasswordOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Account/SendEmailActivationLink';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendEmailActivationLink(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendEmailActivationLink(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Account/ActivateEmail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivateEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivateEmail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processActivateEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/Impersonate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processImpersonate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processImpersonate(<any>response_);
            } catch (e) {
              return <Observable<ImpersonateOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ImpersonateOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ImpersonateOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ImpersonateOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/DelegatedImpersonate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelegatedImpersonate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelegatedImpersonate(<any>response_);
            } catch (e) {
              return <Observable<ImpersonateOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ImpersonateOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ImpersonateOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ImpersonateOutput>(<any>null);
  }

  /**
   * @return Success
   */
  backToImpersonator(): Observable<ImpersonateOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/BackToImpersonator';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processBackToImpersonator(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processBackToImpersonator(<any>response_);
            } catch (e) {
              return <Observable<ImpersonateOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ImpersonateOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ImpersonateOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ImpersonateOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/SwitchToLinkedAccount';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSwitchToLinkedAccount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSwitchToLinkedAccount(<any>response_);
            } catch (e) {
              return <Observable<SwitchToLinkedAccountOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<SwitchToLinkedAccountOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
  }
}

@Injectable()
export class AppLocalizationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param editionId (optional)
   * @param page (optional)
   * @param platForm (optional)
   * @param appVersion (optional)
   * @param version (optional)
   * @param section (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    editionId: number | null | undefined,
    page: string | null | undefined,
    platForm: TerminologyPlatForm | undefined,
    appVersion: TerminologyAppVersion | undefined,
    version: TerminologyVersion | undefined,
    section: TerminologySection | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfAppLocalizationListDto> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (editionId !== undefined) url_ += 'EditionId=' + encodeURIComponent('' + editionId) + '&';
    if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (platForm === null) throw new Error("The parameter 'platForm' cannot be null.");
    else if (platForm !== undefined) url_ += 'PlatForm=' + encodeURIComponent('' + platForm) + '&';
    if (appVersion === null) throw new Error("The parameter 'appVersion' cannot be null.");
    else if (appVersion !== undefined) url_ += 'AppVersion=' + encodeURIComponent('' + appVersion) + '&';
    if (version === null) throw new Error("The parameter 'version' cannot be null.");
    else if (version !== undefined) url_ += 'Version=' + encodeURIComponent('' + version) + '&';
    if (section === null) throw new Error("The parameter 'section' cannot be null.");
    else if (section !== undefined) url_ += 'Section=' + encodeURIComponent('' + section) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfAppLocalizationListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfAppLocalizationListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfAppLocalizationListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfAppLocalizationListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfAppLocalizationListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getForView(id: number | undefined): Observable<AppLocalizationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/GetForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForView(<any>response_);
            } catch (e) {
              return <Observable<AppLocalizationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<AppLocalizationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForView(response: HttpResponseBase): Observable<AppLocalizationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AppLocalizationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AppLocalizationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getForEdit(id: number | undefined): Observable<CreateOrEditAppLocalizationDto> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/GetForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditAppLocalizationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditAppLocalizationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditAppLocalizationDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditAppLocalizationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditAppLocalizationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditAppLocalizationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: AppLocalizationFilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  restore(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/Restore';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRestore(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRestore(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRestore(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  generate(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/Generate';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGenerate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrUpdateKeyLog(body: TerminologieMonitorInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/AppLocalization/CreateOrUpdateKeyLog';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrUpdateKeyLog(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrUpdateKeyLog(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrUpdateKeyLog(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AuditLogServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @param userName (optional)
   * @param serviceName (optional)
   * @param methodName (optional)
   * @param browserInfo (optional)
   * @param hasException (optional)
   * @param minExecutionDuration (optional)
   * @param maxExecutionDuration (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getAuditLogs(
    startDate: moment.Moment | undefined,
    endDate: moment.Moment | undefined,
    userName: string | null | undefined,
    serviceName: string | null | undefined,
    methodName: string | null | undefined,
    browserInfo: string | null | undefined,
    hasException: boolean | null | undefined,
    minExecutionDuration: number | null | undefined,
    maxExecutionDuration: number | null | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfAuditLogListDto> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetAuditLogs?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    if (userName !== undefined) url_ += 'UserName=' + encodeURIComponent('' + userName) + '&';
    if (serviceName !== undefined) url_ += 'ServiceName=' + encodeURIComponent('' + serviceName) + '&';
    if (methodName !== undefined) url_ += 'MethodName=' + encodeURIComponent('' + methodName) + '&';
    if (browserInfo !== undefined) url_ += 'BrowserInfo=' + encodeURIComponent('' + browserInfo) + '&';
    if (hasException !== undefined) url_ += 'HasException=' + encodeURIComponent('' + hasException) + '&';
    if (minExecutionDuration !== undefined) url_ += 'MinExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&';
    if (maxExecutionDuration !== undefined) url_ += 'MaxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAuditLogs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAuditLogs(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfAuditLogListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfAuditLogListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @param userName (optional)
   * @param serviceName (optional)
   * @param methodName (optional)
   * @param browserInfo (optional)
   * @param hasException (optional)
   * @param minExecutionDuration (optional)
   * @param maxExecutionDuration (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getAuditLogsToExcel(
    startDate: moment.Moment | undefined,
    endDate: moment.Moment | undefined,
    userName: string | null | undefined,
    serviceName: string | null | undefined,
    methodName: string | null | undefined,
    browserInfo: string | null | undefined,
    hasException: boolean | null | undefined,
    minExecutionDuration: number | null | undefined,
    maxExecutionDuration: number | null | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetAuditLogsToExcel?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    if (userName !== undefined) url_ += 'UserName=' + encodeURIComponent('' + userName) + '&';
    if (serviceName !== undefined) url_ += 'ServiceName=' + encodeURIComponent('' + serviceName) + '&';
    if (methodName !== undefined) url_ += 'MethodName=' + encodeURIComponent('' + methodName) + '&';
    if (browserInfo !== undefined) url_ += 'BrowserInfo=' + encodeURIComponent('' + browserInfo) + '&';
    if (hasException !== undefined) url_ += 'HasException=' + encodeURIComponent('' + hasException) + '&';
    if (minExecutionDuration !== undefined) url_ += 'MinExecutionDuration=' + encodeURIComponent('' + minExecutionDuration) + '&';
    if (maxExecutionDuration !== undefined) url_ += 'MaxExecutionDuration=' + encodeURIComponent('' + maxExecutionDuration) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAuditLogsToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAuditLogsToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityHistoryObjectTypes';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEntityHistoryObjectTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEntityHistoryObjectTypes(<any>response_);
            } catch (e) {
              return <Observable<NameValueDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<NameValueDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NameValueDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<NameValueDto[]>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @param userName (optional)
   * @param entityTypeFullName (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getEntityChanges(
    startDate: moment.Moment | undefined,
    endDate: moment.Moment | undefined,
    userName: string | null | undefined,
    entityTypeFullName: string | null | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfEntityChangeListDto> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityChanges?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    if (userName !== undefined) url_ += 'UserName=' + encodeURIComponent('' + userName) + '&';
    if (entityTypeFullName !== undefined) url_ += 'EntityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEntityChanges(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEntityChanges(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfEntityChangeListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfEntityChangeListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
  }

  /**
   * @param entityTypeFullName (optional)
   * @param entityId (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getEntityTypeChanges(
    entityTypeFullName: string | null | undefined,
    entityId: string | null | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfEntityChangeListDto> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityTypeChanges?';
    if (entityTypeFullName !== undefined) url_ += 'EntityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
    if (entityId !== undefined) url_ += 'EntityId=' + encodeURIComponent('' + entityId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEntityTypeChanges(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEntityTypeChanges(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfEntityChangeListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfEntityChangeListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @param userName (optional)
   * @param entityTypeFullName (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getEntityChangesToExcel(
    startDate: moment.Moment | undefined,
    endDate: moment.Moment | undefined,
    userName: string | null | undefined,
    entityTypeFullName: string | null | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityChangesToExcel?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    if (userName !== undefined) url_ += 'UserName=' + encodeURIComponent('' + userName) + '&';
    if (entityTypeFullName !== undefined) url_ += 'EntityTypeFullName=' + encodeURIComponent('' + entityTypeFullName) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEntityChangesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEntityChangesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param entityChangeId (optional)
   * @return Success
   */
  getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
    let url_ = this.baseUrl + '/api/services/app/AuditLog/GetEntityPropertyChanges?';
    if (entityChangeId === null) throw new Error("The parameter 'entityChangeId' cannot be null.");
    else if (entityChangeId !== undefined) url_ += 'entityChangeId=' + encodeURIComponent('' + entityChangeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEntityPropertyChanges(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEntityPropertyChanges(<any>response_);
            } catch (e) {
              return <Observable<EntityPropertyChangeDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<EntityPropertyChangeDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(EntityPropertyChangeDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EntityPropertyChangeDto[]>(<any>null);
  }
}

@Injectable()
export class BalanceRechargeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param tenantId (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param referenceNo (optional)
   * @param minLongitude (optional)
   * @param maxLongitude (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    tenantId: number | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    referenceNo: string | null | undefined,
    minLongitude: number | null | undefined,
    maxLongitude: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfBalanceRechargeListDto> {
    let url_ = this.baseUrl + '/api/services/app/BalanceRecharge/GetAll?';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (referenceNo !== undefined) url_ += 'ReferenceNo=' + encodeURIComponent('' + referenceNo) + '&';
    if (minLongitude !== undefined) url_ += 'minLongitude=' + encodeURIComponent('' + minLongitude) + '&';
    if (maxLongitude !== undefined) url_ += 'maxLongitude=' + encodeURIComponent('' + maxLongitude) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfBalanceRechargeListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfBalanceRechargeListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBalanceRechargeListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfBalanceRechargeListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfBalanceRechargeListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateBalanceRechargeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/BalanceRecharge/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/BalanceRecharge/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: GetAllBalanceRechargeInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/BalanceRecharge/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class CachingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAllCaches(): Observable<ListResultDtoOfCacheDto> {
    let url_ = this.baseUrl + '/api/services/app/Caching/GetAllCaches';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCaches(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCaches(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfCacheDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfCacheDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfCacheDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  clearCache(body: EntityDtoOfString | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Caching/ClearCache';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearCache(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearCache(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClearCache(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  clearAllCaches(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Caching/ClearAllCaches';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearAllCaches(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearAllCaches(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CapacitiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param truckTypeDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    truckTypeDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetCapacityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (truckTypeDisplayNameFilter !== undefined) url_ += 'TruckTypeDisplayNameFilter=' + encodeURIComponent('' + truckTypeDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetCapacityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetCapacityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCapacityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetCapacityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetCapacityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCapacityForView(id: number | undefined): Observable<GetCapacityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/GetCapacityForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCapacityForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCapacityForView(<any>response_);
            } catch (e) {
              return <Observable<GetCapacityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCapacityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCapacityForView(response: HttpResponseBase): Observable<GetCapacityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCapacityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCapacityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCapacityForEdit(id: number | undefined): Observable<GetCapacityForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/GetCapacityForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCapacityForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCapacityForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetCapacityForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCapacityForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCapacityForEdit(response: HttpResponseBase): Observable<GetCapacityForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCapacityForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCapacityForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditCapacityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTruckTypeForTableDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Capacities/GetAllTruckTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckTypeForTableDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class ChatServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
    let url_ = this.baseUrl + '/api/services/app/Chat/GetUserChatFriendsWithSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserChatFriendsWithSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserChatFriendsWithSettings(<any>response_);
            } catch (e) {
              return <Observable<GetUserChatFriendsWithSettingsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetUserChatFriendsWithSettingsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
  }

  /**
   * @param tenantId (optional)
   * @param userId (optional)
   * @param minMessageId (optional)
   * @return Success
   */
  getUserChatMessages(
    tenantId: number | null | undefined,
    userId: number | undefined,
    minMessageId: number | null | undefined
  ): Observable<ListResultDtoOfChatMessageDto> {
    let url_ = this.baseUrl + '/api/services/app/Chat/GetUserChatMessages?';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
    if (minMessageId !== undefined) url_ += 'MinMessageId=' + encodeURIComponent('' + minMessageId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserChatMessages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserChatMessages(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfChatMessageDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfChatMessageDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CitiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param codeFilter (optional)
   * @param latitudeFilter (optional)
   * @param longitudeFilter (optional)
   * @param countyDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    codeFilter: string | null | undefined,
    latitudeFilter: string | null | undefined,
    longitudeFilter: string | null | undefined,
    countyDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetCityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Cities/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (codeFilter !== undefined) url_ += 'CodeFilter=' + encodeURIComponent('' + codeFilter) + '&';
    if (latitudeFilter !== undefined) url_ += 'LatitudeFilter=' + encodeURIComponent('' + latitudeFilter) + '&';
    if (longitudeFilter !== undefined) url_ += 'LongitudeFilter=' + encodeURIComponent('' + longitudeFilter) + '&';
    if (countyDisplayNameFilter !== undefined) url_ += 'CountyDisplayNameFilter=' + encodeURIComponent('' + countyDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetCityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetCityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetCityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetCityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCityForView(id: number | undefined): Observable<GetCityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Cities/GetCityForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCityForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCityForView(<any>response_);
            } catch (e) {
              return <Observable<GetCityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCityForView(response: HttpResponseBase): Observable<GetCityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCityForEdit(id: number | undefined): Observable<GetCityForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Cities/GetCityForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCityForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCityForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetCityForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCityForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCityForEdit(response: HttpResponseBase): Observable<GetCityForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCityForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCityForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditCityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Cities/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Cities/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param codeFilter (optional)
   * @param latitudeFilter (optional)
   * @param longitudeFilter (optional)
   * @param countyDisplayNameFilter (optional)
   * @return Success
   */
  getCitiesToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    codeFilter: string | null | undefined,
    latitudeFilter: string | null | undefined,
    longitudeFilter: string | null | undefined,
    countyDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Cities/GetCitiesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (codeFilter !== undefined) url_ += 'CodeFilter=' + encodeURIComponent('' + codeFilter) + '&';
    if (latitudeFilter !== undefined) url_ += 'LatitudeFilter=' + encodeURIComponent('' + latitudeFilter) + '&';
    if (longitudeFilter !== undefined) url_ += 'LongitudeFilter=' + encodeURIComponent('' + longitudeFilter) + '&';
    if (countyDisplayNameFilter !== undefined) url_ += 'CountyDisplayNameFilter=' + encodeURIComponent('' + countyDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitiesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitiesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCitiesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCountyForTableDropdown(): Observable<CityCountyLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Cities/GetAllCountyForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountyForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountyForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<CityCountyLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CityCountyLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCountyForTableDropdown(response: HttpResponseBase): Observable<CityCountyLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CityCountyLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CityCountyLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class CitiesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    cityDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetCitiesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetCitiesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetCitiesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCitiesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetCitiesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetCitiesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCitiesTranslationForView(id: number | undefined): Observable<GetCitiesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/GetCitiesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitiesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitiesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetCitiesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCitiesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCitiesTranslationForView(response: HttpResponseBase): Observable<GetCitiesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCitiesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCitiesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCitiesTranslationForEdit(id: number | undefined): Observable<GetCitiesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/GetCitiesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitiesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitiesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetCitiesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCitiesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCitiesTranslationForEdit(response: HttpResponseBase): Observable<GetCitiesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCitiesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCitiesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditCitiesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCityForTableDropdown(): Observable<CitiesTranslationCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/CitiesTranslations/GetAllCityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<CitiesTranslationCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CitiesTranslationCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<CitiesTranslationCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CitiesTranslationCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CitiesTranslationCityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class CommonLookupServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param onlyFreeItems (optional)
   * @return Success
   */
  getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetEditionsForCombobox?';
    if (onlyFreeItems === null) throw new Error("The parameter 'onlyFreeItems' cannot be null.");
    else if (onlyFreeItems !== undefined) url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditionsForCombobox(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditionsForCombobox(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/FindUsers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFindUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFindUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
  }

  /**
   * @return Success
   */
  getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetDefaultEditionName';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDefaultEditionName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDefaultEditionName(<any>response_);
            } catch (e) {
              return <Observable<GetDefaultEditionNameOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDefaultEditionNameOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDefaultEditionNameOutput>(<any>null);
  }

  /**
   * @param name (optional)
   * @param edtionName (optional)
   * @return Success
   */
  getAutoCompleteTenants(name: string | null | undefined, edtionName: string | null | undefined): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetAutoCompleteTenants?';
    if (name !== undefined) url_ += 'name=' + encodeURIComponent('' + name) + '&';
    if (edtionName !== undefined) url_ += 'EdtionName=' + encodeURIComponent('' + edtionName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAutoCompleteTenants(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAutoCompleteTenants(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAutoCompleteTenants(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getPeriods(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetPeriods';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPeriods(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPeriods(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPeriods(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAccidentReason(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/CommonLookup/GetAccidentReason';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAccidentReason(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAccidentReason(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAccidentReason(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class CountiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param codeFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    codeFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetCountyForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Counties/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (codeFilter !== undefined) url_ += 'CodeFilter=' + encodeURIComponent('' + codeFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetCountyForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetCountyForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCountyForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetCountyForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetCountyForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCountyForView(id: number | undefined): Observable<GetCountyForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Counties/GetCountyForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountyForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountyForView(<any>response_);
            } catch (e) {
              return <Observable<GetCountyForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCountyForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountyForView(response: HttpResponseBase): Observable<GetCountyForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCountyForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCountyForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCountyForEdit(id: number | undefined): Observable<GetCountyForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Counties/GetCountyForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountyForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountyForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetCountyForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCountyForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountyForEdit(response: HttpResponseBase): Observable<GetCountyForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCountyForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCountyForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditCountyDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Counties/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Counties/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param codeFilter (optional)
   * @return Success
   */
  getCountiesToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    codeFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Counties/GetCountiesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (codeFilter !== undefined) url_ += 'CodeFilter=' + encodeURIComponent('' + codeFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountiesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountiesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountiesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class CountriesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param countyDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    countyDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetCountriesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (countyDisplayNameFilter !== undefined) url_ += 'CountyDisplayNameFilter=' + encodeURIComponent('' + countyDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetCountriesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetCountriesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCountriesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetCountriesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetCountriesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCountriesTranslationForView(id: number | undefined): Observable<GetCountriesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/GetCountriesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountriesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountriesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetCountriesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCountriesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountriesTranslationForView(response: HttpResponseBase): Observable<GetCountriesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCountriesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCountriesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCountriesTranslationForEdit(id: number | undefined): Observable<GetCountriesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/GetCountriesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountriesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountriesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetCountriesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCountriesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountriesTranslationForEdit(response: HttpResponseBase): Observable<GetCountriesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCountriesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCountriesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditCountriesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCountyForTableDropdown(): Observable<CountriesTranslationCountyLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/CountriesTranslations/GetAllCountyForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountyForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountyForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<CountriesTranslationCountyLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CountriesTranslationCountyLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCountyForTableDropdown(response: HttpResponseBase): Observable<CountriesTranslationCountyLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CountriesTranslationCountyLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CountriesTranslationCountyLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param dashboardName (optional)
   * @param application (optional)
   * @return Success
   */
  getUserDashboard(dashboardName: string | null | undefined, application: string | null | undefined): Observable<Dashboard> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/GetUserDashboard?';
    if (dashboardName !== undefined) url_ += 'DashboardName=' + encodeURIComponent('' + dashboardName) + '&';
    if (application !== undefined) url_ += 'Application=' + encodeURIComponent('' + application) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserDashboard(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserDashboard(<any>response_);
            } catch (e) {
              return <Observable<Dashboard>>(<any>_observableThrow(e));
            }
          } else return <Observable<Dashboard>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Dashboard.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<Dashboard>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  savePage(body: SavePageInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/SavePage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSavePage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSavePage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSavePage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  renamePage(body: RenamePageInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/RenamePage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRenamePage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRenamePage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRenamePage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/AddNewPage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddNewPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddNewPage(<any>response_);
            } catch (e) {
              return <Observable<AddNewPageOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<AddNewPageOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AddNewPageOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AddNewPageOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @param dashboardName (optional)
   * @param application (optional)
   * @return Success
   */
  deletePage(id: string | null | undefined, dashboardName: string | null | undefined, application: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/DeletePage?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (dashboardName !== undefined) url_ += 'DashboardName=' + encodeURIComponent('' + dashboardName) + '&';
    if (application !== undefined) url_ += 'Application=' + encodeURIComponent('' + application) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeletePage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeletePage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeletePage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/AddWidget';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddWidget(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddWidget(<any>response_);
            } catch (e) {
              return <Observable<Widget>>(<any>_observableThrow(e));
            }
          } else return <Observable<Widget>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Widget.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<Widget>(<any>null);
  }

  /**
   * @param dashboardName (optional)
   * @param application (optional)
   * @return Success
   */
  getDashboardDefinition(dashboardName: string | null | undefined, application: string | null | undefined): Observable<DashboardOutput> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/GetDashboardDefinition?';
    if (dashboardName !== undefined) url_ += 'DashboardName=' + encodeURIComponent('' + dashboardName) + '&';
    if (application !== undefined) url_ += 'Application=' + encodeURIComponent('' + application) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDashboardDefinition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDashboardDefinition(<any>response_);
            } catch (e) {
              return <Observable<DashboardOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<DashboardOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DashboardOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DashboardOutput>(<any>null);
  }

  /**
   * @param dashboardName (optional)
   * @param application (optional)
   * @return Success
   */
  getAllWidgetDefinitions(dashboardName: string | null | undefined, application: string | null | undefined): Observable<WidgetOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?';
    if (dashboardName !== undefined) url_ += 'DashboardName=' + encodeURIComponent('' + dashboardName) + '&';
    if (application !== undefined) url_ += 'Application=' + encodeURIComponent('' + application) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllWidgetDefinitions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllWidgetDefinitions(<any>response_);
            } catch (e) {
              return <Observable<WidgetOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<WidgetOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(WidgetOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<WidgetOutput[]>(<any>null);
  }

  /**
   * @param application (optional)
   * @return Success
   */
  getSettingName(application: string | null | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/DashboardCustomization/GetSettingName?';
    if (application !== undefined) url_ += 'application=' + encodeURIComponent('' + application) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSettingName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSettingName(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSettingName(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param date (optional)
   * @return Success
   */
  sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/SendAndGetDate?';
    if (date !== undefined) url_ += 'date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendAndGetDate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendAndGetDate(<any>response_);
            } catch (e) {
              return <Observable<DateToStringOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<DateToStringOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DateToStringOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DateToStringOutput>(<any>null);
  }

  /**
   * @param date (optional)
   * @return Success
   */
  sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/SendAndGetDateTime?';
    if (date !== undefined) url_ += 'date=' + encodeURIComponent(date ? '' + date.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendAndGetDateTime(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendAndGetDateTime(<any>response_);
            } catch (e) {
              return <Observable<DateToStringOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<DateToStringOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DateToStringOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DateToStringOutput>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @return Success
   */
  sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/SendAndGetDateRange?';
    if (startDate !== undefined) url_ += 'startDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate !== undefined) url_ += 'endDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendAndGetDateRange(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendAndGetDateRange(<any>response_);
            } catch (e) {
              return <Observable<DateToStringOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<DateToStringOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DateToStringOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DateToStringOutput>(<any>null);
  }

  /**
   * @param searchTerm (optional)
   * @return Success
   */
  getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/GetCountries?';
    if (searchTerm !== undefined) url_ += 'searchTerm=' + encodeURIComponent('' + searchTerm) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountries(<any>response_);
            } catch (e) {
              return <Observable<NameValueOfString[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<NameValueOfString[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NameValueOfString.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<NameValueOfString[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendAndGetSelectedCountries(body: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/SendAndGetSelectedCountries';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendAndGetSelectedCountries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendAndGetSelectedCountries(<any>response_);
            } catch (e) {
              return <Observable<NameValueOfString[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<NameValueOfString[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NameValueOfString.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<NameValueOfString[]>(<any>null);
  }

  /**
   * @param input (optional)
   * @return Success
   */
  sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
    let url_ = this.baseUrl + '/api/services/app/DemoUiComponents/SendAndGetValue?';
    if (input !== undefined) url_ += 'input=' + encodeURIComponent('' + input) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendAndGetValue(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendAndGetValue(<any>response_);
            } catch (e) {
              return <Observable<StringOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<StringOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StringOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<StringOutput>(<any>null);
  }
}

@Injectable()
export class DocumentFilesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param maxExpirationDateFilter (optional)
   * @param minExpirationDateFilter (optional)
   * @param documentTypeDisplayNameFilter (optional)
   * @param documentEntityFilter (optional)
   * @param truckIdFilter (optional)
   * @param entityIdFilter (optional)
   * @param trailerTrailerCodeFilter (optional)
   * @param userNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    maxExpirationDateFilter: moment.Moment | null | undefined,
    minExpirationDateFilter: moment.Moment | null | undefined,
    documentTypeDisplayNameFilter: string | null | undefined,
    documentEntityFilter: DocumentsEntitiesEnum | undefined,
    truckIdFilter: number | null | undefined,
    entityIdFilter: string | null | undefined,
    trailerTrailerCodeFilter: string | null | undefined,
    userNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetDocumentFileForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (maxExpirationDateFilter !== undefined)
      url_ += 'MaxExpirationDateFilter=' + encodeURIComponent(maxExpirationDateFilter ? '' + maxExpirationDateFilter.toJSON() : '') + '&';
    if (minExpirationDateFilter !== undefined)
      url_ += 'MinExpirationDateFilter=' + encodeURIComponent(minExpirationDateFilter ? '' + minExpirationDateFilter.toJSON() : '') + '&';
    if (documentTypeDisplayNameFilter !== undefined)
      url_ += 'DocumentTypeDisplayNameFilter=' + encodeURIComponent('' + documentTypeDisplayNameFilter) + '&';
    if (documentEntityFilter === null) throw new Error("The parameter 'documentEntityFilter' cannot be null.");
    else if (documentEntityFilter !== undefined) url_ += 'DocumentEntityFilter=' + encodeURIComponent('' + documentEntityFilter) + '&';
    if (truckIdFilter !== undefined) url_ += 'TruckIdFilter=' + encodeURIComponent('' + truckIdFilter) + '&';
    if (entityIdFilter !== undefined) url_ += 'EntityIdFilter=' + encodeURIComponent('' + entityIdFilter) + '&';
    if (trailerTrailerCodeFilter !== undefined) url_ += 'TrailerTrailerCodeFilter=' + encodeURIComponent('' + trailerTrailerCodeFilter) + '&';
    if (userNameFilter !== undefined) url_ += 'UserNameFilter=' + encodeURIComponent('' + userNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetDocumentFileForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetDocumentFileForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentFileForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetDocumentFileForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetDocumentFileForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentFileForView(id: string | undefined): Observable<GetDocumentFileForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetDocumentFileForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentFileForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentFileForView(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentFileForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentFileForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentFileForView(response: HttpResponseBase): Observable<GetDocumentFileForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentFileForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentFileForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentFileForEdit(id: string | undefined): Observable<GetDocumentFileForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetDocumentFileForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentFileForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentFileForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentFileForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentFileForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentFileForEdit(response: HttpResponseBase): Observable<GetDocumentFileForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentFileForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentFileForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditDocumentFileDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllDocumentTypeForTableDropdown(): Observable<DocumentFileDocumentTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllDocumentTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDocumentTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDocumentTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentFileDocumentTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentFileDocumentTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllDocumentTypeForTableDropdown(response: HttpResponseBase): Observable<DocumentFileDocumentTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentFileDocumentTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentFileDocumentTypeLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTruckForTableDropdown(): Observable<DocumentFileTruckLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllTruckForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentFileTruckLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentFileTruckLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckForTableDropdown(response: HttpResponseBase): Observable<DocumentFileTruckLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentFileTruckLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentFileTruckLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerForTableDropdown(): Observable<DocumentFileTrailerLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllTrailerForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentFileTrailerLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentFileTrailerLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerForTableDropdown(response: HttpResponseBase): Observable<DocumentFileTrailerLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentFileTrailerLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentFileTrailerLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllUserForTableDropdown(): Observable<DocumentFileUserLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllUserForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentFileUserLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentFileUserLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUserForTableDropdown(response: HttpResponseBase): Observable<DocumentFileUserLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentFileUserLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentFileUserLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllRoutStepForTableDropdown(): Observable<DocumentFileRoutStepLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllRoutStepForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRoutStepForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRoutStepForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentFileRoutStepLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentFileRoutStepLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRoutStepForTableDropdown(response: HttpResponseBase): Observable<DocumentFileRoutStepLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentFileRoutStepLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentFileRoutStepLookupTableDto[]>(<any>null);
  }

  /**
   * @param documentFileId (optional)
   * @return Success
   */
  getDocumentFileDto(documentFileId: string | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetDocumentFileDto?';
    if (documentFileId === null) throw new Error("The parameter 'documentFileId' cannot be null.");
    else if (documentFileId !== undefined) url_ += 'documentFileId=' + encodeURIComponent('' + documentFileId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentFileDto(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentFileDto(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentFileDto(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param truckId (optional)
   * @return Success
   */
  getTruckRequiredDocumentFiles(truckId: string | null | undefined): Observable<CreateOrEditDocumentFileDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetTruckRequiredDocumentFiles?';
    if (truckId !== undefined) url_ += 'truckId=' + encodeURIComponent('' + truckId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckRequiredDocumentFiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckRequiredDocumentFiles(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckRequiredDocumentFiles(response: HttpResponseBase): Observable<CreateOrEditDocumentFileDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CreateOrEditDocumentFileDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditDocumentFileDto[]>(<any>null);
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  getDriverRequiredDocumentFiles(userId: string | null | undefined): Observable<CreateOrEditDocumentFileDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetDriverRequiredDocumentFiles?';
    if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDriverRequiredDocumentFiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDriverRequiredDocumentFiles(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDriverRequiredDocumentFiles(response: HttpResponseBase): Observable<CreateOrEditDocumentFileDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CreateOrEditDocumentFileDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditDocumentFileDto[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addTenantRequiredDocumentFiles(body: CreateOrEditDocumentFileDto[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/AddTenantRequiredDocumentFiles';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddTenantRequiredDocumentFiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddTenantRequiredDocumentFiles(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddTenantRequiredDocumentFiles(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllEditionsForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllEditionsForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllEditionsForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllEditionsForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllEditionsForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  accept(id: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/Accept?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @param reason (optional)
   * @return Success
   */
  reject(id: string | undefined, reason: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/Reject?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    if (reason !== undefined) url_ += 'reason=' + encodeURIComponent('' + reason) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTenantSubmittedRequiredDocumentsWithStatuses(): Observable<GetTenantSubmittedDocumnetForView[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetAllTenantSubmittedRequiredDocumentsWithStatuses';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTenantSubmittedRequiredDocumentsWithStatuses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTenantSubmittedRequiredDocumentsWithStatuses(<any>response_);
            } catch (e) {
              return <Observable<GetTenantSubmittedDocumnetForView[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTenantSubmittedDocumnetForView[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTenantSubmittedRequiredDocumentsWithStatuses(response: HttpResponseBase): Observable<GetTenantSubmittedDocumnetForView[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetTenantSubmittedDocumnetForView.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTenantSubmittedDocumnetForView[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isDocumentTypeNumberUnique(body: DocumentUniqueCheckOutput | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/IsDocumentTypeNumberUnique';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsDocumentTypeNumberUnique(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsDocumentTypeNumberUnique(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsDocumentTypeNumberUnique(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param entityId (optional)
   * @param body (optional)
   * @return Success
   */
  checkIfMissingDocumentFiles(entityId: string | null | undefined, body: DocumentsEntitiesEnum | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/CheckIfMissingDocumentFiles?';
    if (entityId !== undefined) url_ += 'entityId=' + encodeURIComponent('' + entityId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfMissingDocumentFiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfMissingDocumentFiles(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfMissingDocumentFiles(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @return Success
   */
  getTenantRequiredDocumentFilesTemplateForCreate(): Observable<CreateOrEditDocumentFileDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetTenantRequiredDocumentFilesTemplateForCreate';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenantRequiredDocumentFilesTemplateForCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenantRequiredDocumentFilesTemplateForCreate(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenantRequiredDocumentFilesTemplateForCreate(response: HttpResponseBase): Observable<CreateOrEditDocumentFileDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CreateOrEditDocumentFileDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditDocumentFileDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getTenentMissingDocuments(): Observable<CreateOrEditDocumentFileDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetTenentMissingDocuments';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenentMissingDocuments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenentMissingDocuments(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditDocumentFileDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenentMissingDocuments(response: HttpResponseBase): Observable<CreateOrEditDocumentFileDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CreateOrEditDocumentFileDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditDocumentFileDto[]>(<any>null);
  }

  /**
   * @param tenantId (optional)
   * @return Success
   */
  isAllRequiredDocumentsApproved(tenantId: number | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/IsAllRequiredDocumentsApproved?';
    if (tenantId === null) throw new Error("The parameter 'tenantId' cannot be null.");
    else if (tenantId !== undefined) url_ += 'tenantId=' + encodeURIComponent('' + tenantId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsAllRequiredDocumentsApproved(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsAllRequiredDocumentsApproved(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsAllRequiredDocumentsApproved(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @return Success
   */
  getDocumentEntitiesForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentFiles/GetDocumentEntitiesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentEntitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentEntitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentEntitiesForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class DocumentsEntitiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetDocumentsEntityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentsEntities/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetDocumentsEntityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetDocumentsEntityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentsEntityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetDocumentsEntityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetDocumentsEntityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentsEntityForView(id: number | undefined): Observable<GetDocumentsEntityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentsEntities/GetDocumentsEntityForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentsEntityForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentsEntityForView(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentsEntityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentsEntityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentsEntityForView(response: HttpResponseBase): Observable<GetDocumentsEntityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentsEntityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentsEntityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentsEntityForEdit(id: number | undefined): Observable<GetDocumentsEntityForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/DocumentsEntities/GetDocumentsEntityForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentsEntityForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentsEntityForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentsEntityForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentsEntityForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentsEntityForEdit(response: HttpResponseBase): Observable<GetDocumentsEntityForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentsEntityForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentsEntityForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditDocumentsEntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentsEntities/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentsEntities/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DocumentTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param isRequiredFilter (optional)
   * @param hasExpirationDateFilter (optional)
   * @param requiredFromFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    isRequiredFilter: number | undefined,
    hasExpirationDateFilter: number | undefined,
    requiredFromFilter: DocumentsEntitiesEnum | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (isRequiredFilter === null) throw new Error("The parameter 'isRequiredFilter' cannot be null.");
    else if (isRequiredFilter !== undefined) url_ += 'IsRequiredFilter=' + encodeURIComponent('' + isRequiredFilter) + '&';
    if (hasExpirationDateFilter === null) throw new Error("The parameter 'hasExpirationDateFilter' cannot be null.");
    else if (hasExpirationDateFilter !== undefined) url_ += 'HasExpirationDateFilter=' + encodeURIComponent('' + hasExpirationDateFilter) + '&';
    if (requiredFromFilter === null) throw new Error("The parameter 'requiredFromFilter' cannot be null.");
    else if (requiredFromFilter !== undefined) url_ += 'RequiredFromFilter=' + encodeURIComponent('' + requiredFromFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetDocumentTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetDocumentTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetDocumentTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetDocumentTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentTypeForView(id: number | undefined): Observable<GetDocumentTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetDocumentTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypeForView(response: HttpResponseBase): Observable<GetDocumentTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentTypeForEdit(id: number | undefined): Observable<GetDocumentTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetDocumentTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypeForEdit(response: HttpResponseBase): Observable<GetDocumentTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditDocumentTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param isRequiredFilter (optional)
   * @param hasExpirationDateFilter (optional)
   * @param requiredFromFilter (optional)
   * @return Success
   */
  getDocumentTypesToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    isRequiredFilter: number | undefined,
    hasExpirationDateFilter: number | undefined,
    requiredFromFilter: DocumentsEntitiesEnum | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetDocumentTypesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (isRequiredFilter === null) throw new Error("The parameter 'isRequiredFilter' cannot be null.");
    else if (isRequiredFilter !== undefined) url_ += 'IsRequiredFilter=' + encodeURIComponent('' + isRequiredFilter) + '&';
    if (hasExpirationDateFilter === null) throw new Error("The parameter 'hasExpirationDateFilter' cannot be null.");
    else if (hasExpirationDateFilter !== undefined) url_ += 'HasExpirationDateFilter=' + encodeURIComponent('' + hasExpirationDateFilter) + '&';
    if (requiredFromFilter === null) throw new Error("The parameter 'requiredFromFilter' cannot be null.");
    else if (requiredFromFilter !== undefined) url_ += 'RequiredFromFilter=' + encodeURIComponent('' + requiredFromFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllDocumentsEntitiesForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetAllDocumentsEntitiesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDocumentsEntitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDocumentsEntitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllDocumentsEntitiesForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param documentTypeId (optional)
   * @param body (optional)
   * @return Success
   */
  translate(documentTypeId: number | undefined, body: DocumentTypeTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/Translate?';
    if (documentTypeId === null) throw new Error("The parameter 'documentTypeId' cannot be null.");
    else if (documentTypeId !== undefined) url_ += 'documentTypeId=' + encodeURIComponent('' + documentTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTranslate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTranslate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processTranslate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getDocumentEntitiesForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/GetDocumentEntitiesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentEntitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentEntitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentEntitiesForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param documentTypeName (optional)
   * @param id (optional)
   * @return Success
   */
  isDocuemntTypeNameAvaliable(documentTypeName: string | null | undefined, id: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypes/IsDocuemntTypeNameAvaliable?';
    if (documentTypeName !== undefined) url_ += 'documentTypeName=' + encodeURIComponent('' + documentTypeName) + '&';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsDocuemntTypeNameAvaliable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsDocuemntTypeNameAvaliable(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsDocuemntTypeNameAvaliable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

@Injectable()
export class DocumentTypeTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param languageFilter (optional)
   * @param documentTypeDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    documentTypeDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetDocumentTypeTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (documentTypeDisplayNameFilter !== undefined)
      url_ += 'DocumentTypeDisplayNameFilter=' + encodeURIComponent('' + documentTypeDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetDocumentTypeTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetDocumentTypeTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentTypeTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetDocumentTypeTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetDocumentTypeTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentTypeTranslationForView(id: number | undefined): Observable<GetDocumentTypeTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/GetDocumentTypeTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypeTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypeTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentTypeTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentTypeTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypeTranslationForView(response: HttpResponseBase): Observable<GetDocumentTypeTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentTypeTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentTypeTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDocumentTypeTranslationForEdit(id: number | undefined): Observable<GetDocumentTypeTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/GetDocumentTypeTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypeTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypeTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetDocumentTypeTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDocumentTypeTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypeTranslationForEdit(response: HttpResponseBase): Observable<GetDocumentTypeTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDocumentTypeTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDocumentTypeTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditDocumentTypeTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param languageFilter (optional)
   * @param documentTypeDisplayNameFilter (optional)
   * @return Success
   */
  getDocumentTypeTranslationsToExcel(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    documentTypeDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/GetDocumentTypeTranslationsToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (documentTypeDisplayNameFilter !== undefined)
      url_ += 'DocumentTypeDisplayNameFilter=' + encodeURIComponent('' + documentTypeDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentTypeTranslationsToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentTypeTranslationsToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentTypeTranslationsToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllDocumentTypeForTableDropdown(): Observable<DocumentTypeTranslationDocumentTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/DocumentTypeTranslations/GetAllDocumentTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDocumentTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDocumentTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<DocumentTypeTranslationDocumentTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<DocumentTypeTranslationDocumentTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllDocumentTypeForTableDropdown(response: HttpResponseBase): Observable<DocumentTypeTranslationDocumentTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DocumentTypeTranslationDocumentTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DocumentTypeTranslationDocumentTypeLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class DriverServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getDriverDetails(): Observable<DriverDetailDto> {
    let url_ = this.baseUrl + '/api/services/app/Driver/GetDriverDetails';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDriverDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDriverDetails(<any>response_);
            } catch (e) {
              return <Observable<DriverDetailDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DriverDetailDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDriverDetails(response: HttpResponseBase): Observable<DriverDetailDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DriverDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DriverDetailDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  refreshDeviceToken(body: UserDeviceTokenDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Driver/RefreshDeviceToken';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshDeviceToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshDeviceToken(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefreshDeviceToken(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DynamicEntityParameterDefinitionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAllAllowedInputTypeNames(): Observable<string[]> {
    let url_ = this.baseUrl + '/api/services/app/DynamicEntityParameterDefinition/GetAllAllowedInputTypeNames';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllAllowedInputTypeNames(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllAllowedInputTypeNames(<any>response_);
            } catch (e) {
              return <Observable<string[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<string[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllEntities(): Observable<string[]> {
    let url_ = this.baseUrl + '/api/services/app/DynamicEntityParameterDefinition/GetAllEntities';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllEntities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllEntities(<any>response_);
            } catch (e) {
              return <Observable<string[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<string[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string[]>(<any>null);
  }
}

@Injectable()
export class DynamicParameterServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<DynamicParameterDto> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DynamicParameterDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DynamicParameterDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DynamicParameterDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DynamicParameterDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DynamicParameterDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<ListResultDtoOfDynamicParameterDto> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/GetAll';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfDynamicParameterDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfDynamicParameterDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicParameterDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfDynamicParameterDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfDynamicParameterDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: DynamicParameterDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/Add';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: DynamicParameterDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param name (optional)
   * @return Success
   */
  findAllowedInputType(name: string | null | undefined): Observable<IInputType> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameter/FindAllowedInputType?';
    if (name !== undefined) url_ += 'name=' + encodeURIComponent('' + name) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFindAllowedInputType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFindAllowedInputType(<any>response_);
            } catch (e) {
              return <Observable<IInputType>>(<any>_observableThrow(e));
            }
          } else return <Observable<IInputType>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IInputType.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<IInputType>(<any>null);
  }
}

@Injectable()
export class DynamicParameterValueServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<DynamicParameterValueDto> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameterValue/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DynamicParameterValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DynamicParameterValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DynamicParameterValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DynamicParameterValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DynamicParameterValueDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getAllValuesOfDynamicParameter(id: number | undefined): Observable<ListResultDtoOfDynamicParameterValueDto> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameterValue/GetAllValuesOfDynamicParameter?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllValuesOfDynamicParameter(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllValuesOfDynamicParameter(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfDynamicParameterValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfDynamicParameterValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllValuesOfDynamicParameter(response: HttpResponseBase): Observable<ListResultDtoOfDynamicParameterValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfDynamicParameterValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfDynamicParameterValueDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: DynamicParameterValueDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameterValue/Add';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: DynamicParameterValueDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameterValue/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/DynamicParameterValue/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EditionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getEditions(): Observable<ListResultDtoOfEditionListDto> {
    let url_ = this.baseUrl + '/api/services/app/Edition/GetEditions';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditions(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfEditionListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfEditionListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Edition/GetEditionForEdit?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditionForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditionForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetEditionEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetEditionEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetEditionEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetEditionEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createEdition(body: CreateEditionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Edition/CreateEdition';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateEdition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateEdition(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateEdition(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Edition/UpdateEdition';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateEdition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateEdition(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteEdition(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Edition/DeleteEdition?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteEdition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteEdition(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Edition/MoveTenantsToAnotherEdition';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMoveTenantsToAnotherEdition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMoveTenantsToAnotherEdition(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param selectedEditionId (optional)
   * @param addAllItem (optional)
   * @param onlyFreeItems (optional)
   * @return Success
   */
  getEditionComboboxItems(
    selectedEditionId: number | null | undefined,
    addAllItem: boolean | undefined,
    onlyFreeItems: boolean | undefined
  ): Observable<SubscribableEditionComboboxItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Edition/GetEditionComboboxItems?';
    if (selectedEditionId !== undefined) url_ += 'selectedEditionId=' + encodeURIComponent('' + selectedEditionId) + '&';
    if (addAllItem === null) throw new Error("The parameter 'addAllItem' cannot be null.");
    else if (addAllItem !== undefined) url_ += 'addAllItem=' + encodeURIComponent('' + addAllItem) + '&';
    if (onlyFreeItems === null) throw new Error("The parameter 'onlyFreeItems' cannot be null.");
    else if (onlyFreeItems !== undefined) url_ += 'onlyFreeItems=' + encodeURIComponent('' + onlyFreeItems) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditionComboboxItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditionComboboxItems(<any>response_);
            } catch (e) {
              return <Observable<SubscribableEditionComboboxItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscribableEditionComboboxItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
  }

  /**
   * @param editionId (optional)
   * @return Success
   */
  getTenantCount(editionId: number | undefined): Observable<number> {
    let url_ = this.baseUrl + '/api/services/app/Edition/GetTenantCount?';
    if (editionId === null) throw new Error("The parameter 'editionId' cannot be null.");
    else if (editionId !== undefined) url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenantCount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenantCount(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }
}

@Injectable()
export class EntityDynamicParameterServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EntityDynamicParameterDto> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EntityDynamicParameterDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EntityDynamicParameterDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EntityDynamicParameterDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EntityDynamicParameterDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EntityDynamicParameterDto>(<any>null);
  }

  /**
   * @param entityFullName (optional)
   * @return Success
   */
  getAllParametersOfAnEntity(entityFullName: string | null | undefined): Observable<ListResultDtoOfEntityDynamicParameterDto> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/GetAllParametersOfAnEntity?';
    if (entityFullName !== undefined) url_ += 'EntityFullName=' + encodeURIComponent('' + entityFullName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllParametersOfAnEntity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllParametersOfAnEntity(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfEntityDynamicParameterDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfEntityDynamicParameterDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllParametersOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfEntityDynamicParameterDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfEntityDynamicParameterDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfEntityDynamicParameterDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<ListResultDtoOfEntityDynamicParameterDto> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/GetAll';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfEntityDynamicParameterDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfEntityDynamicParameterDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfEntityDynamicParameterDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfEntityDynamicParameterDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfEntityDynamicParameterDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: EntityDynamicParameterDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/Add';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EntityDynamicParameterDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameter/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EntityDynamicParameterValueServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EntityDynamicParameterValueDto> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/Get?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EntityDynamicParameterValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EntityDynamicParameterValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EntityDynamicParameterValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EntityDynamicParameterValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EntityDynamicParameterValueDto>(<any>null);
  }

  /**
   * @param entityId (optional)
   * @param parameterId (optional)
   * @return Success
   */
  getAll(entityId: string | null | undefined, parameterId: number | undefined): Observable<ListResultDtoOfEntityDynamicParameterValueDto> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/GetAll?';
    if (entityId !== undefined) url_ += 'EntityId=' + encodeURIComponent('' + entityId) + '&';
    if (parameterId === null) throw new Error("The parameter 'parameterId' cannot be null.");
    else if (parameterId !== undefined) url_ += 'ParameterId=' + encodeURIComponent('' + parameterId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfEntityDynamicParameterValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfEntityDynamicParameterValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfEntityDynamicParameterValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfEntityDynamicParameterValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfEntityDynamicParameterValueDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: EntityDynamicParameterValueDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/Add';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EntityDynamicParameterValueDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllEntityDynamicParameterValues(entityFullName: string, entityId: string): Observable<GetAllEntityDynamicParameterValuesOutput> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/GetAllEntityDynamicParameterValues?';
    if (entityFullName === undefined || entityFullName === null)
      throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
    else url_ += 'EntityFullName=' + encodeURIComponent('' + entityFullName) + '&';
    if (entityId === undefined || entityId === null) throw new Error("The parameter 'entityId' must be defined and cannot be null.");
    else url_ += 'EntityId=' + encodeURIComponent('' + entityId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllEntityDynamicParameterValues(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllEntityDynamicParameterValues(<any>response_);
            } catch (e) {
              return <Observable<GetAllEntityDynamicParameterValuesOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllEntityDynamicParameterValuesOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllEntityDynamicParameterValues(response: HttpResponseBase): Observable<GetAllEntityDynamicParameterValuesOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetAllEntityDynamicParameterValuesOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllEntityDynamicParameterValuesOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/InsertOrUpdateAllValues';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInsertOrUpdateAllValues(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInsertOrUpdateAllValues(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  cleanValues(body: CleanValuesInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/EntityDynamicParameterValue/CleanValues';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCleanValues(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCleanValues(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCleanValues(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class FacilitiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param adressFilter (optional)
   * @param maxLongitudeFilter (optional)
   * @param minLongitudeFilter (optional)
   * @param maxLatitudeFilter (optional)
   * @param minLatitudeFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    adressFilter: string | null | undefined,
    maxLongitudeFilter: number | null | undefined,
    minLongitudeFilter: number | null | undefined,
    maxLatitudeFilter: number | null | undefined,
    minLatitudeFilter: number | null | undefined,
    cityDisplayNameFilter: string | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetFacilityForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (adressFilter !== undefined) url_ += 'AdressFilter=' + encodeURIComponent('' + adressFilter) + '&';
    if (maxLongitudeFilter !== undefined) url_ += 'MaxLongitudeFilter=' + encodeURIComponent('' + maxLongitudeFilter) + '&';
    if (minLongitudeFilter !== undefined) url_ += 'MinLongitudeFilter=' + encodeURIComponent('' + minLongitudeFilter) + '&';
    if (maxLatitudeFilter !== undefined) url_ += 'MaxLatitudeFilter=' + encodeURIComponent('' + maxLatitudeFilter) + '&';
    if (minLatitudeFilter !== undefined) url_ += 'MinLatitudeFilter=' + encodeURIComponent('' + minLatitudeFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetFacilityForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetFacilityForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetFacilityForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetFacilityForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetFacilityForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFacilityForView(id: number | undefined): Observable<GetFacilityForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/GetFacilityForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFacilityForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFacilityForView(<any>response_);
            } catch (e) {
              return <Observable<GetFacilityForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetFacilityForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFacilityForView(response: HttpResponseBase): Observable<GetFacilityForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetFacilityForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetFacilityForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFacilityForEdit(id: number | undefined): Observable<GetFacilityForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/GetFacilityForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFacilityForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFacilityForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetFacilityForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetFacilityForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFacilityForEdit(response: HttpResponseBase): Observable<GetFacilityForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetFacilityForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetFacilityForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditFacilityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param adressFilter (optional)
   * @param maxLongitudeFilter (optional)
   * @param minLongitudeFilter (optional)
   * @param maxLatitudeFilter (optional)
   * @param minLatitudeFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @return Success
   */
  getFacilitiesToExcel(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    adressFilter: string | null | undefined,
    maxLongitudeFilter: number | null | undefined,
    minLongitudeFilter: number | null | undefined,
    maxLatitudeFilter: number | null | undefined,
    minLatitudeFilter: number | null | undefined,
    cityDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/GetFacilitiesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (adressFilter !== undefined) url_ += 'AdressFilter=' + encodeURIComponent('' + adressFilter) + '&';
    if (maxLongitudeFilter !== undefined) url_ += 'MaxLongitudeFilter=' + encodeURIComponent('' + maxLongitudeFilter) + '&';
    if (minLongitudeFilter !== undefined) url_ += 'MinLongitudeFilter=' + encodeURIComponent('' + minLongitudeFilter) + '&';
    if (maxLatitudeFilter !== undefined) url_ += 'MaxLatitudeFilter=' + encodeURIComponent('' + maxLatitudeFilter) + '&';
    if (minLatitudeFilter !== undefined) url_ += 'MinLatitudeFilter=' + encodeURIComponent('' + minLatitudeFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFacilitiesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFacilitiesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFacilitiesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCityForTableDropdown(): Observable<FacilityCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Facilities/GetAllCityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<FacilityCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<FacilityCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<FacilityCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(FacilityCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FacilityCityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class FriendshipServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
    let url_ = this.baseUrl + '/api/services/app/Friendship/CreateFriendshipRequest';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateFriendshipRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateFriendshipRequest(<any>response_);
            } catch (e) {
              return <Observable<FriendDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FriendDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FriendDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FriendDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
    let url_ = this.baseUrl + '/api/services/app/Friendship/CreateFriendshipRequestByUserName';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateFriendshipRequestByUserName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateFriendshipRequestByUserName(<any>response_);
            } catch (e) {
              return <Observable<FriendDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FriendDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FriendDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FriendDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  blockUser(body: BlockUserInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Friendship/BlockUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processBlockUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processBlockUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processBlockUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  unblockUser(body: UnblockUserInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Friendship/UnblockUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnblockUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnblockUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUnblockUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Friendship/AcceptFriendshipRequest';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAcceptFriendshipRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAcceptFriendshipRequest(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class GoodCategoriesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetGoodCategoryForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetGoodCategoryForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetGoodCategoryForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGoodCategoryForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetGoodCategoryForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetGoodCategoryForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getGoodCategoryForView(id: number | undefined): Observable<GetGoodCategoryForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/GetGoodCategoryForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodCategoryForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodCategoryForView(<any>response_);
            } catch (e) {
              return <Observable<GetGoodCategoryForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodCategoryForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodCategoryForView(response: HttpResponseBase): Observable<GetGoodCategoryForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetGoodCategoryForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodCategoryForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getGoodCategoryForEdit(id: number | undefined): Observable<GetGoodCategoryForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/GetGoodCategoryForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodCategoryForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodCategoryForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetGoodCategoryForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodCategoryForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodCategoryForEdit(response: HttpResponseBase): Observable<GetGoodCategoryForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetGoodCategoryForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodCategoryForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditGoodCategoryDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @return Success
   */
  getGoodCategoriesToExcel(filter: string | null | undefined, displayNameFilter: string | null | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/GetGoodCategoriesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodCategoriesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodCategoriesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllGoodsCategoriesForDropDown(): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/GoodCategories/GetAllGoodsCategoriesForDropDown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllGoodsCategoriesForDropDown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllGoodsCategoriesForDropDown(<any>response_);
            } catch (e) {
              return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllGoodsCategoriesForDropDown(response: HttpResponseBase): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllGoodsCategoriesForDropDownOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllGoodsCategoriesForDropDownOutput[]>(<any>null);
  }
}

@Injectable()
export class GoodsDetailsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param descriptionFilter (optional)
   * @param quantityFilter (optional)
   * @param weightFilter (optional)
   * @param dimentionsFilter (optional)
   * @param isDangerousGoodFilter (optional)
   * @param dangerousGoodsCodeFilter (optional)
   * @param goodCategoryDisplayNameFilter (optional)
   * @param routPointId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    descriptionFilter: string | null | undefined,
    quantityFilter: number | undefined,
    weightFilter: number | null | undefined,
    dimentionsFilter: string | null | undefined,
    isDangerousGoodFilter: number | undefined,
    dangerousGoodsCodeFilter: string | null | undefined,
    goodCategoryDisplayNameFilter: string | null | undefined,
    routPointId: number | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetGoodsDetailForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (descriptionFilter !== undefined) url_ += 'DescriptionFilter=' + encodeURIComponent('' + descriptionFilter) + '&';
    if (quantityFilter === null) throw new Error("The parameter 'quantityFilter' cannot be null.");
    else if (quantityFilter !== undefined) url_ += 'QuantityFilter=' + encodeURIComponent('' + quantityFilter) + '&';
    if (weightFilter !== undefined) url_ += 'WeightFilter=' + encodeURIComponent('' + weightFilter) + '&';
    if (dimentionsFilter !== undefined) url_ += 'DimentionsFilter=' + encodeURIComponent('' + dimentionsFilter) + '&';
    if (isDangerousGoodFilter === null) throw new Error("The parameter 'isDangerousGoodFilter' cannot be null.");
    else if (isDangerousGoodFilter !== undefined) url_ += 'IsDangerousGoodFilter=' + encodeURIComponent('' + isDangerousGoodFilter) + '&';
    if (dangerousGoodsCodeFilter !== undefined) url_ += 'DangerousGoodsCodeFilter=' + encodeURIComponent('' + dangerousGoodsCodeFilter) + '&';
    if (goodCategoryDisplayNameFilter !== undefined)
      url_ += 'GoodCategoryDisplayNameFilter=' + encodeURIComponent('' + goodCategoryDisplayNameFilter) + '&';
    if (routPointId === null) throw new Error("The parameter 'routPointId' cannot be null.");
    else if (routPointId !== undefined) url_ += 'RoutPointId=' + encodeURIComponent('' + routPointId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetGoodsDetailForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetGoodsDetailForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGoodsDetailForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetGoodsDetailForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetGoodsDetailForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getGoodsDetailForView(id: number | undefined): Observable<GetGoodsDetailForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetGoodsDetailForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodsDetailForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodsDetailForView(<any>response_);
            } catch (e) {
              return <Observable<GetGoodsDetailForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodsDetailForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodsDetailForView(response: HttpResponseBase): Observable<GetGoodsDetailForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetGoodsDetailForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodsDetailForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getGoodsDetailForEdit(id: number | undefined): Observable<GetGoodsDetailForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetGoodsDetailForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodsDetailForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodsDetailForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetGoodsDetailForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodsDetailForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodsDetailForEdit(response: HttpResponseBase): Observable<GetGoodsDetailForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetGoodsDetailForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodsDetailForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditGoodsDetailDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param descriptionFilter (optional)
   * @param quantityFilter (optional)
   * @param weightFilter (optional)
   * @param dimentionsFilter (optional)
   * @param isDangerousGoodFilter (optional)
   * @param dangerousGoodsCodeFilter (optional)
   * @param goodCategoryDisplayNameFilter (optional)
   * @return Success
   */
  getGoodsDetailsToExcel(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    descriptionFilter: string | null | undefined,
    quantityFilter: number | undefined,
    weightFilter: number | null | undefined,
    dimentionsFilter: string | null | undefined,
    isDangerousGoodFilter: number | undefined,
    dangerousGoodsCodeFilter: string | null | undefined,
    goodCategoryDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetGoodsDetailsToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (descriptionFilter !== undefined) url_ += 'DescriptionFilter=' + encodeURIComponent('' + descriptionFilter) + '&';
    if (quantityFilter === null) throw new Error("The parameter 'quantityFilter' cannot be null.");
    else if (quantityFilter !== undefined) url_ += 'QuantityFilter=' + encodeURIComponent('' + quantityFilter) + '&';
    if (weightFilter !== undefined) url_ += 'WeightFilter=' + encodeURIComponent('' + weightFilter) + '&';
    if (dimentionsFilter !== undefined) url_ += 'DimentionsFilter=' + encodeURIComponent('' + dimentionsFilter) + '&';
    if (isDangerousGoodFilter === null) throw new Error("The parameter 'isDangerousGoodFilter' cannot be null.");
    else if (isDangerousGoodFilter !== undefined) url_ += 'IsDangerousGoodFilter=' + encodeURIComponent('' + isDangerousGoodFilter) + '&';
    if (dangerousGoodsCodeFilter !== undefined) url_ += 'DangerousGoodsCodeFilter=' + encodeURIComponent('' + dangerousGoodsCodeFilter) + '&';
    if (goodCategoryDisplayNameFilter !== undefined)
      url_ += 'GoodCategoryDisplayNameFilter=' + encodeURIComponent('' + goodCategoryDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoodsDetailsToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoodsDetailsToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGoodsDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param fatherId (optional)
   * @return Success
   */
  getAllGoodCategoryForTableDropdown(fatherId: number | null | undefined): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetAllGoodCategoryForTableDropdown?';
    if (fatherId !== undefined) url_ += 'fatherId=' + encodeURIComponent('' + fatherId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllGoodCategoryForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllGoodCategoryForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllGoodCategoryForTableDropdown(response: HttpResponseBase): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllGoodsCategoriesForDropDownOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllGoodsCategoriesForDropDownOutput[]>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getShippingrequestGoodsDetailsForSingleDropWaybill(shippingRequestTripId: number | undefined): Observable<GetGoodsDetailsForWaybillsOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetShippingrequestGoodsDetailsForSingleDropWaybill?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingrequestGoodsDetailsForSingleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingrequestGoodsDetailsForSingleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetGoodsDetailsForWaybillsOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodsDetailsForWaybillsOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingrequestGoodsDetailsForSingleDropWaybill(response: HttpResponseBase): Observable<GetGoodsDetailsForWaybillsOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetGoodsDetailsForWaybillsOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodsDetailsForWaybillsOutput[]>(<any>null);
  }

  /**
   * @param routPointId (optional)
   * @return Success
   */
  getShippingrequestGoodsDetailsForMultipleDropWaybill(routPointId: number | undefined): Observable<GetGoodsDetailsForWaybillsOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/GoodsDetails/GetShippingrequestGoodsDetailsForMultipleDropWaybill?';
    if (routPointId === null) throw new Error("The parameter 'routPointId' cannot be null.");
    else if (routPointId !== undefined) url_ += 'RoutPointId=' + encodeURIComponent('' + routPointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingrequestGoodsDetailsForMultipleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingrequestGoodsDetailsForMultipleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetGoodsDetailsForWaybillsOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGoodsDetailsForWaybillsOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingrequestGoodsDetailsForMultipleDropWaybill(response: HttpResponseBase): Observable<GetGoodsDetailsForWaybillsOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetGoodsDetailsForWaybillsOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGoodsDetailsForWaybillsOutput[]>(<any>null);
  }
}

@Injectable()
export class ShippingRequestDriverServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  uploadPointDeliveryDocument(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/UploadPointDeliveryDocument';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadPointDeliveryDocument(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadPointDeliveryDocument(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadPointDeliveryDocument(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param status (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    status: ShippingRequestTripDriverLoadStatusDto | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfShippingRequestTripDriverListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/GetAll?';
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfShippingRequestTripDriverListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfShippingRequestTripDriverListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfShippingRequestTripDriverListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfShippingRequestTripDriverListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfShippingRequestTripDriverListDto>(<any>null);
  }

  /**
   * @param tripId (optional)
   * @param isAccepted (optional)
   * @return Success
   */
  getDetail(tripId: number | undefined, isAccepted: boolean | undefined): Observable<ShippingRequestTripDriverDetailsDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/GetDetail?';
    if (tripId === null) throw new Error("The parameter 'tripId' cannot be null.");
    else if (tripId !== undefined) url_ += 'TripId=' + encodeURIComponent('' + tripId) + '&';
    if (isAccepted === null) throw new Error("The parameter 'isAccepted' cannot be null.");
    else if (isAccepted !== undefined) url_ += 'IsAccepted=' + encodeURIComponent('' + isAccepted) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDetail(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestTripDriverDetailsDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestTripDriverDetailsDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDetail(response: HttpResponseBase): Observable<ShippingRequestTripDriverDetailsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShippingRequestTripDriverDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestTripDriverDetailsDto>(<any>null);
  }

  /**
   * @param pointId (optional)
   * @return Success
   */
  getDropOffDetail(pointId: number | undefined): Observable<RoutDropOffDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/GetDropOffDetail?';
    if (pointId === null) throw new Error("The parameter 'pointId' cannot be null.");
    else if (pointId !== undefined) url_ += 'PointId=' + encodeURIComponent('' + pointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDropOffDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDropOffDetail(<any>response_);
            } catch (e) {
              return <Observable<RoutDropOffDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoutDropOffDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDropOffDetail(response: HttpResponseBase): Observable<RoutDropOffDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoutDropOffDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoutDropOffDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  startTrip(body: ShippingRequestTripDriverStartInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/StartTrip';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStartTrip(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStartTrip(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processStartTrip(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  changeTripStatus(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/ChangeTripStatus';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeTripStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeTripStatus(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeTripStatus(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param pointId (optional)
   * @return Success
   */
  gotoNextLocation(pointId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/GotoNextLocation?';
    if (pointId === null) throw new Error("The parameter 'pointId' cannot be null.");
    else if (pointId !== undefined) url_ += 'PointId=' + encodeURIComponent('' + pointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGotoNextLocation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGotoNextLocation(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGotoNextLocation(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param code (optional)
   * @return Success
   */
  confirmReceiverCode(code: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/ConfirmReceiverCode?';
    if (code !== undefined) url_ += 'Code=' + encodeURIComponent('' + code) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmReceiverCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmReceiverCode(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processConfirmReceiverCode(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param pointId (optional)
   * @param rate (optional)
   * @param note (optional)
   * @return Success
   */
  setRating(pointId: number | undefined, rate: number | undefined, note: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/SetRating?';
    if (pointId === null) throw new Error("The parameter 'pointId' cannot be null.");
    else if (pointId !== undefined) url_ += 'PointId=' + encodeURIComponent('' + pointId) + '&';
    if (rate === null) throw new Error("The parameter 'rate' cannot be null.");
    else if (rate !== undefined) url_ += 'Rate=' + encodeURIComponent('' + rate) + '&';
    if (note !== undefined) url_ += 'Note=' + encodeURIComponent('' + note) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetRating(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetRating(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetRating(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param tripId (optional)
   * @return Success
   */
  accepted(tripId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/Accepted?';
    if (tripId === null) throw new Error("The parameter 'tripId' cannot be null.");
    else if (tripId !== undefined) url_ += 'TripId=' + encodeURIComponent('' + tripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccepted(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccepted(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccepted(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param tripId (optional)
   * @return Success
   */
  reset(tripId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/Reset?';
    if (tripId === null) throw new Error("The parameter 'tripId' cannot be null.");
    else if (tripId !== undefined) url_ += 'TripId=' + encodeURIComponent('' + tripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReset(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReset(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReset(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param tripId (optional)
   * @return Success
   */
  pushNotification(tripId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDriver/PushNotification?';
    if (tripId === null) throw new Error("The parameter 'tripId' cannot be null.");
    else if (tripId !== undefined) url_ += 'TripId=' + encodeURIComponent('' + tripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPushNotification(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPushNotification(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPushNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class HostDashboardServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @return Success
   */
  getTopStatsData(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<TopStatsData> {
    let url_ = this.baseUrl + '/api/services/app/HostDashboard/GetTopStatsData?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTopStatsData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTopStatsData(<any>response_);
            } catch (e) {
              return <Observable<TopStatsData>>(<any>_observableThrow(e));
            }
          } else return <Observable<TopStatsData>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TopStatsData.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TopStatsData>(<any>null);
  }

  /**
   * @return Success
   */
  getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
    let url_ = this.baseUrl + '/api/services/app/HostDashboard/GetRecentTenantsData';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRecentTenantsData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRecentTenantsData(<any>response_);
            } catch (e) {
              return <Observable<GetRecentTenantsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRecentTenantsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRecentTenantsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRecentTenantsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
    let url_ = this.baseUrl + '/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubscriptionExpiringTenantsData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubscriptionExpiringTenantsData(<any>response_);
            } catch (e) {
              return <Observable<GetExpiringTenantsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetExpiringTenantsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetExpiringTenantsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetExpiringTenantsOutput>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @return Success
   */
  getIncomeStatistics(
    incomeStatisticsDateInterval: ChartDateInterval,
    startDate: moment.Moment | undefined,
    endDate: moment.Moment | undefined
  ): Observable<GetIncomeStatisticsDataOutput> {
    let url_ = this.baseUrl + '/api/services/app/HostDashboard/GetIncomeStatistics?';
    if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
      throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
    else url_ += 'IncomeStatisticsDateInterval=' + encodeURIComponent('' + incomeStatisticsDateInterval) + '&';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetIncomeStatistics(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetIncomeStatistics(<any>response_);
            } catch (e) {
              return <Observable<GetIncomeStatisticsDataOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetIncomeStatisticsDataOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
  }

  /**
   * @param startDate (optional)
   * @param endDate (optional)
   * @return Success
   */
  getEditionTenantStatistics(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetEditionTenantStatisticsOutput> {
    let url_ = this.baseUrl + '/api/services/app/HostDashboard/GetEditionTenantStatistics?';
    if (startDate === null) throw new Error("The parameter 'startDate' cannot be null.");
    else if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate === null) throw new Error("The parameter 'endDate' cannot be null.");
    else if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditionTenantStatistics(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditionTenantStatistics(<any>response_);
            } catch (e) {
              return <Observable<GetEditionTenantStatisticsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetEditionTenantStatisticsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
  }
}

@Injectable()
export class HostSettingsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAllSettings(): Observable<HostSettingsEditDto> {
    let url_ = this.baseUrl + '/api/services/app/HostSettings/GetAllSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSettings(<any>response_);
            } catch (e) {
              return <Observable<HostSettingsEditDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<HostSettingsEditDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HostSettingsEditDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<HostSettingsEditDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/HostSettings/UpdateAllSettings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateAllSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateAllSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  testUnifonicSms(body: TestUnifonicSmsInput | undefined): Observable<UnifonicResponseRoot> {
    let url_ = this.baseUrl + '/api/services/app/HostSettings/TestUnifonicSms';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTestUnifonicSms(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTestUnifonicSms(<any>response_);
            } catch (e) {
              return <Observable<UnifonicResponseRoot>>(<any>_observableThrow(e));
            }
          } else return <Observable<UnifonicResponseRoot>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processTestUnifonicSms(response: HttpResponseBase): Observable<UnifonicResponseRoot> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UnifonicResponseRoot.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UnifonicResponseRoot>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/HostSettings/SendTestEmail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendTestEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendTestEmail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
    let url_ = this.baseUrl + '/api/services/app/HostSettings/GetEnabledSocialLoginSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEnabledSocialLoginSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEnabledSocialLoginSettings(<any>response_);
            } catch (e) {
              return <Observable<ExternalLoginSettingsDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalLoginSettingsDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalLoginSettingsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalLoginSettingsDto>(<any>null);
  }
}

@Injectable()
export class InstallServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setup(body: InstallDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Install/Setup';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetup(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetup(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetup(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAppSettingsJson(): Observable<AppSettingsJsonDto> {
    let url_ = this.baseUrl + '/api/services/app/Install/GetAppSettingsJson';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAppSettingsJson(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAppSettingsJson(<any>response_);
            } catch (e) {
              return <Observable<AppSettingsJsonDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<AppSettingsJsonDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AppSettingsJsonDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AppSettingsJsonDto>(<any>null);
  }

  /**
   * @return Success
   */
  checkDatabase(): Observable<CheckDatabaseOutput> {
    let url_ = this.baseUrl + '/api/services/app/Install/CheckDatabase';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckDatabase(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckDatabase(<any>response_);
            } catch (e) {
              return <Observable<CheckDatabaseOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<CheckDatabaseOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CheckDatabaseOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CheckDatabaseOutput>(<any>null);
  }
}

@Injectable()
export class InvoiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/GetInvoiceInfo?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetInvoiceInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetInvoiceInfo(<any>response_);
            } catch (e) {
              return <Observable<InvoiceDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<InvoiceDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = InvoiceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<InvoiceDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/CreateInvoice';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateInvoice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateInvoice(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param tenantId (optional)
   * @param periodId (optional)
   * @param isPaid (optional)
   * @param accountType (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param dueFromDate (optional)
   * @param dueToDate (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    tenantId: number | null | undefined,
    periodId: number | null | undefined,
    isPaid: boolean | null | undefined,
    accountType: InvoiceAccountType | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    dueFromDate: moment.Moment | null | undefined,
    dueToDate: moment.Moment | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfInvoiceListDto> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/GetAll?';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (periodId !== undefined) url_ += 'PeriodId=' + encodeURIComponent('' + periodId) + '&';
    if (isPaid !== undefined) url_ += 'IsPaid=' + encodeURIComponent('' + isPaid) + '&';
    if (accountType === null) throw new Error("The parameter 'accountType' cannot be null.");
    else if (accountType !== undefined) url_ += 'AccountType=' + encodeURIComponent('' + accountType) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (dueFromDate !== undefined) url_ += 'DueFromDate=' + encodeURIComponent(dueFromDate ? '' + dueFromDate.toJSON() : '') + '&';
    if (dueToDate !== undefined) url_ += 'DueToDate=' + encodeURIComponent(dueToDate ? '' + dueToDate.toJSON() : '') + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfInvoiceListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfInvoiceListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfInvoiceListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfInvoiceListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfInvoiceListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<InvoiceInfoDto> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/GetById?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<InvoiceInfoDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<InvoiceInfoDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<InvoiceInfoDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = InvoiceInfoDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<InvoiceInfoDto>(<any>null);
  }

  /**
   * @param invoiceId (optional)
   * @return Success
   */
  makePaid(invoiceId: number | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/MakePaid?';
    if (invoiceId === null) throw new Error("The parameter 'invoiceId' cannot be null.");
    else if (invoiceId !== undefined) url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMakePaid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMakePaid(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMakePaid(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param invoiceId (optional)
   * @return Success
   */
  makeUnPaid(invoiceId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/MakeUnPaid?';
    if (invoiceId === null) throw new Error("The parameter 'invoiceId' cannot be null.");
    else if (invoiceId !== undefined) url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMakeUnPaid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMakeUnPaid(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMakeUnPaid(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  onDemand(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/OnDemand?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOnDemand(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOnDemand(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOnDemand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param invoiceId (optional)
   * @return Success
   */
  getInvoiceReportInfo(invoiceId: number | undefined): Observable<InvoiceInfoDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/GetInvoiceReportInfo?';
    if (invoiceId === null) throw new Error("The parameter 'invoiceId' cannot be null.");
    else if (invoiceId !== undefined) url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetInvoiceReportInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetInvoiceReportInfo(<any>response_);
            } catch (e) {
              return <Observable<InvoiceInfoDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<InvoiceInfoDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetInvoiceReportInfo(response: HttpResponseBase): Observable<InvoiceInfoDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(InvoiceInfoDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<InvoiceInfoDto[]>(<any>null);
  }

  /**
   * @param invoiceId (optional)
   * @return Success
   */
  getInvoiceShippingRequestsReportInfo(invoiceId: number | undefined): Observable<InvoiceItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/GetInvoiceShippingRequestsReportInfo?';
    if (invoiceId === null) throw new Error("The parameter 'invoiceId' cannot be null.");
    else if (invoiceId !== undefined) url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetInvoiceShippingRequestsReportInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetInvoiceShippingRequestsReportInfo(<any>response_);
            } catch (e) {
              return <Observable<InvoiceItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<InvoiceItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetInvoiceShippingRequestsReportInfo(response: HttpResponseBase): Observable<InvoiceItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(InvoiceItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<InvoiceItemDto[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: InvoiceFilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Invoice/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class InvoicePaymentMethodServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @return Success
   */
  getAll(filter: string | null | undefined, sorting: string | null | undefined): Observable<ListResultDtoOfInvoicePaymentMethodListDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePaymentMethod/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfInvoicePaymentMethodListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfInvoicePaymentMethodListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfInvoicePaymentMethodListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfInvoicePaymentMethodListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfInvoicePaymentMethodListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditInvoicePaymentMethod | undefined): Observable<CreateOrEditInvoicePaymentMethod> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePaymentMethod/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditInvoicePaymentMethod>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditInvoicePaymentMethod>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<CreateOrEditInvoicePaymentMethod> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditInvoicePaymentMethod.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditInvoicePaymentMethod>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePaymentMethod/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class InvoicePeriodServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @return Success
   */
  getAll(filter: string | null | undefined, sorting: string | null | undefined): Observable<ListResultDtoOfInvoicePeriodDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfInvoicePeriodDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfInvoicePeriodDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfInvoicePeriodDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfInvoicePeriodDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfInvoicePeriodDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCommon(): Observable<PeriodCommonDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/GetAllCommon';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCommon(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCommon(<any>response_);
            } catch (e) {
              return <Observable<PeriodCommonDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PeriodCommonDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCommon(response: HttpResponseBase): Observable<PeriodCommonDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PeriodCommonDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PeriodCommonDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createEdit(body: InvoicePeriodDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/CreateEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: InvoicePeriodDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param periodId (optional)
   * @param isEnabled (optional)
   * @return Success
   */
  enabled(periodId: number | undefined, isEnabled: boolean | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/Enabled?';
    if (periodId === null) throw new Error("The parameter 'periodId' cannot be null.");
    else if (periodId !== undefined) url_ += 'PeriodId=' + encodeURIComponent('' + periodId) + '&';
    if (isEnabled === null) throw new Error("The parameter 'isEnabled' cannot be null.");
    else if (isEnabled !== undefined) url_ += 'IsEnabled=' + encodeURIComponent('' + isEnabled) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnabled(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnabled(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEnabled(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exportToExcel(body: FilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoicePeriod/ExportToExcel';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExportToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExportToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class InvoiceReportServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param invoiceId (optional)
   * @return Success
   */
  downloadInvoiceReportPdf(invoiceId: number | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoiceReportService/DownloadInvoiceReportPdf?';
    if (invoiceId === null) throw new Error("The parameter 'invoiceId' cannot be null.");
    else if (invoiceId !== undefined) url_ += 'invoiceId=' + encodeURIComponent('' + invoiceId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadInvoiceReportPdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadInvoiceReportPdf(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadInvoiceReportPdf(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class InvoicesProformaServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param tenantId (optional)
   * @param minAmount (optional)
   * @param maxAmount (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    tenantId: number | null | undefined,
    minAmount: number | null | undefined,
    maxAmount: number | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfInvoicesProformaListDto> {
    let url_ = this.baseUrl + '/api/services/app/InvoicesProforma/GetAll?';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (minAmount !== undefined) url_ += 'MinAmount=' + encodeURIComponent('' + minAmount) + '&';
    if (maxAmount !== undefined) url_ += 'MaxAmount=' + encodeURIComponent('' + maxAmount) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfInvoicesProformaListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfInvoicesProformaListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfInvoicesProformaListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfInvoicesProformaListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfInvoicesProformaListDto>(<any>null);
  }
}

@Injectable()
export class LanguageServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getLanguages(): Observable<GetLanguagesOutput> {
    let url_ = this.baseUrl + '/api/services/app/Language/GetLanguages';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLanguages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLanguages(<any>response_);
            } catch (e) {
              return <Observable<GetLanguagesOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetLanguagesOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetLanguagesOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetLanguagesOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Language/GetLanguageForEdit?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLanguageForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLanguageForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetLanguageForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetLanguageForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetLanguageForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetLanguageForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Language/CreateOrUpdateLanguage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrUpdateLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrUpdateLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLanguage(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Language/DeleteLanguage?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Language/SetDefaultLanguage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetDefaultLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetDefaultLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @param sorting (optional)
   * @param baseLanguageName (optional)
   * @param targetValueFilter (optional)
   * @param filterText (optional)
   * @return Success
   */
  getLanguageTexts(
    maxResultCount: number | undefined,
    skipCount: number | undefined,
    sorting: string | null | undefined,
    sourceName: string,
    baseLanguageName: string | null | undefined,
    targetLanguageName: string,
    targetValueFilter: string | null | undefined,
    filterText: string | null | undefined
  ): Observable<PagedResultDtoOfLanguageTextListDto> {
    let url_ = this.baseUrl + '/api/services/app/Language/GetLanguageTexts?';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (sourceName === undefined || sourceName === null) throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
    else url_ += 'SourceName=' + encodeURIComponent('' + sourceName) + '&';
    if (baseLanguageName !== undefined) url_ += 'BaseLanguageName=' + encodeURIComponent('' + baseLanguageName) + '&';
    if (targetLanguageName === undefined || targetLanguageName === null)
      throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
    else url_ += 'TargetLanguageName=' + encodeURIComponent('' + targetLanguageName) + '&';
    if (targetValueFilter !== undefined) url_ += 'TargetValueFilter=' + encodeURIComponent('' + targetValueFilter) + '&';
    if (filterText !== undefined) url_ += 'FilterText=' + encodeURIComponent('' + filterText) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLanguageTexts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLanguageTexts(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfLanguageTextListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfLanguageTextListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Language/UpdateLanguageText';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLanguageText(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLanguageText(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class NationalitiesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetNationalityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetNationalityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetNationalityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetNationalityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetNationalityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetNationalityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getNationalityForView(id: number | undefined): Observable<GetNationalityForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/GetNationalityForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNationalityForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNationalityForView(<any>response_);
            } catch (e) {
              return <Observable<GetNationalityForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNationalityForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetNationalityForView(response: HttpResponseBase): Observable<GetNationalityForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNationalityForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNationalityForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getNationalityForEdit(id: number | undefined): Observable<GetNationalityForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/GetNationalityForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNationalityForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNationalityForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetNationalityForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNationalityForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetNationalityForEdit(response: HttpResponseBase): Observable<GetNationalityForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNationalityForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNationalityForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditNationalityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllNationalityForDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Nationalities/GetAllNationalityForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllNationalityForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllNationalityForDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllNationalityForDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class NationalityTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedNameFilter (optional)
   * @param languageFilter (optional)
   * @param nationalityNameFilter (optional)
   * @param nationalityIdFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    nationalityNameFilter: string | null | undefined,
    nationalityIdFilter: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetNationalityTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedNameFilter !== undefined) url_ += 'TranslatedNameFilter=' + encodeURIComponent('' + translatedNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (nationalityNameFilter !== undefined) url_ += 'NationalityNameFilter=' + encodeURIComponent('' + nationalityNameFilter) + '&';
    if (nationalityIdFilter !== undefined) url_ += 'NationalityIdFilter=' + encodeURIComponent('' + nationalityIdFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetNationalityTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetNationalityTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetNationalityTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetNationalityTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetNationalityTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getNationalityTranslationForView(id: number | undefined): Observable<GetNationalityTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/GetNationalityTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNationalityTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNationalityTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetNationalityTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNationalityTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetNationalityTranslationForView(response: HttpResponseBase): Observable<GetNationalityTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNationalityTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNationalityTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getNationalityTranslationForEdit(id: number | undefined): Observable<GetNationalityTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/GetNationalityTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNationalityTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNationalityTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetNationalityTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNationalityTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetNationalityTranslationForEdit(response: HttpResponseBase): Observable<GetNationalityTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNationalityTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNationalityTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditNationalityTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllNationalityForTableDropdown(): Observable<NationalityTranslationNationalityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/NationalityTranslations/GetAllNationalityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllNationalityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllNationalityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<NationalityTranslationNationalityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<NationalityTranslationNationalityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllNationalityForTableDropdown(response: HttpResponseBase): Observable<NationalityTranslationNationalityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(NationalityTranslationNationalityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<NationalityTranslationNationalityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class NotificationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param state (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getUserNotifications(
    state: UserNotificationState | undefined,
    startDate: moment.Moment | null | undefined,
    endDate: moment.Moment | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<GetNotificationsOutput> {
    let url_ = this.baseUrl + '/api/services/app/Notification/GetUserNotifications?';
    if (state === null) throw new Error("The parameter 'state' cannot be null.");
    else if (state !== undefined) url_ += 'State=' + encodeURIComponent('' + state) + '&';
    if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserNotifications(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserNotifications(<any>response_);
            } catch (e) {
              return <Observable<GetNotificationsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNotificationsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNotificationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNotificationsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  setAllNotificationsAsRead(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Notification/SetAllNotificationsAsRead';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetAllNotificationsAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetAllNotificationsAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Notification/SetNotificationAsRead';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetNotificationAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetNotificationAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
    let url_ = this.baseUrl + '/api/services/app/Notification/GetNotificationSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNotificationSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNotificationSettings(<any>response_);
            } catch (e) {
              return <Observable<GetNotificationSettingsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetNotificationSettingsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetNotificationSettingsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetNotificationSettingsOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Notification/UpdateNotificationSettings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateNotificationSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateNotificationSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteNotification(id: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Notification/DeleteNotification?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteNotification(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteNotification(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param state (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @return Success
   */
  deleteAllUserNotifications(
    state: UserNotificationState | undefined,
    startDate: moment.Moment | null | undefined,
    endDate: moment.Moment | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Notification/DeleteAllUserNotifications?';
    if (state === null) throw new Error("The parameter 'state' cannot be null.");
    else if (state !== undefined) url_ += 'State=' + encodeURIComponent('' + state) + '&';
    if (startDate !== undefined) url_ += 'StartDate=' + encodeURIComponent(startDate ? '' + startDate.toJSON() : '') + '&';
    if (endDate !== undefined) url_ += 'EndDate=' + encodeURIComponent(endDate ? '' + endDate.toJSON() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteAllUserNotifications(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteAllUserNotifications(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class OffersServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param descriptionFilter (optional)
   * @param maxPriceFilter (optional)
   * @param minPriceFilter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param trailerTypeDisplayNameFilter (optional)
   * @param goodCategoryDisplayNameFilter (optional)
   * @param routeDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    descriptionFilter: string | null | undefined,
    maxPriceFilter: number | null | undefined,
    minPriceFilter: number | null | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    trailerTypeDisplayNameFilter: string | null | undefined,
    goodCategoryDisplayNameFilter: string | null | undefined,
    routeDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetOfferForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (descriptionFilter !== undefined) url_ += 'DescriptionFilter=' + encodeURIComponent('' + descriptionFilter) + '&';
    if (maxPriceFilter !== undefined) url_ += 'MaxPriceFilter=' + encodeURIComponent('' + maxPriceFilter) + '&';
    if (minPriceFilter !== undefined) url_ += 'MinPriceFilter=' + encodeURIComponent('' + minPriceFilter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (trailerTypeDisplayNameFilter !== undefined)
      url_ += 'TrailerTypeDisplayNameFilter=' + encodeURIComponent('' + trailerTypeDisplayNameFilter) + '&';
    if (goodCategoryDisplayNameFilter !== undefined)
      url_ += 'GoodCategoryDisplayNameFilter=' + encodeURIComponent('' + goodCategoryDisplayNameFilter) + '&';
    if (routeDisplayNameFilter !== undefined) url_ += 'RouteDisplayNameFilter=' + encodeURIComponent('' + routeDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetOfferForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetOfferForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetOfferForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetOfferForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetOfferForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getOfferForView(id: number | undefined): Observable<GetOfferForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetOfferForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOfferForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOfferForView(<any>response_);
            } catch (e) {
              return <Observable<GetOfferForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetOfferForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOfferForView(response: HttpResponseBase): Observable<GetOfferForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetOfferForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetOfferForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getOfferForEdit(id: number | undefined): Observable<GetOfferForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetOfferForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOfferForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOfferForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetOfferForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetOfferForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOfferForEdit(response: HttpResponseBase): Observable<GetOfferForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetOfferForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetOfferForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditOfferDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Offers/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Offers/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param descriptionFilter (optional)
   * @param maxPriceFilter (optional)
   * @param minPriceFilter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param trailerTypeDisplayNameFilter (optional)
   * @param goodCategoryDisplayNameFilter (optional)
   * @param routeDisplayNameFilter (optional)
   * @return Success
   */
  getOffersToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    descriptionFilter: string | null | undefined,
    maxPriceFilter: number | null | undefined,
    minPriceFilter: number | null | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    trailerTypeDisplayNameFilter: string | null | undefined,
    goodCategoryDisplayNameFilter: string | null | undefined,
    routeDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetOffersToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (descriptionFilter !== undefined) url_ += 'DescriptionFilter=' + encodeURIComponent('' + descriptionFilter) + '&';
    if (maxPriceFilter !== undefined) url_ += 'MaxPriceFilter=' + encodeURIComponent('' + maxPriceFilter) + '&';
    if (minPriceFilter !== undefined) url_ += 'MinPriceFilter=' + encodeURIComponent('' + minPriceFilter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (trailerTypeDisplayNameFilter !== undefined)
      url_ += 'TrailerTypeDisplayNameFilter=' + encodeURIComponent('' + trailerTypeDisplayNameFilter) + '&';
    if (goodCategoryDisplayNameFilter !== undefined)
      url_ += 'GoodCategoryDisplayNameFilter=' + encodeURIComponent('' + goodCategoryDisplayNameFilter) + '&';
    if (routeDisplayNameFilter !== undefined) url_ += 'RouteDisplayNameFilter=' + encodeURIComponent('' + routeDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOffersToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOffersToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOffersToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrucksTypeForTableDropdown(): Observable<TrucksTypeSelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetAllTrucksTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrucksTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrucksTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrucksTypeForTableDropdown(response: HttpResponseBase): Observable<TrucksTypeSelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrucksTypeSelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrucksTypeSelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerTypeForTableDropdown(): Observable<OfferTrailerTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetAllTrailerTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<OfferTrailerTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<OfferTrailerTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerTypeForTableDropdown(response: HttpResponseBase): Observable<OfferTrailerTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OfferTrailerTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OfferTrailerTypeLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllGoodCategoryForTableDropdown(): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetAllGoodCategoryForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllGoodCategoryForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllGoodCategoryForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllGoodCategoryForTableDropdown(response: HttpResponseBase): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllGoodsCategoriesForDropDownOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllGoodsCategoriesForDropDownOutput[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllRouteForTableDropdown(): Observable<OfferRouteLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Offers/GetAllRouteForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRouteForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRouteForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<OfferRouteLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<OfferRouteLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRouteForTableDropdown(response: HttpResponseBase): Observable<OfferRouteLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OfferRouteLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OfferRouteLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class OrganizationUnitServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetOrganizationUnits';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrganizationUnits(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrganizationUnits(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfOrganizationUnitDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfOrganizationUnitDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getOrganizationUnitUsers(
    id: number | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrganizationUnitUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrganizationUnitUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getOrganizationUnitRoles(
    id: number | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrganizationUnitRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrganizationUnitRoles(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/CreateOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<OrganizationUnitDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganizationUnitDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganizationUnitDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganizationUnitDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/UpdateOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<OrganizationUnitDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganizationUnitDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganizationUnitDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganizationUnitDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/MoveOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMoveOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMoveOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<OrganizationUnitDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<OrganizationUnitDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrganizationUnitDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OrganizationUnitDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteOrganizationUnit(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/DeleteOrganizationUnit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param userId (optional)
   * @param organizationUnitId (optional)
   * @return Success
   */
  removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?';
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
    if (organizationUnitId === null) throw new Error("The parameter 'organizationUnitId' cannot be null.");
    else if (organizationUnitId !== undefined) url_ += 'OrganizationUnitId=' + encodeURIComponent('' + organizationUnitId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveUserFromOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveUserFromOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param roleId (optional)
   * @param organizationUnitId (optional)
   * @return Success
   */
  removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?';
    if (roleId === null) throw new Error("The parameter 'roleId' cannot be null.");
    else if (roleId !== undefined) url_ += 'RoleId=' + encodeURIComponent('' + roleId) + '&';
    if (organizationUnitId === null) throw new Error("The parameter 'organizationUnitId' cannot be null.");
    else if (organizationUnitId !== undefined) url_ += 'OrganizationUnitId=' + encodeURIComponent('' + organizationUnitId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveRoleFromOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveRoleFromOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUsersToOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUsersToOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddRolesToOrganizationUnit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddRolesToOrganizationUnit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/FindUsers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFindUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFindUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
    let url_ = this.baseUrl + '/api/services/app/OrganizationUnit/FindRoles';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFindRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFindRoles(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfNameValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
  }
}

@Injectable()
export class PackingTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetPackingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PackingTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetPackingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetPackingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPackingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetPackingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetPackingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPackingTypeForView(id: number | undefined): Observable<GetPackingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PackingTypes/GetPackingTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPackingTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPackingTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetPackingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPackingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPackingTypeForView(response: HttpResponseBase): Observable<GetPackingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPackingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPackingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPackingTypeForEdit(id: number | undefined): Observable<GetPackingTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/PackingTypes/GetPackingTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPackingTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPackingTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetPackingTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPackingTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPackingTypeForEdit(response: HttpResponseBase): Observable<GetPackingTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPackingTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPackingTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPackingTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PackingTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PackingTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PayloadMaxWeightsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param maxMaxWeightFilter (optional)
   * @param minMaxWeightFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    maxMaxWeightFilter: number | null | undefined,
    minMaxWeightFilter: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetPayloadMaxWeightForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (maxMaxWeightFilter !== undefined) url_ += 'MaxMaxWeightFilter=' + encodeURIComponent('' + maxMaxWeightFilter) + '&';
    if (minMaxWeightFilter !== undefined) url_ += 'MinMaxWeightFilter=' + encodeURIComponent('' + minMaxWeightFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetPayloadMaxWeightForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetPayloadMaxWeightForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPayloadMaxWeightForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetPayloadMaxWeightForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetPayloadMaxWeightForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPayloadMaxWeightForView(id: number | undefined): Observable<GetPayloadMaxWeightForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/GetPayloadMaxWeightForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPayloadMaxWeightForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPayloadMaxWeightForView(<any>response_);
            } catch (e) {
              return <Observable<GetPayloadMaxWeightForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPayloadMaxWeightForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPayloadMaxWeightForView(response: HttpResponseBase): Observable<GetPayloadMaxWeightForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPayloadMaxWeightForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPayloadMaxWeightForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPayloadMaxWeightForEdit(id: number | undefined): Observable<GetPayloadMaxWeightForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/GetPayloadMaxWeightForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPayloadMaxWeightForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPayloadMaxWeightForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetPayloadMaxWeightForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPayloadMaxWeightForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPayloadMaxWeightForEdit(response: HttpResponseBase): Observable<GetPayloadMaxWeightForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPayloadMaxWeightForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPayloadMaxWeightForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPayloadMaxWeightDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param maxMaxWeightFilter (optional)
   * @param minMaxWeightFilter (optional)
   * @return Success
   */
  getPayloadMaxWeightsToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    maxMaxWeightFilter: number | null | undefined,
    minMaxWeightFilter: number | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/PayloadMaxWeights/GetPayloadMaxWeightsToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (maxMaxWeightFilter !== undefined) url_ += 'MaxMaxWeightFilter=' + encodeURIComponent('' + maxMaxWeightFilter) + '&';
    if (minMaxWeightFilter !== undefined) url_ += 'MinMaxWeightFilter=' + encodeURIComponent('' + minMaxWeightFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPayloadMaxWeightsToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPayloadMaxWeightsToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPayloadMaxWeightsToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class PaymentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param upgradeEditionId (optional)
   * @return Success
   */
  getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
    let url_ = this.baseUrl + '/api/services/app/Payment/GetPaymentInfo?';
    if (upgradeEditionId !== undefined) url_ += 'UpgradeEditionId=' + encodeURIComponent('' + upgradeEditionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentInfo(<any>response_);
            } catch (e) {
              return <Observable<PaymentInfoDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentInfoDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentInfoDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentInfoDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createPayment(body: CreatePaymentDto | undefined): Observable<number> {
    let url_ = this.baseUrl + '/api/services/app/Payment/CreatePayment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePayment(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePayment(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/CancelPayment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelPayment(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelPayment(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getPaymentHistory(
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
    let url_ = this.baseUrl + '/api/services/app/Payment/GetPaymentHistory?';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentHistory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentHistory(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
  }

  /**
   * @param recurringPaymentsEnabled (optional)
   * @return Success
   */
  getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
    let url_ = this.baseUrl + '/api/services/app/Payment/GetActiveGateways?';
    if (recurringPaymentsEnabled !== undefined) url_ += 'RecurringPaymentsEnabled=' + encodeURIComponent('' + recurringPaymentsEnabled) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveGateways(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveGateways(<any>response_);
            } catch (e) {
              return <Observable<PaymentGatewayModel[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<PaymentGatewayModel[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PaymentGatewayModel.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PaymentGatewayModel[]>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
    let url_ = this.baseUrl + '/api/services/app/Payment/GetPayment?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPayment(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionPaymentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionPaymentDto>(<any>null);
  }

  /**
   * @return Success
   */
  getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
    let url_ = this.baseUrl + '/api/services/app/Payment/GetLastCompletedPayment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLastCompletedPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLastCompletedPayment(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionPaymentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionPaymentDto>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  buyNowSucceed(paymentId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/BuyNowSucceed?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processBuyNowSucceed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processBuyNowSucceed(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/NewRegistrationSucceed?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNewRegistrationSucceed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNewRegistrationSucceed(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  upgradeSucceed(paymentId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/UpgradeSucceed?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpgradeSucceed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpgradeSucceed(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  extendSucceed(paymentId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/ExtendSucceed?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExtendSucceed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExtendSucceed(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  paymentFailed(paymentId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/PaymentFailed?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPaymentFailed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPaymentFailed(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param upgradeEditionId (optional)
   * @return Success
   */
  switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/SwitchBetweenFreeEditions?';
    if (upgradeEditionId === null) throw new Error("The parameter 'upgradeEditionId' cannot be null.");
    else if (upgradeEditionId !== undefined) url_ += 'upgradeEditionId=' + encodeURIComponent('' + upgradeEditionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSwitchBetweenFreeEditions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSwitchBetweenFreeEditions(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param editionId (optional)
   * @return Success
   */
  upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?';
    if (editionId === null) throw new Error("The parameter 'editionId' cannot be null.");
    else if (editionId !== undefined) url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpgradeSubscriptionCostsLessThenMinAmount(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  hasAnyPayment(): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/Payment/HasAnyPayment';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHasAnyPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHasAnyPayment(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

@Injectable()
export class PayPalPaymentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param paymentId (optional)
   * @param paypalOrderId (optional)
   * @return Success
   */
  confirmPayment(paymentId: number | undefined, paypalOrderId: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PayPalPayment/ConfirmPayment?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'paymentId=' + encodeURIComponent('' + paymentId) + '&';
    if (paypalOrderId !== undefined) url_ += 'paypalOrderId=' + encodeURIComponent('' + paypalOrderId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfirmPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfirmPayment(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getConfiguration(): Observable<PayPalConfigurationDto> {
    let url_ = this.baseUrl + '/api/services/app/PayPalPayment/GetConfiguration';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetConfiguration(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetConfiguration(<any>response_);
            } catch (e) {
              return <Observable<PayPalConfigurationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PayPalConfigurationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PayPalConfigurationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PayPalConfigurationDto>(<any>null);
  }
}

@Injectable()
export class PermissionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
    let url_ = this.baseUrl + '/api/services/app/Permission/GetAllPermissions';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
  }
}

@Injectable()
export class PickingTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetPickingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PickingTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetPickingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetPickingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPickingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetPickingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetPickingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPickingTypeForView(id: number | undefined): Observable<GetPickingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PickingTypes/GetPickingTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPickingTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPickingTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetPickingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPickingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPickingTypeForView(response: HttpResponseBase): Observable<GetPickingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPickingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPickingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPickingTypeForEdit(id: number | undefined): Observable<GetPickingTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/PickingTypes/GetPickingTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPickingTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPickingTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetPickingTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPickingTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPickingTypeForEdit(response: HttpResponseBase): Observable<GetPickingTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPickingTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPickingTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPickingTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PickingTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PickingTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PlateTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfPlateTypeDto> {
    let url_ = this.baseUrl + '/api/services/app/PlateTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfPlateTypeDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfPlateTypeDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfPlateTypeDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfPlateTypeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfPlateTypeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPlateTypeForView(id: number | undefined): Observable<GetPlateTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PlateTypes/GetPlateTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPlateTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPlateTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetPlateTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPlateTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPlateTypeForView(response: HttpResponseBase): Observable<GetPlateTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPlateTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPlateTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPlateTypeForEdit(id: number | undefined): Observable<GetPlateTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/PlateTypes/GetPlateTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPlateTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPlateTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetPlateTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPlateTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPlateTypeForEdit(response: HttpResponseBase): Observable<GetPlateTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPlateTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPlateTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPlateTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PlateTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PlateTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PortsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param adressFilter (optional)
   * @param maxLongitudeFilter (optional)
   * @param minLongitudeFilter (optional)
   * @param maxLatitudeFilter (optional)
   * @param minLatitudeFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    adressFilter: string | null | undefined,
    maxLongitudeFilter: number | null | undefined,
    minLongitudeFilter: number | null | undefined,
    maxLatitudeFilter: number | null | undefined,
    minLatitudeFilter: number | null | undefined,
    cityDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetPortForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Ports/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (adressFilter !== undefined) url_ += 'AdressFilter=' + encodeURIComponent('' + adressFilter) + '&';
    if (maxLongitudeFilter !== undefined) url_ += 'MaxLongitudeFilter=' + encodeURIComponent('' + maxLongitudeFilter) + '&';
    if (minLongitudeFilter !== undefined) url_ += 'MinLongitudeFilter=' + encodeURIComponent('' + minLongitudeFilter) + '&';
    if (maxLatitudeFilter !== undefined) url_ += 'MaxLatitudeFilter=' + encodeURIComponent('' + maxLatitudeFilter) + '&';
    if (minLatitudeFilter !== undefined) url_ += 'MinLatitudeFilter=' + encodeURIComponent('' + minLatitudeFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetPortForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetPortForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetPortForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetPortForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetPortForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPortForView(id: number | undefined): Observable<GetPortForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Ports/GetPortForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPortForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPortForView(<any>response_);
            } catch (e) {
              return <Observable<GetPortForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPortForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPortForView(response: HttpResponseBase): Observable<GetPortForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPortForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPortForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getPortForEdit(id: number | undefined): Observable<GetPortForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Ports/GetPortForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPortForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPortForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetPortForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPortForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPortForEdit(response: HttpResponseBase): Observable<GetPortForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPortForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPortForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPortDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Ports/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Ports/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param nameFilter (optional)
   * @param adressFilter (optional)
   * @param maxLongitudeFilter (optional)
   * @param minLongitudeFilter (optional)
   * @param maxLatitudeFilter (optional)
   * @param minLatitudeFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @return Success
   */
  getPortsToExcel(
    filter: string | null | undefined,
    nameFilter: string | null | undefined,
    adressFilter: string | null | undefined,
    maxLongitudeFilter: number | null | undefined,
    minLongitudeFilter: number | null | undefined,
    maxLatitudeFilter: number | null | undefined,
    minLatitudeFilter: number | null | undefined,
    cityDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Ports/GetPortsToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (nameFilter !== undefined) url_ += 'NameFilter=' + encodeURIComponent('' + nameFilter) + '&';
    if (adressFilter !== undefined) url_ += 'AdressFilter=' + encodeURIComponent('' + adressFilter) + '&';
    if (maxLongitudeFilter !== undefined) url_ += 'MaxLongitudeFilter=' + encodeURIComponent('' + maxLongitudeFilter) + '&';
    if (minLongitudeFilter !== undefined) url_ += 'MinLongitudeFilter=' + encodeURIComponent('' + minLongitudeFilter) + '&';
    if (maxLatitudeFilter !== undefined) url_ += 'MaxLatitudeFilter=' + encodeURIComponent('' + maxLatitudeFilter) + '&';
    if (minLatitudeFilter !== undefined) url_ += 'MinLatitudeFilter=' + encodeURIComponent('' + minLatitudeFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPortsToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPortsToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPortsToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCityForTableDropdown(): Observable<PortCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Ports/GetAllCityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<PortCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<PortCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<PortCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PortCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PortCityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class PriceOfferServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @param channel (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    id: number | undefined,
    channel: PriceOfferChannel | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfPriceOfferListDto> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetAll?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    if (channel === null) throw new Error("The parameter 'channel' cannot be null.");
    else if (channel !== undefined) url_ += 'Channel=' + encodeURIComponent('' + channel) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfPriceOfferListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfPriceOfferListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfPriceOfferListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfPriceOfferListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfPriceOfferListDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllListForSearch(): Observable<GetShippingRequestSearchListDto> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetAllListForSearch';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllListForSearch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllListForSearch(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestSearchListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestSearchListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllListForSearch(response: HttpResponseBase): Observable<GetShippingRequestSearchListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestSearchListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestSearchListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @param offerId (optional)
   * @return Success
   */
  getPriceOfferForCreateOrEdit(id: number | undefined, offerId: number | null | undefined): Observable<PriceOfferDto> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetPriceOfferForCreateOrEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    if (offerId !== undefined) url_ += 'OfferId=' + encodeURIComponent('' + offerId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPriceOfferForCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPriceOfferForCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<PriceOfferDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PriceOfferDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPriceOfferForCreateOrEdit(response: HttpResponseBase): Observable<PriceOfferDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceOfferDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PriceOfferDto>(<any>null);
  }

  /**
   * @param offerId (optional)
   * @return Success
   */
  getPriceOfferForView(offerId: number | undefined): Observable<PriceOfferViewDto> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetPriceOfferForView?';
    if (offerId === null) throw new Error("The parameter 'offerId' cannot be null.");
    else if (offerId !== undefined) url_ += 'OfferId=' + encodeURIComponent('' + offerId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPriceOfferForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPriceOfferForView(<any>response_);
            } catch (e) {
              return <Observable<PriceOfferViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PriceOfferViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPriceOfferForView(response: HttpResponseBase): Observable<PriceOfferViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceOfferViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PriceOfferViewDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditPriceOfferInput | undefined): Observable<number> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param carrier (optional)
   * @param shippingRequestId (optional)
   * @param channel (optional)
   * @param requestType (optional)
   * @param truckTypeId (optional)
   * @param originId (optional)
   * @param destinationId (optional)
   * @param pickupFromDate (optional)
   * @param pickupToDate (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param routeTypeId (optional)
   * @param status (optional)
   * @param isTachyonDeal (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllShippingRequest(
    filter: string | null | undefined,
    carrier: string | null | undefined,
    shippingRequestId: number | null | undefined,
    channel: PriceOfferChannel | undefined,
    requestType: ShippingRequestType | undefined,
    truckTypeId: number | null | undefined,
    originId: number | null | undefined,
    destinationId: number | null | undefined,
    pickupFromDate: moment.Moment | null | undefined,
    pickupToDate: moment.Moment | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    routeTypeId: ShippingRequestRouteType | undefined,
    status: number | null | undefined,
    isTachyonDeal: boolean | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ListResultDtoOfGetShippingRequestForPriceOfferListDto> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetAllShippingRequest?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (carrier !== undefined) url_ += 'Carrier=' + encodeURIComponent('' + carrier) + '&';
    if (shippingRequestId !== undefined) url_ += 'ShippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    if (channel === null) throw new Error("The parameter 'channel' cannot be null.");
    else if (channel !== undefined) url_ += 'Channel=' + encodeURIComponent('' + channel) + '&';
    if (requestType === null) throw new Error("The parameter 'requestType' cannot be null.");
    else if (requestType !== undefined) url_ += 'RequestType=' + encodeURIComponent('' + requestType) + '&';
    if (truckTypeId !== undefined) url_ += 'TruckTypeId=' + encodeURIComponent('' + truckTypeId) + '&';
    if (originId !== undefined) url_ += 'OriginId=' + encodeURIComponent('' + originId) + '&';
    if (destinationId !== undefined) url_ += 'DestinationId=' + encodeURIComponent('' + destinationId) + '&';
    if (pickupFromDate !== undefined) url_ += 'PickupFromDate=' + encodeURIComponent(pickupFromDate ? '' + pickupFromDate.toJSON() : '') + '&';
    if (pickupToDate !== undefined) url_ += 'PickupToDate=' + encodeURIComponent(pickupToDate ? '' + pickupToDate.toJSON() : '') + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (routeTypeId === null) throw new Error("The parameter 'routeTypeId' cannot be null.");
    else if (routeTypeId !== undefined) url_ += 'RouteTypeId=' + encodeURIComponent('' + routeTypeId) + '&';
    if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (isTachyonDeal === null) throw new Error("The parameter 'isTachyonDeal' cannot be null.");
    else if (isTachyonDeal !== undefined) url_ += 'IsTachyonDeal=' + encodeURIComponent('' + isTachyonDeal) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingRequest(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfGetShippingRequestForPriceOfferListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfGetShippingRequestForPriceOfferListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingRequest(response: HttpResponseBase): Observable<ListResultDtoOfGetShippingRequestForPriceOfferListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfGetShippingRequestForPriceOfferListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfGetShippingRequestForPriceOfferListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  accept(id: number | undefined): Observable<PriceOfferStatus> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/Accept?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(<any>response_);
            } catch (e) {
              return <Observable<PriceOfferStatus>>(<any>_observableThrow(e));
            }
          } else return <Observable<PriceOfferStatus>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<PriceOfferStatus> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PriceOfferStatus>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  reject(body: RejectPriceOfferInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/Reject';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  cancel(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/Cancel?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancel(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancel(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param channel (optional)
   * @param id (optional)
   * @return Success
   */
  getShippingRequestForPricing(channel: PriceOfferChannel | undefined, id: number | undefined): Observable<GetShippingRequestForPricingOutput> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/GetShippingRequestForPricing?';
    if (channel === null) throw new Error("The parameter 'channel' cannot be null.");
    else if (channel !== undefined) url_ += 'Channel=' + encodeURIComponent('' + channel) + '&';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestForPricing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestForPricing(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestForPricingOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestForPricingOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestForPricing(response: HttpResponseBase): Observable<GetShippingRequestForPricingOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestForPricingOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestForPricingOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  cancelShipment(body: CancelShippingRequestInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/PriceOffer/CancelShipment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelShipment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelShipment(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelShipment(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ProfileServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetCurrentUserProfileForEdit';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentUserProfileForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentUserProfileForEdit(<any>response_);
            } catch (e) {
              return <Observable<CurrentUserProfileEditDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CurrentUserProfileEditDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CurrentUserProfileEditDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CurrentUserProfileEditDto>(<any>null);
  }

  /**
   * @return Success
   */
  disableGoogleAuthenticator(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/DisableGoogleAuthenticator';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDisableGoogleAuthenticator(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDisableGoogleAuthenticator(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/UpdateGoogleAuthenticatorKey';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateGoogleAuthenticatorKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateGoogleAuthenticatorKey(<any>response_);
            } catch (e) {
              return <Observable<UpdateGoogleAuthenticatorKeyOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<UpdateGoogleAuthenticatorKeyOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/SendVerificationSms';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendVerificationSms(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendVerificationSms(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/VerifySmsCode';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processVerifySmsCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processVerifySmsCode(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  prepareCollectedData(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/PrepareCollectedData';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPrepareCollectedData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPrepareCollectedData(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/UpdateCurrentUserProfile';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCurrentUserProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCurrentUserProfile(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/ChangePassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/UpdateProfilePicture';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateProfilePicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateProfilePicture(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetPasswordComplexitySetting';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPasswordComplexitySetting(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPasswordComplexitySetting(<any>response_);
            } catch (e) {
              return <Observable<GetPasswordComplexitySettingOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetPasswordComplexitySettingOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getProfilePicture(): Observable<GetProfilePictureOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetProfilePicture';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProfilePicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProfilePicture(<any>response_);
            } catch (e) {
              return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetProfilePictureOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetProfilePictureOutput>(<any>null);
  }

  /**
   * @param username (optional)
   * @return Success
   */
  getProfilePictureByUserName(username: string | null | undefined): Observable<GetProfilePictureOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetProfilePictureByUserName?';
    if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProfilePictureByUserName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProfilePictureByUserName(<any>response_);
            } catch (e) {
              return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetProfilePictureOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetProfilePictureOutput>(<any>null);
  }

  /**
   * @param userId (optional)
   * @param tenantId (optional)
   * @return Success
   */
  getFriendProfilePicture(userId: number | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetFriendProfilePicture?';
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += 'UserId=' + encodeURIComponent('' + userId) + '&';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFriendProfilePicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFriendProfilePicture(<any>response_);
            } catch (e) {
              return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetProfilePictureOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetProfilePictureOutput>(<any>null);
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
    let url_ = this.baseUrl + '/api/services/app/Profile/GetProfilePictureByUser?';
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProfilePictureByUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProfilePictureByUser(<any>response_);
            } catch (e) {
              return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetProfilePictureOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetProfilePictureOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetProfilePictureOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Profile/ChangeLanguage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ReceiversServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param fullNameFilter (optional)
   * @param emailFilter (optional)
   * @param phoneNumberFilter (optional)
   * @param facilityNameFilter (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    fullNameFilter: string | null | undefined,
    emailFilter: string | null | undefined,
    phoneNumberFilter: string | null | undefined,
    facilityNameFilter: string | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetReceiverForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (fullNameFilter !== undefined) url_ += 'FullNameFilter=' + encodeURIComponent('' + fullNameFilter) + '&';
    if (emailFilter !== undefined) url_ += 'EmailFilter=' + encodeURIComponent('' + emailFilter) + '&';
    if (phoneNumberFilter !== undefined) url_ += 'PhoneNumberFilter=' + encodeURIComponent('' + phoneNumberFilter) + '&';
    if (facilityNameFilter !== undefined) url_ += 'FacilityNameFilter=' + encodeURIComponent('' + facilityNameFilter) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetReceiverForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetReceiverForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetReceiverForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetReceiverForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetReceiverForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getReceiverForView(id: number | undefined): Observable<GetReceiverForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/GetReceiverForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReceiverForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReceiverForView(<any>response_);
            } catch (e) {
              return <Observable<GetReceiverForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetReceiverForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReceiverForView(response: HttpResponseBase): Observable<GetReceiverForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetReceiverForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetReceiverForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getReceiverForEdit(id: number | undefined): Observable<GetReceiverForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/GetReceiverForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReceiverForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReceiverForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetReceiverForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetReceiverForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReceiverForEdit(response: HttpResponseBase): Observable<GetReceiverForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetReceiverForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetReceiverForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditReceiverDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param phoneNumber (optional)
   * @param reciverId (optional)
   * @return Success
   */
  checkIfPhoneNumberValid(phoneNumber: string | null | undefined, reciverId: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/CheckIfPhoneNumberValid?';
    if (phoneNumber !== undefined) url_ += 'phoneNumber=' + encodeURIComponent('' + phoneNumber) + '&';
    if (reciverId !== undefined) url_ += 'reciverId=' + encodeURIComponent('' + reciverId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfPhoneNumberValid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfPhoneNumberValid(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfPhoneNumberValid(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param fullNameFilter (optional)
   * @param emailFilter (optional)
   * @param phoneNumberFilter (optional)
   * @param facilityNameFilter (optional)
   * @return Success
   */
  getReceiversToExcel(
    filter: string | null | undefined,
    fullNameFilter: string | null | undefined,
    emailFilter: string | null | undefined,
    phoneNumberFilter: string | null | undefined,
    facilityNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/GetReceiversToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (fullNameFilter !== undefined) url_ += 'FullNameFilter=' + encodeURIComponent('' + fullNameFilter) + '&';
    if (emailFilter !== undefined) url_ += 'EmailFilter=' + encodeURIComponent('' + emailFilter) + '&';
    if (phoneNumberFilter !== undefined) url_ += 'PhoneNumberFilter=' + encodeURIComponent('' + phoneNumberFilter) + '&';
    if (facilityNameFilter !== undefined) url_ += 'FacilityNameFilter=' + encodeURIComponent('' + facilityNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReceiversToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReceiversToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReceiversToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllFacilityForTableDropdown(): Observable<ReceiverFacilityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Receivers/GetAllFacilityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllFacilityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllFacilityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ReceiverFacilityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ReceiverFacilityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllFacilityForTableDropdown(response: HttpResponseBase): Observable<ReceiverFacilityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ReceiverFacilityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ReceiverFacilityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param permissions (optional)
   * @return Success
   */
  getRoles(permissions: string[] | null | undefined): Observable<ListResultDtoOfRoleListDto> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetRoles?';
    if (permissions !== undefined)
      permissions &&
        permissions.forEach((item) => {
          url_ += 'Permissions=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfRoleListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfRoleListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Role/GetRoleForEdit?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoleForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoleForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Role/CreateOrUpdateRole';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrUpdateRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrUpdateRole(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteRole(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Role/DeleteRole?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteRole(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RoutesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param routTypeDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    routTypeDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetRouteForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Routes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (routTypeDisplayNameFilter !== undefined) url_ += 'RoutTypeDisplayNameFilter=' + encodeURIComponent('' + routTypeDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetRouteForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetRouteForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRouteForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetRouteForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetRouteForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRouteForView(id: number | undefined): Observable<GetRouteForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Routes/GetRouteForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRouteForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRouteForView(<any>response_);
            } catch (e) {
              return <Observable<GetRouteForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRouteForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRouteForView(response: HttpResponseBase): Observable<GetRouteForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRouteForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRouteForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRouteForEdit(id: number | undefined): Observable<GetRouteForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Routes/GetRouteForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRouteForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRouteForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRouteForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRouteForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRouteForEdit(response: HttpResponseBase): Observable<GetRouteForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRouteForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRouteForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditRouteDto | undefined): Observable<number> {
    let url_ = this.baseUrl + '/api/services/app/Routes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<number>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Routes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param routTypeDisplayNameFilter (optional)
   * @return Success
   */
  getRoutesToExcel(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    routTypeDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Routes/GetRoutesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (routTypeDisplayNameFilter !== undefined) url_ += 'RoutTypeDisplayNameFilter=' + encodeURIComponent('' + routTypeDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllRoutTypeForTableDropdown(): Observable<RouteRoutTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Routes/GetAllRoutTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRoutTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRoutTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<RouteRoutTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<RouteRoutTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRoutTypeForTableDropdown(response: HttpResponseBase): Observable<RouteRoutTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(RouteRoutTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RouteRoutTypeLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class RoutPointsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param pickingType (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    pickingType: PickingType | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetRoutPointForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/RoutPoints/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (pickingType === null) throw new Error("The parameter 'pickingType' cannot be null.");
    else if (pickingType !== undefined) url_ += 'PickingType=' + encodeURIComponent('' + pickingType) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetRoutPointForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetRoutPointForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRoutPointForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetRoutPointForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetRoutPointForViewOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEditRoutPoint(body: CreateOrEditRoutPointDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutPoints/CreateOrEditRoutPoint';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEditRoutPoint(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEditRoutPoint(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEditRoutPoint(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutPoints/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getDropsDetailsForMasterWaybill(shippingRequestTripId: number | undefined): Observable<GetDropsDetailsForMasterWaybillOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutPoints/GetDropsDetailsForMasterWaybill?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDropsDetailsForMasterWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDropsDetailsForMasterWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetDropsDetailsForMasterWaybillOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDropsDetailsForMasterWaybillOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDropsDetailsForMasterWaybill(response: HttpResponseBase): Observable<GetDropsDetailsForMasterWaybillOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetDropsDetailsForMasterWaybillOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDropsDetailsForMasterWaybillOutput[]>(<any>null);
  }
}

@Injectable()
export class RoutStepsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param latitudeFilter (optional)
   * @param longitudeFilter (optional)
   * @param maxOrderFilter (optional)
   * @param minOrderFilter (optional)
   * @param cityDisplayNameFilter (optional)
   * @param cityDisplayName2Filter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param trailerTypeDisplayNameFilter (optional)
   * @param shippingRequestId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    latitudeFilter: string | null | undefined,
    longitudeFilter: string | null | undefined,
    maxOrderFilter: number | null | undefined,
    minOrderFilter: number | null | undefined,
    cityDisplayNameFilter: string | null | undefined,
    cityDisplayName2Filter: string | null | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    trailerTypeDisplayNameFilter: string | null | undefined,
    shippingRequestId: number | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetRoutStepForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (latitudeFilter !== undefined) url_ += 'LatitudeFilter=' + encodeURIComponent('' + latitudeFilter) + '&';
    if (longitudeFilter !== undefined) url_ += 'LongitudeFilter=' + encodeURIComponent('' + longitudeFilter) + '&';
    if (maxOrderFilter !== undefined) url_ += 'MaxOrderFilter=' + encodeURIComponent('' + maxOrderFilter) + '&';
    if (minOrderFilter !== undefined) url_ += 'MinOrderFilter=' + encodeURIComponent('' + minOrderFilter) + '&';
    if (cityDisplayNameFilter !== undefined) url_ += 'CityDisplayNameFilter=' + encodeURIComponent('' + cityDisplayNameFilter) + '&';
    if (cityDisplayName2Filter !== undefined) url_ += 'CityDisplayName2Filter=' + encodeURIComponent('' + cityDisplayName2Filter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (trailerTypeDisplayNameFilter !== undefined)
      url_ += 'TrailerTypeDisplayNameFilter=' + encodeURIComponent('' + trailerTypeDisplayNameFilter) + '&';
    if (shippingRequestId === null) throw new Error("The parameter 'shippingRequestId' cannot be null.");
    else if (shippingRequestId !== undefined) url_ += 'ShippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetRoutStepForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetRoutStepForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRoutStepForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetRoutStepForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetRoutStepForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoutStepForView(id: number | undefined): Observable<GetRoutStepForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetRoutStepForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutStepForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutStepForView(<any>response_);
            } catch (e) {
              return <Observable<GetRoutStepForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoutStepForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutStepForView(response: HttpResponseBase): Observable<GetRoutStepForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoutStepForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoutStepForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoutStepForEdit(id: number | undefined): Observable<GetRoutStepForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetRoutStepForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutStepForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutStepForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoutStepForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoutStepForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutStepForEdit(response: HttpResponseBase): Observable<GetRoutStepForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoutStepForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoutStepForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditRoutStepDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCityForTableDropdown(): Observable<RoutStepCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllCityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<RoutStepCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoutStepCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<RoutStepCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(RoutStepCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoutStepCityLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllRouteForTableDropdown(): Observable<RoutStepRouteLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllRouteForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRouteForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRouteForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<RoutStepRouteLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoutStepRouteLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRouteForTableDropdown(response: HttpResponseBase): Observable<RoutStepRouteLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(RoutStepRouteLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RoutStepRouteLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllFacilitiesForDropdown(): Observable<FacilityForDropdownDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllFacilitiesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllFacilitiesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllFacilitiesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<FacilityForDropdownDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<FacilityForDropdownDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllFacilitiesForDropdown(response: HttpResponseBase): Observable<FacilityForDropdownDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(FacilityForDropdownDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FacilityForDropdownDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrucksTypeForTableDropdown(): Observable<TrucksTypeSelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllTrucksTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrucksTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrucksTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrucksTypeForTableDropdown(response: HttpResponseBase): Observable<TrucksTypeSelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrucksTypeSelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrucksTypeSelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerTypeForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllTrailerTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerTypeForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllGoodsDetailForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/RoutSteps/GetAllGoodsDetailForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllGoodsDetailForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllGoodsDetailForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllGoodsDetailForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class RoutTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetRoutTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetRoutTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetRoutTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRoutTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetRoutTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetRoutTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoutTypeForView(id: number | undefined): Observable<GetRoutTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/GetRoutTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetRoutTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoutTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutTypeForView(response: HttpResponseBase): Observable<GetRoutTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoutTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoutTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoutTypeForEdit(id: number | undefined): Observable<GetRoutTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/GetRoutTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoutTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRoutTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutTypeForEdit(response: HttpResponseBase): Observable<GetRoutTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoutTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRoutTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditRoutTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @return Success
   */
  getRoutTypesToExcel(filter: string | null | undefined, displayNameFilter: string | null | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/RoutTypes/GetRoutTypesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoutTypesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoutTypesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRoutTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ = this.baseUrl + '/api/services/app/Session/GetCurrentLoginInformations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(<any>response_);
            } catch (e) {
              return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetCurrentLoginInformationsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
    let url_ = this.baseUrl + '/api/services/app/Session/UpdateUserSignInToken';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserSignInToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserSignInToken(<any>response_);
            } catch (e) {
              return <Observable<UpdateUserSignInTokenOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<UpdateUserSignInTokenOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
  }
}

@Injectable()
export class ShippingRequestDirectRequestServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param shippingRequestId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    shippingRequestId: number | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfShippingRequestDirectRequestListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/GetAll?';
    if (shippingRequestId === null) throw new Error("The parameter 'shippingRequestId' cannot be null.");
    else if (shippingRequestId !== undefined) url_ += 'ShippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfShippingRequestDirectRequestListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfShippingRequestDirectRequestListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfShippingRequestDirectRequestListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfShippingRequestDirectRequestListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfShippingRequestDirectRequestListDto>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param shippingRequestId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllCarriers(
    filter: string | null | undefined,
    shippingRequestId: number | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/GetAllCarriers?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (shippingRequestId === null) throw new Error("The parameter 'shippingRequestId' cannot be null.");
    else if (shippingRequestId !== undefined) url_ += 'ShippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCarriers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCarriers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCarriers(response: HttpResponseBase): Observable<PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateShippingRequestDirectRequestInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  reject(body: RejectShippingRequestDirectRequestInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/Reject';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  decline(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestDirectRequest/Decline?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDecline(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDecline(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDecline(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestReasonAccidentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @return Success
   */
  getAll(filter: string | null | undefined, sorting: string | null | undefined): Observable<ListResultDtoOfShippingRequestReasonAccidentListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestReasonAccident/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfShippingRequestReasonAccidentListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfShippingRequestReasonAccidentListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfShippingRequestReasonAccidentListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfShippingRequestReasonAccidentListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfShippingRequestReasonAccidentListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getForEdit(id: number | undefined): Observable<CreateOrEditShippingRequestReasonAccidentDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestReasonAccident/GetForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditShippingRequestReasonAccidentDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditShippingRequestReasonAccidentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditShippingRequestReasonAccidentDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditShippingRequestReasonAccidentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditShippingRequestReasonAccidentDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestReasonAccidentDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestReasonAccident/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: FilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestReasonAccident/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestReasonAccident/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param maxVasFilter (optional)
   * @param minVasFilter (optional)
   * @param isBid (optional)
   * @param isTachyonDeal (optional)
   * @param isTachyonDealer (optional)
   * @param status (optional)
   * @param isPricedWihtoutTrips (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    maxVasFilter: number | null | undefined,
    minVasFilter: number | null | undefined,
    isBid: boolean | null | undefined,
    isTachyonDeal: boolean | null | undefined,
    isTachyonDealer: boolean | null | undefined,
    status: ShippingRequestStatus | undefined,
    isPricedWihtoutTrips: boolean | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<GetAllShippingRequestsOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (maxVasFilter !== undefined) url_ += 'MaxVasFilter=' + encodeURIComponent('' + maxVasFilter) + '&';
    if (minVasFilter !== undefined) url_ += 'MinVasFilter=' + encodeURIComponent('' + minVasFilter) + '&';
    if (isBid !== undefined) url_ += 'IsBid=' + encodeURIComponent('' + isBid) + '&';
    if (isTachyonDeal !== undefined) url_ += 'IsTachyonDeal=' + encodeURIComponent('' + isTachyonDeal) + '&';
    if (isTachyonDealer !== undefined) url_ += 'IsTachyonDealer=' + encodeURIComponent('' + isTachyonDealer) + '&';
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (isPricedWihtoutTrips !== undefined) url_ += 'IsPricedWihtoutTrips=' + encodeURIComponent('' + isPricedWihtoutTrips) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<GetAllShippingRequestsOutputDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllShippingRequestsOutputDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<GetAllShippingRequestsOutputDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetAllShippingRequestsOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllShippingRequestsOutputDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestForView(id: number | undefined): Observable<GetShippingRequestForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetShippingRequestForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestForView(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestForView(response: HttpResponseBase): Observable<GetShippingRequestForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestForEdit(id: number | undefined): Observable<GetShippingRequestForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetShippingRequestForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestForEdit(response: HttpResponseBase): Observable<GetShippingRequestForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEditStep1(body: CreateOrEditShippingRequestStep1Dto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/CreateOrEditStep1';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEditStep1(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEditStep1(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEditStep1(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editStep2(body: EditShippingRequestStep2Dto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/EditStep2';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEditStep2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEditStep2(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEditStep2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editStep3(body: EditShippingRequestStep3Dto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/EditStep3';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEditStep3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEditStep3(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEditStep3(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editStep4(body: EditShippingRequestStep4Dto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/EditStep4';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEditStep4(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEditStep4(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEditStep4(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  publishShippingRequest(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/PublishShippingRequest?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPublishShippingRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPublishShippingRequest(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPublishShippingRequest(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePrice(body: UpdatePriceInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/UpdatePrice';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePrice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePrice(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdatePrice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  acceptOrRejectShippingRequestPrice(body: AcceptShippingRequestPriceInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/AcceptOrRejectShippingRequestPrice';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAcceptOrRejectShippingRequestPrice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAcceptOrRejectShippingRequestPrice(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAcceptOrRejectShippingRequestPrice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  rejectShippingRequest(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/RejectShippingRequest?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRejectShippingRequest(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRejectShippingRequest(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRejectShippingRequest(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCarriersForDropDown(): Observable<CarriersForDropDownDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllCarriersForDropDown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCarriersForDropDown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCarriersForDropDown(<any>response_);
            } catch (e) {
              return <Observable<CarriersForDropDownDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CarriersForDropDownDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCarriersForDropDown(response: HttpResponseBase): Observable<CarriersForDropDownDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CarriersForDropDownDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CarriersForDropDownDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrucksTypeForTableDropdown(): Observable<TrucksTypeSelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllTrucksTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrucksTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrucksTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrucksTypeForTableDropdown(response: HttpResponseBase): Observable<TrucksTypeSelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrucksTypeSelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrucksTypeSelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerTypeForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllTrailerTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerTypeForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllGoodCategoriesForTableDropdown(): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllGoodCategoriesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllGoodCategoriesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllGoodCategoriesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllGoodsCategoriesForDropDownOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllGoodCategoriesForTableDropdown(response: HttpResponseBase): Observable<GetAllGoodsCategoriesForDropDownOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllGoodsCategoriesForDropDownOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllGoodsCategoriesForDropDownOutput[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPortsForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllPortsForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPortsForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPortsForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPortsForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllShippingRequestVasesForTableDropdown(): Observable<ShippingRequestVasListOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllShippingRequestVasesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingRequestVasesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingRequestVasesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestVasListOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestVasListOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingRequestVasesForTableDropdown(response: HttpResponseBase): Observable<ShippingRequestVasListOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShippingRequestVasListOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestVasListOutput[]>(<any>null);
  }

  /**
   * @param shippingRequestId (optional)
   * @return Success
   */
  getAllShippingRequestVasForPricing(shippingRequestId: number | undefined): Observable<ShippingRequestVasPriceDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllShippingRequestVasForPricing?';
    if (shippingRequestId === null) throw new Error("The parameter 'shippingRequestId' cannot be null.");
    else if (shippingRequestId !== undefined) url_ += 'shippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingRequestVasForPricing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingRequestVasForPricing(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestVasPriceDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestVasPriceDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingRequestVasForPricing(response: HttpResponseBase): Observable<ShippingRequestVasPriceDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShippingRequestVasPriceDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestVasPriceDto[]>(<any>null);
  }

  /**
   * @param shippingRequestId (optional)
   * @return Success
   */
  getAllShippingRequestPricingForView(shippingRequestId: number | undefined): Observable<ShippingRequestPricingOutputforView> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllShippingRequestPricingForView?';
    if (shippingRequestId === null) throw new Error("The parameter 'shippingRequestId' cannot be null.");
    else if (shippingRequestId !== undefined) url_ += 'shippingRequestId=' + encodeURIComponent('' + shippingRequestId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingRequestPricingForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingRequestPricingForView(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestPricingOutputforView>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestPricingOutputforView>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingRequestPricingForView(response: HttpResponseBase): Observable<ShippingRequestPricingOutputforView> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShippingRequestPricingOutputforView.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestPricingOutputforView>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTransportTypesForDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllTransportTypesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTransportTypesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTransportTypesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTransportTypesForDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @param transportTypeId (optional)
   * @return Success
   */
  getAllTruckTypesByTransportTypeIdForDropdown(transportTypeId: number | undefined): Observable<TrucksTypeSelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllTruckTypesByTransportTypeIdForDropdown?';
    if (transportTypeId === null) throw new Error("The parameter 'transportTypeId' cannot be null.");
    else if (transportTypeId !== undefined) url_ += 'transportTypeId=' + encodeURIComponent('' + transportTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckTypesByTransportTypeIdForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckTypesByTransportTypeIdForDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrucksTypeSelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckTypesByTransportTypeIdForDropdown(response: HttpResponseBase): Observable<TrucksTypeSelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrucksTypeSelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrucksTypeSelectItemDto[]>(<any>null);
  }

  /**
   * @param truckTypeId (optional)
   * @return Success
   */
  getAllTuckCapacitiesByTuckTypeIdForDropdown(truckTypeId: number | undefined): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllTuckCapacitiesByTuckTypeIdForDropdown?';
    if (truckTypeId === null) throw new Error("The parameter 'truckTypeId' cannot be null.");
    else if (truckTypeId !== undefined) url_ += 'truckTypeId=' + encodeURIComponent('' + truckTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTuckCapacitiesByTuckTypeIdForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTuckCapacitiesByTuckTypeIdForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTuckCapacitiesByTuckTypeIdForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getMasterWaybill(shippingRequestTripId: number | undefined): Observable<GetMasterWaybillOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetMasterWaybill?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMasterWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMasterWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetMasterWaybillOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetMasterWaybillOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMasterWaybill(response: HttpResponseBase): Observable<GetMasterWaybillOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetMasterWaybillOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetMasterWaybillOutput[]>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getSingleDropWaybill(shippingRequestTripId: number | undefined): Observable<GetSingleDropWaybillOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetSingleDropWaybill?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSingleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSingleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetSingleDropWaybillOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetSingleDropWaybillOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSingleDropWaybill(response: HttpResponseBase): Observable<GetSingleDropWaybillOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetSingleDropWaybillOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetSingleDropWaybillOutput[]>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getShippingRequestVasesForSingleDropWaybill(shippingRequestTripId: number | undefined): Observable<GetAllShippingRequestVasesOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetShippingRequestVasesForSingleDropWaybill?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestVasesForSingleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestVasesForSingleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetAllShippingRequestVasesOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllShippingRequestVasesOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestVasesForSingleDropWaybill(response: HttpResponseBase): Observable<GetAllShippingRequestVasesOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllShippingRequestVasesOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllShippingRequestVasesOutput[]>(<any>null);
  }

  /**
   * @param routPointId (optional)
   * @return Success
   */
  getMultipleDropWaybill(routPointId: number | undefined): Observable<GetMultipleDropWaybillOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetMultipleDropWaybill?';
    if (routPointId === null) throw new Error("The parameter 'routPointId' cannot be null.");
    else if (routPointId !== undefined) url_ += 'routPointId=' + encodeURIComponent('' + routPointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMultipleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMultipleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetMultipleDropWaybillOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetMultipleDropWaybillOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMultipleDropWaybill(response: HttpResponseBase): Observable<GetMultipleDropWaybillOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetMultipleDropWaybillOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetMultipleDropWaybillOutput[]>(<any>null);
  }

  /**
   * @param routPointId (optional)
   * @return Success
   */
  getShippingRequestVasesForMultipleDropWaybill(routPointId: number | undefined): Observable<GetAllShippingRequestVasesOutput[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetShippingRequestVasesForMultipleDropWaybill?';
    if (routPointId === null) throw new Error("The parameter 'routPointId' cannot be null.");
    else if (routPointId !== undefined) url_ += 'RoutPointId=' + encodeURIComponent('' + routPointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestVasesForMultipleDropWaybill(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestVasesForMultipleDropWaybill(<any>response_);
            } catch (e) {
              return <Observable<GetAllShippingRequestVasesOutput[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetAllShippingRequestVasesOutput[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestVasesForMultipleDropWaybill(response: HttpResponseBase): Observable<GetAllShippingRequestVasesOutput[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(GetAllShippingRequestVasesOutput.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetAllShippingRequestVasesOutput[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllUnitOfMeasuresForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllUnitOfMeasuresForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUnitOfMeasuresForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUnitOfMeasuresForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUnitOfMeasuresForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllShippingTypesForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllShippingTypesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingTypesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingTypesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingTypesForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPackingTypesForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequests/GetAllPackingTypesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPackingTypesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPackingTypesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPackingTypesForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class ShippingRequestsTachyonDealerServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  startBid(body: TachyonDealerBidDtoInupt | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTachyonDealer/StartBid';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStartBid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStartBid(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processStartBid(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestStatusesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetShippingRequestStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestStatuses/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetShippingRequestStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetShippingRequestStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetShippingRequestStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetShippingRequestStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetShippingRequestStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestStatusForView(id: number | undefined): Observable<GetShippingRequestStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestStatuses/GetShippingRequestStatusForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestStatusForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestStatusForView(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestStatusForView(response: HttpResponseBase): Observable<GetShippingRequestStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestStatusForEdit(id: number | undefined): Observable<GetShippingRequestStatusForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestStatuses/GetShippingRequestStatusForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestStatusForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestStatusForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestStatusForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestStatusForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestStatusForEdit(response: HttpResponseBase): Observable<GetShippingRequestStatusForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestStatusForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestStatusForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestStatusDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestStatuses/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestStatuses/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestsTripServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param requestId (optional)
   * @param status (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    requestId: number | undefined,
    status: ShippingRequestTripStatus | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfShippingRequestsTripListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/GetAll?';
    if (requestId === null) throw new Error("The parameter 'requestId' cannot be null.");
    else if (requestId !== undefined) url_ += 'RequestId=' + encodeURIComponent('' + requestId) + '&';
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfShippingRequestsTripListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfShippingRequestsTripListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfShippingRequestsTripListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfShippingRequestsTripListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfShippingRequestsTripListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestTripForView(id: number | undefined): Observable<ShippingRequestsTripForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/GetShippingRequestTripForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestTripForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestTripForView(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestsTripForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestsTripForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestTripForView(response: HttpResponseBase): Observable<ShippingRequestsTripForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShippingRequestsTripForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestsTripForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestTripForEdit(id: number | undefined): Observable<CreateOrEditShippingRequestTripDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/GetShippingRequestTripForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestTripForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestTripForEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditShippingRequestTripDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditShippingRequestTripDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestTripForEdit(response: HttpResponseBase): Observable<CreateOrEditShippingRequestTripDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditShippingRequestTripDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditShippingRequestTripDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestTripDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  assignDriverAndTruckToShippmentByCarrier(body: AssignDriverAndTruckToShippmentByCarrierInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/AssignDriverAndTruckToShippmentByCarrier';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignDriverAndTruckToShippmentByCarrier(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignDriverAndTruckToShippmentByCarrier(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAssignDriverAndTruckToShippmentByCarrier(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  cancelByAccident(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestsTrip/CancelByAccident?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelByAccident(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelByAccident(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelByAccident(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestTripAccidentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param isResolve (optional)
   * @param tripId (optional)
   * @param pointId (optional)
   * @param sorting (optional)
   * @return Success
   */
  getAll(
    isResolve: boolean | null | undefined,
    tripId: number | undefined,
    pointId: number | null | undefined,
    sorting: string | null | undefined
  ): Observable<ListResultDtoOfShippingRequestTripAccidentListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripAccident/GetAll?';
    if (isResolve !== undefined) url_ += 'IsResolve=' + encodeURIComponent('' + isResolve) + '&';
    if (tripId === null) throw new Error("The parameter 'tripId' cannot be null.");
    else if (tripId !== undefined) url_ += 'TripId=' + encodeURIComponent('' + tripId) + '&';
    if (pointId !== undefined) url_ += 'PointId=' + encodeURIComponent('' + pointId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfShippingRequestTripAccidentListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfShippingRequestTripAccidentListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfShippingRequestTripAccidentListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfShippingRequestTripAccidentListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfShippingRequestTripAccidentListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getForEdit(id: number | undefined): Observable<CreateOrEditShippingRequestTripAccidentDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripAccident/GetForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditShippingRequestTripAccidentDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditShippingRequestTripAccidentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditShippingRequestTripAccidentDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditShippingRequestTripAccidentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditShippingRequestTripAccidentDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestTripAccidentDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripAccident/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFile(id: number | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripAccident/GetFile?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFile(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFile(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEditResolve(body: CreateOrEditShippingRequestTripAccidentResolveDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripAccident/CreateOrEditResolve';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEditResolve(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEditResolve(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEditResolve(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ShippingRequestTripRejectReasonServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @return Success
   */
  getAllRejectReason(
    filter: string | null | undefined,
    sorting: string | null | undefined
  ): Observable<ListResultDtoOfShippingRequestTripRejectReasonListDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripRejectReason/GetAllRejectReason?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllRejectReason(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllRejectReason(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfShippingRequestTripRejectReasonListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfShippingRequestTripRejectReasonListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllRejectReason(response: HttpResponseBase): Observable<ListResultDtoOfShippingRequestTripRejectReasonListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfShippingRequestTripRejectReasonListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfShippingRequestTripRejectReasonListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getForEdit(id: number | undefined): Observable<CreateOrEditShippingRequestTripRejectReasonDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripRejectReason/GetForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForEdit(<any>response_);
            } catch (e) {
              return <Observable<CreateOrEditShippingRequestTripRejectReasonDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CreateOrEditShippingRequestTripRejectReasonDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForEdit(response: HttpResponseBase): Observable<CreateOrEditShippingRequestTripRejectReasonDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreateOrEditShippingRequestTripRejectReasonDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CreateOrEditShippingRequestTripRejectReasonDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestTripRejectReasonDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripRejectReason/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripRejectReason/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: FilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestTripRejectReason/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class ShippingRequestVasesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param vasNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    vasNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetShippingRequestVasForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (vasNameFilter !== undefined) url_ += 'VasNameFilter=' + encodeURIComponent('' + vasNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetShippingRequestVasForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetShippingRequestVasForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetShippingRequestVasForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetShippingRequestVasForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetShippingRequestVasForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestVasForView(id: number | undefined): Observable<GetShippingRequestVasForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/GetShippingRequestVasForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestVasForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestVasForView(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestVasForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestVasForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestVasForView(response: HttpResponseBase): Observable<GetShippingRequestVasForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestVasForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestVasForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingRequestVasForEdit(id: number | undefined): Observable<GetShippingRequestVasForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/GetShippingRequestVasForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingRequestVasForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingRequestVasForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetShippingRequestVasForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingRequestVasForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingRequestVasForEdit(response: HttpResponseBase): Observable<GetShippingRequestVasForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingRequestVasForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingRequestVasForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingRequestVasDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllVasForTableDropdown(): Observable<ShippingRequestVasVasLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingRequestVases/GetAllVasForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllVasForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllVasForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ShippingRequestVasVasLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShippingRequestVasVasLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllVasForTableDropdown(response: HttpResponseBase): Observable<ShippingRequestVasVasLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ShippingRequestVasVasLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShippingRequestVasVasLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class ShippingTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param descriptionFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    descriptionFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetShippingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (descriptionFilter !== undefined) url_ += 'DescriptionFilter=' + encodeURIComponent('' + descriptionFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetShippingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetShippingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetShippingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetShippingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetShippingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingTypeForView(id: number | undefined): Observable<GetShippingTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/GetShippingTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetShippingTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingTypeForView(response: HttpResponseBase): Observable<GetShippingTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getShippingTypeForEdit(id: number | undefined): Observable<GetShippingTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/GetShippingTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShippingTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShippingTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetShippingTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetShippingTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetShippingTypeForEdit(response: HttpResponseBase): Observable<GetShippingTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetShippingTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetShippingTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditShippingTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllShippingTypesForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/ShippingTypes/GetAllShippingTypesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllShippingTypesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllShippingTypesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllShippingTypesForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class StripePaymentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getConfiguration(): Observable<StripeConfigurationDto> {
    let url_ = this.baseUrl + '/api/services/app/StripePayment/GetConfiguration';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetConfiguration(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetConfiguration(<any>response_);
            } catch (e) {
              return <Observable<StripeConfigurationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<StripeConfigurationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StripeConfigurationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<StripeConfigurationDto>(<any>null);
  }

  /**
   * @param stripeSessionId (optional)
   * @return Success
   */
  getPayment(stripeSessionId: string | null | undefined): Observable<SubscriptionPaymentDto> {
    let url_ = this.baseUrl + '/api/services/app/StripePayment/GetPayment?';
    if (stripeSessionId !== undefined) url_ += 'StripeSessionId=' + encodeURIComponent('' + stripeSessionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPayment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPayment(<any>response_);
            } catch (e) {
              return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubscriptionPaymentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubscriptionPaymentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubscriptionPaymentDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/StripePayment/CreatePaymentSession';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePaymentSession(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePaymentSession(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param paymentId (optional)
   * @return Success
   */
  getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
    let url_ = this.baseUrl + '/api/services/app/StripePayment/GetPaymentResult?';
    if (paymentId === null) throw new Error("The parameter 'paymentId' cannot be null.");
    else if (paymentId !== undefined) url_ += 'PaymentId=' + encodeURIComponent('' + paymentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentResult(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentResult(<any>response_);
            } catch (e) {
              return <Observable<StripePaymentResultOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<StripePaymentResultOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StripePaymentResultOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<StripePaymentResultOutput>(<any>null);
  }
}

@Injectable()
export class SubmitInvoicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param tenantId (optional)
   * @param periodId (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param status (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    tenantId: number | null | undefined,
    periodId: number | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    status: SubmitInvoiceStatus | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfSubmitInvoiceListDto> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/GetAll?';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (periodId !== undefined) url_ += 'PeriodId=' + encodeURIComponent('' + periodId) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfSubmitInvoiceListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfSubmitInvoiceListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfSubmitInvoiceListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfSubmitInvoiceListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfSubmitInvoiceListDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<SubmitInvoiceInfoDto> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/GetById?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<SubmitInvoiceInfoDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<SubmitInvoiceInfoDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<SubmitInvoiceInfoDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubmitInvoiceInfoDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SubmitInvoiceInfoDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  claim(body: SubmitInvoiceClaimCreateInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/Claim';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClaim(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClaim(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClaim(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  accepted(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/Accepted?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccepted(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccepted(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccepted(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  rejected(body: SubmitInvoiceRejectedInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/Rejected';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRejected(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRejected(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRejected(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param groupId (optional)
   * @return Success
   */
  getFileDto(groupId: number | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/GetFileDto?';
    if (groupId === null) throw new Error("The parameter 'groupId' cannot be null.");
    else if (groupId !== undefined) url_ += 'GroupId=' + encodeURIComponent('' + groupId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFileDto(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFileDto(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFileDto(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: SubmitInvoiceFilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/SubmitInvoices/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class SubscriptionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  disableRecurringPayments(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/DisableRecurringPayments';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDisableRecurringPayments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDisableRecurringPayments(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  enableRecurringPayments(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Subscription/EnableRecurringPayments';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnableRecurringPayments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnableRecurringPayments(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param subscriptionEndDateStart (optional)
   * @param subscriptionEndDateEnd (optional)
   * @param creationDateStart (optional)
   * @param creationDateEnd (optional)
   * @param editionId (optional)
   * @param editionIdSpecified (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getTenants(
    filter: string | null | undefined,
    subscriptionEndDateStart: moment.Moment | null | undefined,
    subscriptionEndDateEnd: moment.Moment | null | undefined,
    creationDateStart: moment.Moment | null | undefined,
    creationDateEnd: moment.Moment | null | undefined,
    editionId: number | null | undefined,
    editionIdSpecified: boolean | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfTenantListDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetTenants?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (subscriptionEndDateStart !== undefined)
      url_ += 'SubscriptionEndDateStart=' + encodeURIComponent(subscriptionEndDateStart ? '' + subscriptionEndDateStart.toJSON() : '') + '&';
    if (subscriptionEndDateEnd !== undefined)
      url_ += 'SubscriptionEndDateEnd=' + encodeURIComponent(subscriptionEndDateEnd ? '' + subscriptionEndDateEnd.toJSON() : '') + '&';
    if (creationDateStart !== undefined)
      url_ += 'CreationDateStart=' + encodeURIComponent(creationDateStart ? '' + creationDateStart.toJSON() : '') + '&';
    if (creationDateEnd !== undefined) url_ += 'CreationDateEnd=' + encodeURIComponent(creationDateEnd ? '' + creationDateEnd.toJSON() : '') + '&';
    if (editionId !== undefined) url_ += 'EditionId=' + encodeURIComponent('' + editionId) + '&';
    if (editionIdSpecified === null) throw new Error("The parameter 'editionIdSpecified' cannot be null.");
    else if (editionIdSpecified !== undefined) url_ += 'EditionIdSpecified=' + encodeURIComponent('' + editionIdSpecified) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenants(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenants(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfTenantListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfTenantListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createTenant(body: CreateTenantInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/CreateTenant';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateTenant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateTenant(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateTenant(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetTenantForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenantForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenantForEdit(<any>response_);
            } catch (e) {
              return <Observable<TenantEditDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantEditDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantEditDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantEditDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateTenant(body: TenantEditDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/UpdateTenant';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateTenant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateTenant(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteTenant(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/DeleteTenant?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteTenant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteTenant(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetTenantFeaturesForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenantFeaturesForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenantFeaturesForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTenantFeaturesEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTenantFeaturesEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/UpdateTenantFeatures';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateTenantFeatures(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateTenantFeatures(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/ResetTenantSpecificFeatures';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetTenantSpecificFeatures(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetTenantSpecificFeatures(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/UnlockTenantAdmin';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnlockTenantAdmin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnlockTenantAdmin(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCountryForTableDropdown(): Observable<TenantCountryLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetAllCountryForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountryForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountryForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TenantCountryLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantCountryLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<TenantCountryLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TenantCountryLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantCountryLookupTableDto[]>(<any>null);
  }

  /**
   * @param input (optional)
   * @return Success
   */
  getAllCitiesForTableDropdown(input: number | undefined): Observable<TenantCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Tenant/GetAllCitiesForTableDropdown?';
    if (input === null) throw new Error("The parameter 'input' cannot be null.");
    else if (input !== undefined) url_ += 'input=' + encodeURIComponent('' + input) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TenantCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCitiesForTableDropdown(response: HttpResponseBase): Observable<TenantCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TenantCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantCityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TenantCarrierServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    id: number | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfTenantCarriersListDto> {
    let url_ = this.baseUrl + '/api/services/app/TenantCarrier/GetAll?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfTenantCarriersListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfTenantCarriersListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantCarriersListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfTenantCarriersListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfTenantCarriersListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantCarrierInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantCarrier/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantCarrier/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TenantDashboardServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getMemberActivity(): Observable<GetMemberActivityOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetMemberActivity';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMemberActivity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMemberActivity(<any>response_);
            } catch (e) {
              return <Observable<GetMemberActivityOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetMemberActivityOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetMemberActivityOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetMemberActivityOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetDashboardData?';
    if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
      throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
    else url_ += 'SalesSummaryDatePeriod=' + encodeURIComponent('' + salesSummaryDatePeriod) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDashboardData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDashboardData(<any>response_);
            } catch (e) {
              return <Observable<GetDashboardDataOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDashboardDataOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDashboardDataOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDashboardDataOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getTopStats(): Observable<GetTopStatsOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetTopStats';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTopStats(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTopStats(<any>response_);
            } catch (e) {
              return <Observable<GetTopStatsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTopStatsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTopStatsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTopStatsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getProfitShare(): Observable<GetProfitShareOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetProfitShare';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProfitShare(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProfitShare(<any>response_);
            } catch (e) {
              return <Observable<GetProfitShareOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetProfitShareOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetProfitShareOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetProfitShareOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getDailySales(): Observable<GetDailySalesOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetDailySales';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDailySales(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDailySales(<any>response_);
            } catch (e) {
              return <Observable<GetDailySalesOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetDailySalesOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetDailySalesOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetDailySalesOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetSalesSummary?';
    if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
      throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
    else url_ += 'SalesSummaryDatePeriod=' + encodeURIComponent('' + salesSummaryDatePeriod) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSalesSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSalesSummary(<any>response_);
            } catch (e) {
              return <Observable<GetSalesSummaryOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetSalesSummaryOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetSalesSummaryOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetSalesSummaryOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getRegionalStats(): Observable<GetRegionalStatsOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetRegionalStats';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRegionalStats(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRegionalStats(<any>response_);
            } catch (e) {
              return <Observable<GetRegionalStatsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetRegionalStatsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRegionalStatsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetRegionalStatsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getGeneralStats(): Observable<GetGeneralStatsOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantDashboard/GetGeneralStats';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGeneralStats(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGeneralStats(<any>response_);
            } catch (e) {
              return <Observable<GetGeneralStatsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetGeneralStatsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetGeneralStatsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetGeneralStatsOutput>(<any>null);
  }
}

@Injectable()
export class TenantRegistrationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/RegisterTenant';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegisterTenant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegisterTenant(<any>response_);
            } catch (e) {
              return <Observable<RegisterTenantOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<RegisterTenantOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterTenantOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RegisterTenantOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getEditionsForSelect(): Observable<EditionsSelectOutput> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetEditionsForSelect';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEditionsForSelect(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEditionsForSelect(<any>response_);
            } catch (e) {
              return <Observable<EditionsSelectOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<EditionsSelectOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionsSelectOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EditionsSelectOutput>(<any>null);
  }

  /**
   * @param editionId (optional)
   * @return Success
   */
  getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetEdition?';
    if (editionId === null) throw new Error("The parameter 'editionId' cannot be null.");
    else if (editionId !== undefined) url_ += 'editionId=' + encodeURIComponent('' + editionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEdition(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEdition(<any>response_);
            } catch (e) {
              return <Observable<EditionSelectDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<EditionSelectDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionSelectDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<EditionSelectDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCountryForTableDropdown(): Observable<TenantCountryLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetAllCountryForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountryForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountryForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TenantCountryLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantCountryLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<TenantCountryLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TenantCountryLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantCountryLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCountriesWithCode(): Observable<CountyDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetAllCountriesWithCode';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountriesWithCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountriesWithCode(<any>response_);
            } catch (e) {
              return <Observable<CountyDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CountyDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCountriesWithCode(response: HttpResponseBase): Observable<CountyDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CountyDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<CountyDto[]>(<any>null);
  }

  /**
   * @param input (optional)
   * @return Success
   */
  getAllCitiesForTableDropdown(input: number | undefined): Observable<TenantCityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetAllCitiesForTableDropdown?';
    if (input === null) throw new Error("The parameter 'input' cannot be null.");
    else if (input !== undefined) url_ += 'input=' + encodeURIComponent('' + input) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TenantCityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantCityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCitiesForTableDropdown(response: HttpResponseBase): Observable<TenantCityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TenantCityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantCityLookupTableDto[]>(<any>null);
  }

  /**
   * @param companyName (optional)
   * @return Success
   */
  checkIfCompanyUniqueNameisAvailable(companyName: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/CheckIfCompanyUniqueNameisAvailable?';
    if (companyName !== undefined) url_ += 'CompanyName=' + encodeURIComponent('' + companyName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfCompanyUniqueNameisAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfCompanyUniqueNameisAvailable(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfCompanyUniqueNameisAvailable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param email (optional)
   * @return Success
   */
  checkIfEmailisAvailable(email: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/CheckIfEmailisAvailable?';
    if (email !== undefined) url_ += 'email=' + encodeURIComponent('' + email) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfEmailisAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfEmailisAvailable(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfEmailisAvailable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param editiontId (optional)
   * @return Success
   */
  getActiveTermAndConditionForViewAndApprove(editiontId: string | null | undefined): Observable<GetTermAndConditionForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TenantRegistration/GetActiveTermAndConditionForViewAndApprove?';
    if (editiontId !== undefined) url_ += 'editiontId=' + encodeURIComponent('' + editiontId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveTermAndConditionForViewAndApprove(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveTermAndConditionForViewAndApprove(<any>response_);
            } catch (e) {
              return <Observable<GetTermAndConditionForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTermAndConditionForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetActiveTermAndConditionForViewAndApprove(response: HttpResponseBase): Observable<GetTermAndConditionForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTermAndConditionForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTermAndConditionForViewDto>(<any>null);
  }
}

@Injectable()
export class TenantSettingsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAllSettings(): Observable<TenantSettingsEditDto> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/GetAllSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSettings(<any>response_);
            } catch (e) {
              return <Observable<TenantSettingsEditDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<TenantSettingsEditDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantSettingsEditDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TenantSettingsEditDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/UpdateAllSettings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateAllSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateAllSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  clearLogo(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/ClearLogo';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearLogo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearLogo(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClearLogo(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  clearCustomCss(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/ClearCustomCss';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearCustomCss(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearCustomCss(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/SendTestEmail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendTestEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendTestEmail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
    let url_ = this.baseUrl + '/api/services/app/TenantSettings/GetEnabledSocialLoginSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetEnabledSocialLoginSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetEnabledSocialLoginSettings(<any>response_);
            } catch (e) {
              return <Observable<ExternalLoginSettingsDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalLoginSettingsDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalLoginSettingsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalLoginSettingsDto>(<any>null);
  }
}

@Injectable()
export class TermAndConditionsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param titleFilter (optional)
   * @param contentFilter (optional)
   * @param maxVersionFilter (optional)
   * @param minVersionFilter (optional)
   * @param maxEditionIdFilter (optional)
   * @param minEditionIdFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    titleFilter: string | null | undefined,
    contentFilter: string | null | undefined,
    maxVersionFilter: number | null | undefined,
    minVersionFilter: number | null | undefined,
    maxEditionIdFilter: number | null | undefined,
    minEditionIdFilter: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTermAndConditionForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (titleFilter !== undefined) url_ += 'TitleFilter=' + encodeURIComponent('' + titleFilter) + '&';
    if (contentFilter !== undefined) url_ += 'ContentFilter=' + encodeURIComponent('' + contentFilter) + '&';
    if (maxVersionFilter !== undefined) url_ += 'MaxVersionFilter=' + encodeURIComponent('' + maxVersionFilter) + '&';
    if (minVersionFilter !== undefined) url_ += 'MinVersionFilter=' + encodeURIComponent('' + minVersionFilter) + '&';
    if (maxEditionIdFilter !== undefined) url_ += 'MaxEditionIdFilter=' + encodeURIComponent('' + maxEditionIdFilter) + '&';
    if (minEditionIdFilter !== undefined) url_ += 'MinEditionIdFilter=' + encodeURIComponent('' + minEditionIdFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTermAndConditionForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTermAndConditionForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTermAndConditionForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTermAndConditionForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTermAndConditionForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTermAndConditionForView(id: number | undefined): Observable<GetTermAndConditionForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/GetTermAndConditionForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTermAndConditionForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTermAndConditionForView(<any>response_);
            } catch (e) {
              return <Observable<GetTermAndConditionForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTermAndConditionForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTermAndConditionForView(response: HttpResponseBase): Observable<GetTermAndConditionForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTermAndConditionForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTermAndConditionForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTermAndConditionForEdit(id: number | undefined): Observable<GetTermAndConditionForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/GetTermAndConditionForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTermAndConditionForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTermAndConditionForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTermAndConditionForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTermAndConditionForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTermAndConditionForEdit(response: HttpResponseBase): Observable<GetTermAndConditionForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTermAndConditionForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTermAndConditionForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTermAndConditionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getDocumentEntitiesForTableDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/GetDocumentEntitiesForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentEntitiesForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentEntitiesForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentEntitiesForTableDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  setAsActive(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditions/SetAsActive?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetAsActive(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetAsActive(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSetAsActive(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TermAndConditionTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param languageFilter (optional)
   * @param termAndConditionTitleFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    languageFilter: string | null | undefined,
    termAndConditionTitleFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTermAndConditionTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (termAndConditionTitleFilter !== undefined)
      url_ += 'TermAndConditionTitleFilter=' + encodeURIComponent('' + termAndConditionTitleFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTermAndConditionTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTermAndConditionTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTermAndConditionTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTermAndConditionTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTermAndConditionTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTermAndConditionTranslationForView(id: number | undefined): Observable<GetTermAndConditionTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/GetTermAndConditionTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTermAndConditionTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTermAndConditionTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetTermAndConditionTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTermAndConditionTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTermAndConditionTranslationForView(response: HttpResponseBase): Observable<GetTermAndConditionTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTermAndConditionTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTermAndConditionTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTermAndConditionTranslationForEdit(id: number | undefined): Observable<GetTermAndConditionTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/GetTermAndConditionTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTermAndConditionTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTermAndConditionTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTermAndConditionTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTermAndConditionTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTermAndConditionTranslationForEdit(response: HttpResponseBase): Observable<GetTermAndConditionTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTermAndConditionTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTermAndConditionTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTermAndConditionTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTermAndConditionForTableDropdown(): Observable<TermAndConditionTranslationTermAndConditionLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TermAndConditionTranslations/GetAllTermAndConditionForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTermAndConditionForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTermAndConditionForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TermAndConditionTranslationTermAndConditionLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TermAndConditionTranslationTermAndConditionLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTermAndConditionForTableDropdown(
    response: HttpResponseBase
  ): Observable<TermAndConditionTranslationTermAndConditionLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TermAndConditionTranslationTermAndConditionLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TermAndConditionTranslationTermAndConditionLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TimingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
    let url_ = this.baseUrl + '/api/services/app/Timing/GetTimezones?';
    if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
      throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
    else url_ += 'DefaultTimezoneScope=' + encodeURIComponent('' + defaultTimezoneScope) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTimezones(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTimezones(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfNameValueDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfNameValueDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
  }

  /**
   * @param selectedTimezoneId (optional)
   * @return Success
   */
  getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Timing/GetTimezoneComboboxItems?';
    if (selectedTimezoneId !== undefined) url_ += 'SelectedTimezoneId=' + encodeURIComponent('' + selectedTimezoneId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTimezoneComboboxItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTimezoneComboboxItems(<any>response_);
            } catch (e) {
              return <Observable<ComboboxItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ComboboxItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ComboboxItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ComboboxItemDto[]>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/Authenticate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<AuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @param username (optional)
   * @param language (optional)
   * @return Success
   */
  mobileAuthenticate(username: string | null | undefined, language: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/TokenAuth/MobileAuthenticate?';
    if (username !== undefined) url_ += 'Username=' + encodeURIComponent('' + username) + '&';
    if (language !== undefined) url_ += 'Language=' + encodeURIComponent('' + language) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMobileAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMobileAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMobileAuthenticate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  oTPAuthenticate(body: AuthenticateMobileModel | undefined): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/OTPAuthenticate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOTPAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOTPAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<AuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<AuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOTPAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @param refreshToken (optional)
   * @return Success
   */
  refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
    let url_ = this.baseUrl + '/api/TokenAuth/RefreshToken?';
    if (refreshToken !== undefined) url_ += 'refreshToken=' + encodeURIComponent('' + refreshToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(<any>response_);
            } catch (e) {
              return <Observable<RefreshTokenResult>>(<any>_observableThrow(e));
            }
          } else return <Observable<RefreshTokenResult>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefreshTokenResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<RefreshTokenResult>(<any>null);
  }

  /**
   * @return Success
   */
  logOut(): Observable<void> {
    let url_ = this.baseUrl + '/api/TokenAuth/LogOut';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogOut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogOut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLogOut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/TokenAuth/SendTwoFactorAuthCode';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendTwoFactorAuthCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendTwoFactorAuthCode(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param impersonationToken (optional)
   * @return Success
   */
  impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/ImpersonatedAuthenticate?';
    if (impersonationToken !== undefined) url_ += 'impersonationToken=' + encodeURIComponent('' + impersonationToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processImpersonatedAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processImpersonatedAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
  }

  /**
   * @param userDelegationId (optional)
   * @param impersonationToken (optional)
   * @return Success
   */
  delegatedImpersonatedAuthenticate(
    userDelegationId: number | undefined,
    impersonationToken: string | null | undefined
  ): Observable<ImpersonatedAuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/DelegatedImpersonatedAuthenticate?';
    if (userDelegationId === null) throw new Error("The parameter 'userDelegationId' cannot be null.");
    else if (userDelegationId !== undefined) url_ += 'userDelegationId=' + encodeURIComponent('' + userDelegationId) + '&';
    if (impersonationToken !== undefined) url_ += 'impersonationToken=' + encodeURIComponent('' + impersonationToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelegatedImpersonatedAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelegatedImpersonatedAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<ImpersonatedAuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
  }

  /**
   * @param switchAccountToken (optional)
   * @return Success
   */
  linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/LinkedAccountAuthenticate?';
    if (switchAccountToken !== undefined) url_ += 'switchAccountToken=' + encodeURIComponent('' + switchAccountToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLinkedAccountAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLinkedAccountAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<SwitchedAccountAuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<SwitchedAccountAuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
    let url_ = this.baseUrl + '/api/TokenAuth/GetExternalAuthenticationProviders';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(<any>response_);
            } catch (e) {
              return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalLoginProviderInfoModel[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + '/api/TokenAuth/ExternalAuthenticate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(e));
            }
          } else return <Observable<ExternalAuthenticateResultModel>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }

  /**
   * @param message (optional)
   * @param severity (optional)
   * @return Success
   */
  testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/TokenAuth/TestNotification?';
    if (message !== undefined) url_ += 'message=' + encodeURIComponent('' + message) + '&';
    if (severity !== undefined) url_ += 'severity=' + encodeURIComponent('' + severity) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTestNotification(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTestNotification(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processTestNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TrackingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param status (optional)
   * @param shipper (optional)
   * @param carrier (optional)
   * @param truckTypeId (optional)
   * @param originId (optional)
   * @param destinationId (optional)
   * @param pickupFromDate (optional)
   * @param pickupToDate (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param routeTypeId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    status: ShippingRequestTripStatus | undefined,
    shipper: string | null | undefined,
    carrier: string | null | undefined,
    truckTypeId: number | null | undefined,
    originId: number | null | undefined,
    destinationId: number | null | undefined,
    pickupFromDate: moment.Moment | null | undefined,
    pickupToDate: moment.Moment | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    routeTypeId: ShippingRequestRouteType | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfTrackingListDto> {
    let url_ = this.baseUrl + '/api/services/app/Tracking/GetAll?';
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += 'Status=' + encodeURIComponent('' + status) + '&';
    if (shipper !== undefined) url_ += 'Shipper=' + encodeURIComponent('' + shipper) + '&';
    if (carrier !== undefined) url_ += 'Carrier=' + encodeURIComponent('' + carrier) + '&';
    if (truckTypeId !== undefined) url_ += 'TruckTypeId=' + encodeURIComponent('' + truckTypeId) + '&';
    if (originId !== undefined) url_ += 'OriginId=' + encodeURIComponent('' + originId) + '&';
    if (destinationId !== undefined) url_ += 'DestinationId=' + encodeURIComponent('' + destinationId) + '&';
    if (pickupFromDate !== undefined) url_ += 'PickupFromDate=' + encodeURIComponent(pickupFromDate ? '' + pickupFromDate.toJSON() : '') + '&';
    if (pickupToDate !== undefined) url_ += 'PickupToDate=' + encodeURIComponent(pickupToDate ? '' + pickupToDate.toJSON() : '') + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (routeTypeId === null) throw new Error("The parameter 'routeTypeId' cannot be null.");
    else if (routeTypeId !== undefined) url_ += 'RouteTypeId=' + encodeURIComponent('' + routeTypeId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfTrackingListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfTrackingListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTrackingListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfTrackingListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfTrackingListDto>(<any>null);
  }
}

@Injectable()
export class TrailersServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param trailerCodeFilter (optional)
   * @param plateNumberFilter (optional)
   * @param modelFilter (optional)
   * @param yearFilter (optional)
   * @param maxWidthFilter (optional)
   * @param minWidthFilter (optional)
   * @param maxHeightFilter (optional)
   * @param minHeightFilter (optional)
   * @param maxLengthFilter (optional)
   * @param minLengthFilter (optional)
   * @param isLiftgateFilter (optional)
   * @param isReeferFilter (optional)
   * @param isVentedFilter (optional)
   * @param isRollDoorFilter (optional)
   * @param trailerStatusDisplayNameFilter (optional)
   * @param trailerTypeDisplayNameFilter (optional)
   * @param payloadMaxWeightDisplayNameFilter (optional)
   * @param truckPlateNumberFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    trailerCodeFilter: string | null | undefined,
    plateNumberFilter: string | null | undefined,
    modelFilter: string | null | undefined,
    yearFilter: string | null | undefined,
    maxWidthFilter: number | null | undefined,
    minWidthFilter: number | null | undefined,
    maxHeightFilter: number | null | undefined,
    minHeightFilter: number | null | undefined,
    maxLengthFilter: number | null | undefined,
    minLengthFilter: number | null | undefined,
    isLiftgateFilter: number | undefined,
    isReeferFilter: number | undefined,
    isVentedFilter: number | undefined,
    isRollDoorFilter: number | undefined,
    trailerStatusDisplayNameFilter: string | null | undefined,
    trailerTypeDisplayNameFilter: string | null | undefined,
    payloadMaxWeightDisplayNameFilter: string | null | undefined,
    truckPlateNumberFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTrailerForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (trailerCodeFilter !== undefined) url_ += 'TrailerCodeFilter=' + encodeURIComponent('' + trailerCodeFilter) + '&';
    if (plateNumberFilter !== undefined) url_ += 'PlateNumberFilter=' + encodeURIComponent('' + plateNumberFilter) + '&';
    if (modelFilter !== undefined) url_ += 'ModelFilter=' + encodeURIComponent('' + modelFilter) + '&';
    if (yearFilter !== undefined) url_ += 'YearFilter=' + encodeURIComponent('' + yearFilter) + '&';
    if (maxWidthFilter !== undefined) url_ += 'MaxWidthFilter=' + encodeURIComponent('' + maxWidthFilter) + '&';
    if (minWidthFilter !== undefined) url_ += 'MinWidthFilter=' + encodeURIComponent('' + minWidthFilter) + '&';
    if (maxHeightFilter !== undefined) url_ += 'MaxHeightFilter=' + encodeURIComponent('' + maxHeightFilter) + '&';
    if (minHeightFilter !== undefined) url_ += 'MinHeightFilter=' + encodeURIComponent('' + minHeightFilter) + '&';
    if (maxLengthFilter !== undefined) url_ += 'MaxLengthFilter=' + encodeURIComponent('' + maxLengthFilter) + '&';
    if (minLengthFilter !== undefined) url_ += 'MinLengthFilter=' + encodeURIComponent('' + minLengthFilter) + '&';
    if (isLiftgateFilter === null) throw new Error("The parameter 'isLiftgateFilter' cannot be null.");
    else if (isLiftgateFilter !== undefined) url_ += 'IsLiftgateFilter=' + encodeURIComponent('' + isLiftgateFilter) + '&';
    if (isReeferFilter === null) throw new Error("The parameter 'isReeferFilter' cannot be null.");
    else if (isReeferFilter !== undefined) url_ += 'IsReeferFilter=' + encodeURIComponent('' + isReeferFilter) + '&';
    if (isVentedFilter === null) throw new Error("The parameter 'isVentedFilter' cannot be null.");
    else if (isVentedFilter !== undefined) url_ += 'IsVentedFilter=' + encodeURIComponent('' + isVentedFilter) + '&';
    if (isRollDoorFilter === null) throw new Error("The parameter 'isRollDoorFilter' cannot be null.");
    else if (isRollDoorFilter !== undefined) url_ += 'IsRollDoorFilter=' + encodeURIComponent('' + isRollDoorFilter) + '&';
    if (trailerStatusDisplayNameFilter !== undefined)
      url_ += 'TrailerStatusDisplayNameFilter=' + encodeURIComponent('' + trailerStatusDisplayNameFilter) + '&';
    if (trailerTypeDisplayNameFilter !== undefined)
      url_ += 'TrailerTypeDisplayNameFilter=' + encodeURIComponent('' + trailerTypeDisplayNameFilter) + '&';
    if (payloadMaxWeightDisplayNameFilter !== undefined)
      url_ += 'PayloadMaxWeightDisplayNameFilter=' + encodeURIComponent('' + payloadMaxWeightDisplayNameFilter) + '&';
    if (truckPlateNumberFilter !== undefined) url_ += 'TruckPlateNumberFilter=' + encodeURIComponent('' + truckPlateNumberFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTrailerForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTrailerForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTrailerForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTrailerForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTrailerForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerForView(id: number | undefined): Observable<GetTrailerForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetTrailerForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerForView(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerForView(response: HttpResponseBase): Observable<GetTrailerForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerForEdit(id: number | undefined): Observable<GetTrailerForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetTrailerForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerForEdit(response: HttpResponseBase): Observable<GetTrailerForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTrailerDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param trailerCodeFilter (optional)
   * @param plateNumberFilter (optional)
   * @param modelFilter (optional)
   * @param yearFilter (optional)
   * @param maxWidthFilter (optional)
   * @param minWidthFilter (optional)
   * @param maxHeightFilter (optional)
   * @param minHeightFilter (optional)
   * @param maxLengthFilter (optional)
   * @param minLengthFilter (optional)
   * @param isLiftgateFilter (optional)
   * @param isReeferFilter (optional)
   * @param isVentedFilter (optional)
   * @param isRollDoorFilter (optional)
   * @param trailerStatusDisplayNameFilter (optional)
   * @param trailerTypeDisplayNameFilter (optional)
   * @param payloadMaxWeightDisplayNameFilter (optional)
   * @param truckPlateNumberFilter (optional)
   * @return Success
   */
  getTrailersToExcel(
    filter: string | null | undefined,
    trailerCodeFilter: string | null | undefined,
    plateNumberFilter: string | null | undefined,
    modelFilter: string | null | undefined,
    yearFilter: string | null | undefined,
    maxWidthFilter: number | null | undefined,
    minWidthFilter: number | null | undefined,
    maxHeightFilter: number | null | undefined,
    minHeightFilter: number | null | undefined,
    maxLengthFilter: number | null | undefined,
    minLengthFilter: number | null | undefined,
    isLiftgateFilter: number | undefined,
    isReeferFilter: number | undefined,
    isVentedFilter: number | undefined,
    isRollDoorFilter: number | undefined,
    trailerStatusDisplayNameFilter: string | null | undefined,
    trailerTypeDisplayNameFilter: string | null | undefined,
    payloadMaxWeightDisplayNameFilter: string | null | undefined,
    truckPlateNumberFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetTrailersToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (trailerCodeFilter !== undefined) url_ += 'TrailerCodeFilter=' + encodeURIComponent('' + trailerCodeFilter) + '&';
    if (plateNumberFilter !== undefined) url_ += 'PlateNumberFilter=' + encodeURIComponent('' + plateNumberFilter) + '&';
    if (modelFilter !== undefined) url_ += 'ModelFilter=' + encodeURIComponent('' + modelFilter) + '&';
    if (yearFilter !== undefined) url_ += 'YearFilter=' + encodeURIComponent('' + yearFilter) + '&';
    if (maxWidthFilter !== undefined) url_ += 'MaxWidthFilter=' + encodeURIComponent('' + maxWidthFilter) + '&';
    if (minWidthFilter !== undefined) url_ += 'MinWidthFilter=' + encodeURIComponent('' + minWidthFilter) + '&';
    if (maxHeightFilter !== undefined) url_ += 'MaxHeightFilter=' + encodeURIComponent('' + maxHeightFilter) + '&';
    if (minHeightFilter !== undefined) url_ += 'MinHeightFilter=' + encodeURIComponent('' + minHeightFilter) + '&';
    if (maxLengthFilter !== undefined) url_ += 'MaxLengthFilter=' + encodeURIComponent('' + maxLengthFilter) + '&';
    if (minLengthFilter !== undefined) url_ += 'MinLengthFilter=' + encodeURIComponent('' + minLengthFilter) + '&';
    if (isLiftgateFilter === null) throw new Error("The parameter 'isLiftgateFilter' cannot be null.");
    else if (isLiftgateFilter !== undefined) url_ += 'IsLiftgateFilter=' + encodeURIComponent('' + isLiftgateFilter) + '&';
    if (isReeferFilter === null) throw new Error("The parameter 'isReeferFilter' cannot be null.");
    else if (isReeferFilter !== undefined) url_ += 'IsReeferFilter=' + encodeURIComponent('' + isReeferFilter) + '&';
    if (isVentedFilter === null) throw new Error("The parameter 'isVentedFilter' cannot be null.");
    else if (isVentedFilter !== undefined) url_ += 'IsVentedFilter=' + encodeURIComponent('' + isVentedFilter) + '&';
    if (isRollDoorFilter === null) throw new Error("The parameter 'isRollDoorFilter' cannot be null.");
    else if (isRollDoorFilter !== undefined) url_ += 'IsRollDoorFilter=' + encodeURIComponent('' + isRollDoorFilter) + '&';
    if (trailerStatusDisplayNameFilter !== undefined)
      url_ += 'TrailerStatusDisplayNameFilter=' + encodeURIComponent('' + trailerStatusDisplayNameFilter) + '&';
    if (trailerTypeDisplayNameFilter !== undefined)
      url_ += 'TrailerTypeDisplayNameFilter=' + encodeURIComponent('' + trailerTypeDisplayNameFilter) + '&';
    if (payloadMaxWeightDisplayNameFilter !== undefined)
      url_ += 'PayloadMaxWeightDisplayNameFilter=' + encodeURIComponent('' + payloadMaxWeightDisplayNameFilter) + '&';
    if (truckPlateNumberFilter !== undefined) url_ += 'TruckPlateNumberFilter=' + encodeURIComponent('' + truckPlateNumberFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailersToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailersToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailersToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerStatusForTableDropdown(): Observable<TrailerTrailerStatusLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetAllTrailerStatusForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerStatusForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerStatusForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrailerTrailerStatusLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrailerTrailerStatusLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerStatusForTableDropdown(response: HttpResponseBase): Observable<TrailerTrailerStatusLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrailerTrailerStatusLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrailerTrailerStatusLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrailerTypeForTableDropdown(): Observable<TrailerTrailerTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetAllTrailerTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrailerTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrailerTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrailerTrailerTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrailerTrailerTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrailerTypeForTableDropdown(response: HttpResponseBase): Observable<TrailerTrailerTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrailerTrailerTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrailerTrailerTypeLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPayloadMaxWeightForTableDropdown(): Observable<TrailerPayloadMaxWeightLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetAllPayloadMaxWeightForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPayloadMaxWeightForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPayloadMaxWeightForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrailerPayloadMaxWeightLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrailerPayloadMaxWeightLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPayloadMaxWeightForTableDropdown(response: HttpResponseBase): Observable<TrailerPayloadMaxWeightLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrailerPayloadMaxWeightLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrailerPayloadMaxWeightLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTruckForTableDropdown(): Observable<TrailerTruckLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trailers/GetAllTruckForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrailerTruckLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrailerTruckLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckForTableDropdown(response: HttpResponseBase): Observable<TrailerTruckLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrailerTruckLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrailerTruckLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TrailerStatusesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTrailerStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTrailerStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTrailerStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTrailerStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTrailerStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTrailerStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerStatusForView(id: number | undefined): Observable<GetTrailerStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/GetTrailerStatusForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerStatusForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerStatusForView(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerStatusForView(response: HttpResponseBase): Observable<GetTrailerStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerStatusForEdit(id: number | undefined): Observable<GetTrailerStatusForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/GetTrailerStatusForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerStatusForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerStatusForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerStatusForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerStatusForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerStatusForEdit(response: HttpResponseBase): Observable<GetTrailerStatusForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerStatusForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerStatusForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTrailerStatusDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @return Success
   */
  getTrailerStatusesToExcel(filter: string | null | undefined, displayNameFilter: string | null | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerStatuses/GetTrailerStatusesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerStatusesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerStatusesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class TrailerTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTrailerTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTrailerTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTrailerTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTrailerTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTrailerTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTrailerTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerTypeForView(id: number | undefined): Observable<GetTrailerTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/GetTrailerTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerTypeForView(response: HttpResponseBase): Observable<GetTrailerTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrailerTypeForEdit(id: number | undefined): Observable<GetTrailerTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/GetTrailerTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTrailerTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrailerTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerTypeForEdit(response: HttpResponseBase): Observable<GetTrailerTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrailerTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrailerTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTrailerTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @return Success
   */
  getTrailerTypesToExcel(filter: string | null | undefined, displayNameFilter: string | null | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/TrailerTypes/GetTrailerTypesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrailerTypesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrailerTypesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrailerTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class TransactionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param channelType (optional)
   * @param tenantId (optional)
   * @param fromDate (optional)
   * @param toDate (optional)
   * @param minLongitude (optional)
   * @param maxLongitude (optional)
   * @param editionId (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    channelType: ChannelType | undefined,
    tenantId: number | null | undefined,
    fromDate: moment.Moment | null | undefined,
    toDate: moment.Moment | null | undefined,
    minLongitude: number | null | undefined,
    maxLongitude: number | null | undefined,
    editionId: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfTransactionListDto> {
    let url_ = this.baseUrl + '/api/services/app/Transaction/GetAll?';
    if (channelType === null) throw new Error("The parameter 'channelType' cannot be null.");
    else if (channelType !== undefined) url_ += 'channelType=' + encodeURIComponent('' + channelType) + '&';
    if (tenantId !== undefined) url_ += 'TenantId=' + encodeURIComponent('' + tenantId) + '&';
    if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toJSON() : '') + '&';
    if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toJSON() : '') + '&';
    if (minLongitude !== undefined) url_ += 'minLongitude=' + encodeURIComponent('' + minLongitude) + '&';
    if (maxLongitude !== undefined) url_ += 'maxLongitude=' + encodeURIComponent('' + maxLongitude) + '&';
    if (editionId !== undefined) url_ += 'EditionId=' + encodeURIComponent('' + editionId) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfTransactionListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfTransactionListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTransactionListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfTransactionListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfTransactionListDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  exports(body: TransactionFilterInput | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Transaction/Exports';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExports(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExports(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExports(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class TransportTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTransportTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTransportTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTransportTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTransportTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTransportTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTransportTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTransportTypeForView(id: number | undefined): Observable<GetTransportTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypes/GetTransportTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTransportTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTransportTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetTransportTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTransportTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTransportTypeForView(response: HttpResponseBase): Observable<GetTransportTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTransportTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTransportTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTransportTypeForEdit(id: number | undefined): Observable<GetTransportTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypes/GetTransportTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTransportTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTransportTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTransportTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTransportTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTransportTypeForEdit(response: HttpResponseBase): Observable<GetTransportTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTransportTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTransportTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTransportTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TransportTypesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param transportTypeTranslatedDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    transportTypeTranslatedDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTransportTypesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (transportTypeTranslatedDisplayNameFilter !== undefined)
      url_ += 'TransportTypeTranslatedDisplayNameFilter=' + encodeURIComponent('' + transportTypeTranslatedDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTransportTypesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTransportTypesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTransportTypesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTransportTypesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTransportTypesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTransportTypesTranslationForView(id: number | undefined): Observable<GetTransportTypesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/GetTransportTypesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTransportTypesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTransportTypesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetTransportTypesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTransportTypesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTransportTypesTranslationForView(response: HttpResponseBase): Observable<GetTransportTypesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTransportTypesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTransportTypesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTransportTypesTranslationForEdit(id: number | undefined): Observable<GetTransportTypesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/GetTransportTypesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTransportTypesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTransportTypesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTransportTypesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTransportTypesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTransportTypesTranslationForEdit(response: HttpResponseBase): Observable<GetTransportTypesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTransportTypesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTransportTypesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTransportTypesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTransportTypeForTableDropdown(): Observable<TransportTypesTranslationTransportTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TransportTypesTranslations/GetAllTransportTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTransportTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTransportTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TransportTypesTranslationTransportTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TransportTypesTranslationTransportTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTransportTypeForTableDropdown(
    response: HttpResponseBase
  ): Observable<TransportTypesTranslationTransportTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TransportTypesTranslationTransportTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TransportTypesTranslationTransportTypeLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TruckCapacitiesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param capacityDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    capacityDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (capacityDisplayNameFilter !== undefined) url_ += 'CapacityDisplayNameFilter=' + encodeURIComponent('' + capacityDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckCapacitiesTranslationForView(id: number | undefined): Observable<GetTruckCapacitiesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/GetTruckCapacitiesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckCapacitiesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckCapacitiesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetTruckCapacitiesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckCapacitiesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckCapacitiesTranslationForView(response: HttpResponseBase): Observable<GetTruckCapacitiesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckCapacitiesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckCapacitiesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckCapacitiesTranslationForEdit(id: number | undefined): Observable<GetTruckCapacitiesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/GetTruckCapacitiesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckCapacitiesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckCapacitiesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTruckCapacitiesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckCapacitiesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckCapacitiesTranslationForEdit(response: HttpResponseBase): Observable<GetTruckCapacitiesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckCapacitiesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckCapacitiesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTruckCapacitiesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCapacityForTableDropdown(): Observable<TruckCapacitiesTranslationCapacityLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TruckCapacitiesTranslations/GetAllCapacityForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCapacityForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCapacityForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TruckCapacitiesTranslationCapacityLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TruckCapacitiesTranslationCapacityLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCapacityForTableDropdown(response: HttpResponseBase): Observable<TruckCapacitiesTranslationCapacityLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TruckCapacitiesTranslationCapacityLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TruckCapacitiesTranslationCapacityLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TrucksServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param plateNumberFilter (optional)
   * @param modelNameFilter (optional)
   * @param modelYearFilter (optional)
   * @param isAttachableFilter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param truckStatusDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    plateNumberFilter: string | null | undefined,
    modelNameFilter: string | null | undefined,
    modelYearFilter: string | null | undefined,
    isAttachableFilter: number | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    truckStatusDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTruckForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (plateNumberFilter !== undefined) url_ += 'PlateNumberFilter=' + encodeURIComponent('' + plateNumberFilter) + '&';
    if (modelNameFilter !== undefined) url_ += 'ModelNameFilter=' + encodeURIComponent('' + modelNameFilter) + '&';
    if (modelYearFilter !== undefined) url_ += 'ModelYearFilter=' + encodeURIComponent('' + modelYearFilter) + '&';
    if (isAttachableFilter === null) throw new Error("The parameter 'isAttachableFilter' cannot be null.");
    else if (isAttachableFilter !== undefined) url_ += 'IsAttachableFilter=' + encodeURIComponent('' + isAttachableFilter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (truckStatusDisplayNameFilter !== undefined)
      url_ += 'TruckStatusDisplayNameFilter=' + encodeURIComponent('' + truckStatusDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTruckForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTruckForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTruckForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTruckForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTruckForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckForView(id: number | undefined): Observable<GetTruckForViewOutput> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetTruckForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckForView(<any>response_);
            } catch (e) {
              return <Observable<GetTruckForViewOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckForViewOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckForView(response: HttpResponseBase): Observable<GetTruckForViewOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckForViewOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckForViewOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckForEdit(id: number | undefined): Observable<GetTruckForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetTruckForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTruckForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckForEdit(response: HttpResponseBase): Observable<GetTruckForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTruckDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param plateNumberFilter (optional)
   * @param modelNameFilter (optional)
   * @param modelYearFilter (optional)
   * @param isAttachableFilter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param truckStatusDisplayNameFilter (optional)
   * @return Success
   */
  getTrucksToExcel(
    filter: string | null | undefined,
    plateNumberFilter: string | null | undefined,
    modelNameFilter: string | null | undefined,
    modelYearFilter: string | null | undefined,
    isAttachableFilter: number | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    truckStatusDisplayNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetTrucksToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (plateNumberFilter !== undefined) url_ += 'PlateNumberFilter=' + encodeURIComponent('' + plateNumberFilter) + '&';
    if (modelNameFilter !== undefined) url_ += 'ModelNameFilter=' + encodeURIComponent('' + modelNameFilter) + '&';
    if (modelYearFilter !== undefined) url_ += 'ModelYearFilter=' + encodeURIComponent('' + modelYearFilter) + '&';
    if (isAttachableFilter === null) throw new Error("The parameter 'isAttachableFilter' cannot be null.");
    else if (isAttachableFilter !== undefined) url_ += 'IsAttachableFilter=' + encodeURIComponent('' + isAttachableFilter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (truckStatusDisplayNameFilter !== undefined)
      url_ += 'TruckStatusDisplayNameFilter=' + encodeURIComponent('' + truckStatusDisplayNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrucksToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrucksToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrucksToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrucksTypeForTableDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllTrucksTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrucksTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrucksTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrucksTypeForTableDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTruckStatusForTableDropdown(): Observable<TruckTruckStatusLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllTruckStatusForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckStatusForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckStatusForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TruckTruckStatusLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TruckTruckStatusLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckStatusForTableDropdown(response: HttpResponseBase): Observable<TruckTruckStatusLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TruckTruckStatusLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TruckTruckStatusLookupTableDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllCarrierTrucksForDropDown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllCarrierTrucksForDropDown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCarrierTrucksForDropDown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCarrierTrucksForDropDown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllCarrierTrucksForDropDown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllDriversForDropDown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllDriversForDropDown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDriversForDropDown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDriversForDropDown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllDriversForDropDown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllUserForLookupTable(
    filter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfTruckUserLookupTableDto> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllUserForLookupTable?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserForLookupTable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserForLookupTable(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfTruckUserLookupTableDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfTruckUserLookupTableDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTruckUserLookupTableDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfTruckUserLookupTableDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfTruckUserLookupTableDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addOrUpdateTruckPicture(body: UpdateTruckPictureInput | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/AddOrUpdateTruckPicture';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddOrUpdateTruckPicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddOrUpdateTruckPicture(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddOrUpdateTruckPicture(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param truckId (optional)
   * @return Success
   */
  getPictureContentForTruck(truckId: number | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetPictureContentForTruck?';
    if (truckId === null) throw new Error("The parameter 'truckId' cannot be null.");
    else if (truckId !== undefined) url_ += 'truckId=' + encodeURIComponent('' + truckId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPictureContentForTruck(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPictureContentForTruck(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPictureContentForTruck(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTransportTypesForDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllTransportTypesForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTransportTypesForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTransportTypesForDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTransportTypesForDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @param transportTypeId (optional)
   * @return Success
   */
  getAllTruckTypesByTransportTypeIdForDropdown(transportTypeId: number | undefined): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllTruckTypesByTransportTypeIdForDropdown?';
    if (transportTypeId === null) throw new Error("The parameter 'transportTypeId' cannot be null.");
    else if (transportTypeId !== undefined) url_ += 'transportTypeId=' + encodeURIComponent('' + transportTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckTypesByTransportTypeIdForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckTypesByTransportTypeIdForDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckTypesByTransportTypeIdForDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @param truckTypeId (optional)
   * @return Success
   */
  getAllTuckCapacitiesByTuckTypeIdForDropdown(truckTypeId: number | undefined): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllTuckCapacitiesByTuckTypeIdForDropdown?';
    if (truckTypeId === null) throw new Error("The parameter 'truckTypeId' cannot be null.");
    else if (truckTypeId !== undefined) url_ += 'truckTypeId=' + encodeURIComponent('' + truckTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTuckCapacitiesByTuckTypeIdForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTuckCapacitiesByTuckTypeIdForDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTuckCapacitiesByTuckTypeIdForDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPlateTypeIdForDropdown(): Observable<PlateTypeSelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/Trucks/GetAllPlateTypeIdForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPlateTypeIdForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPlateTypeIdForDropdown(<any>response_);
            } catch (e) {
              return <Observable<PlateTypeSelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<PlateTypeSelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllPlateTypeIdForDropdown(response: HttpResponseBase): Observable<PlateTypeSelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PlateTypeSelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PlateTypeSelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class TruckStatusesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTruckStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatuses/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTruckStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTruckStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTruckStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTruckStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTruckStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckStatusForView(id: number | undefined): Observable<GetTruckStatusForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatuses/GetTruckStatusForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckStatusForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckStatusForView(<any>response_);
            } catch (e) {
              return <Observable<GetTruckStatusForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckStatusForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckStatusForView(response: HttpResponseBase): Observable<GetTruckStatusForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckStatusForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckStatusForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckStatusForEdit(id: number | undefined): Observable<GetTruckStatusForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatuses/GetTruckStatusForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckStatusForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckStatusForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTruckStatusForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckStatusForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckStatusForEdit(response: HttpResponseBase): Observable<GetTruckStatusForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckStatusForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckStatusForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTruckStatusDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatuses/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatuses/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TruckStatusesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param truckStatusDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    truckStatusDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTruckStatusesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (truckStatusDisplayNameFilter !== undefined)
      url_ += 'TruckStatusDisplayNameFilter=' + encodeURIComponent('' + truckStatusDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTruckStatusesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTruckStatusesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTruckStatusesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTruckStatusesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTruckStatusesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckStatusesTranslationForView(id: number | undefined): Observable<GetTruckStatusesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/GetTruckStatusesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckStatusesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckStatusesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetTruckStatusesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckStatusesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckStatusesTranslationForView(response: HttpResponseBase): Observable<GetTruckStatusesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckStatusesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckStatusesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTruckStatusesTranslationForEdit(id: number | undefined): Observable<GetTruckStatusesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/GetTruckStatusesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTruckStatusesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTruckStatusesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTruckStatusesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTruckStatusesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTruckStatusesTranslationForEdit(response: HttpResponseBase): Observable<GetTruckStatusesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTruckStatusesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTruckStatusesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTruckStatusesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTruckStatusForTableDropdown(): Observable<TruckStatusesTranslationTruckStatusLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TruckStatusesTranslations/GetAllTruckStatusForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTruckStatusForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTruckStatusForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TruckStatusesTranslationTruckStatusLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TruckStatusesTranslationTruckStatusLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTruckStatusForTableDropdown(response: HttpResponseBase): Observable<TruckStatusesTranslationTruckStatusLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TruckStatusesTranslationTruckStatusLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TruckStatusesTranslationTruckStatusLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class TrucksTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTrucksTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTrucksTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTrucksTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTrucksTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTrucksTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTrucksTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrucksTypeForView(id: number | undefined): Observable<GetTrucksTypeForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/GetTrucksTypeForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrucksTypeForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrucksTypeForView(<any>response_);
            } catch (e) {
              return <Observable<GetTrucksTypeForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrucksTypeForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrucksTypeForView(response: HttpResponseBase): Observable<GetTrucksTypeForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrucksTypeForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrucksTypeForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrucksTypeForEdit(id: number | undefined): Observable<GetTrucksTypeForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/GetTrucksTypeForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrucksTypeForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrucksTypeForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTrucksTypeForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrucksTypeForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrucksTypeForEdit(response: HttpResponseBase): Observable<GetTrucksTypeForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrucksTypeForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrucksTypeForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTrucksTypeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTransportTypeForTableDropdown(): Observable<ISelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypes/GetAllTransportTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTransportTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTransportTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<ISelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ISelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTransportTypeForTableDropdown(response: HttpResponseBase): Observable<ISelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ISelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ISelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class TrucksTypesTranslationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param translatedDisplayNameFilter (optional)
   * @param languageFilter (optional)
   * @param trucksTypeDisplayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    translatedDisplayNameFilter: string | null | undefined,
    languageFilter: string | null | undefined,
    trucksTypeDisplayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetTrucksTypesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (translatedDisplayNameFilter !== undefined)
      url_ += 'TranslatedDisplayNameFilter=' + encodeURIComponent('' + translatedDisplayNameFilter) + '&';
    if (languageFilter !== undefined) url_ += 'LanguageFilter=' + encodeURIComponent('' + languageFilter) + '&';
    if (trucksTypeDisplayNameFilter !== undefined)
      url_ += 'TrucksTypeDisplayNameFilter=' + encodeURIComponent('' + trucksTypeDisplayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetTrucksTypesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetTrucksTypesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTrucksTypesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetTrucksTypesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetTrucksTypesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrucksTypesTranslationForView(id: number | undefined): Observable<GetTrucksTypesTranslationForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/GetTrucksTypesTranslationForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrucksTypesTranslationForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrucksTypesTranslationForView(<any>response_);
            } catch (e) {
              return <Observable<GetTrucksTypesTranslationForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrucksTypesTranslationForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrucksTypesTranslationForView(response: HttpResponseBase): Observable<GetTrucksTypesTranslationForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrucksTypesTranslationForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrucksTypesTranslationForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getTrucksTypesTranslationForEdit(id: number | undefined): Observable<GetTrucksTypesTranslationForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/GetTrucksTypesTranslationForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTrucksTypesTranslationForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTrucksTypesTranslationForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetTrucksTypesTranslationForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetTrucksTypesTranslationForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetTrucksTypesTranslationForEdit(response: HttpResponseBase): Observable<GetTrucksTypesTranslationForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetTrucksTypesTranslationForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetTrucksTypesTranslationForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditTrucksTypesTranslationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllTrucksTypeForTableDropdown(): Observable<TrucksTypesTranslationTrucksTypeLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/TrucksTypesTranslations/GetAllTrucksTypeForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllTrucksTypeForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllTrucksTypeForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<TrucksTypesTranslationTrucksTypeLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<TrucksTypesTranslationTrucksTypeLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllTrucksTypeForTableDropdown(response: HttpResponseBase): Observable<TrucksTypesTranslationTrucksTypeLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TrucksTypesTranslationTrucksTypeLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<TrucksTypesTranslationTrucksTypeLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
    let url_ = this.baseUrl + '/api/services/app/UiCustomizationSettings/GetUiManagementSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUiManagementSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUiManagementSettings(<any>response_);
            } catch (e) {
              return <Observable<ThemeSettingsDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ThemeSettingsDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ThemeSettingsDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ThemeSettingsDto[]>(<any>null);
  }

  /**
   * @param themeName (optional)
   * @return Success
   */
  changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?';
    if (themeName !== undefined) url_ += 'themeName=' + encodeURIComponent('' + themeName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeThemeWithDefaultValues(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeThemeWithDefaultValues(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUiManagementSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUiManagementSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateDefaultUiManagementSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateDefaultUiManagementSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  useSystemDefaultSettings(): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUseSystemDefaultSettings(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUseSystemDefaultSettings(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class UnitOfMeasuresServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param displayNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    displayNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetUnitOfMeasureForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (displayNameFilter !== undefined) url_ += 'DisplayNameFilter=' + encodeURIComponent('' + displayNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetUnitOfMeasureForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetUnitOfMeasureForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUnitOfMeasureForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetUnitOfMeasureForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetUnitOfMeasureForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUnitOfMeasureForView(id: number | undefined): Observable<GetUnitOfMeasureForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/GetUnitOfMeasureForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUnitOfMeasureForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUnitOfMeasureForView(<any>response_);
            } catch (e) {
              return <Observable<GetUnitOfMeasureForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetUnitOfMeasureForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUnitOfMeasureForView(response: HttpResponseBase): Observable<GetUnitOfMeasureForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetUnitOfMeasureForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetUnitOfMeasureForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUnitOfMeasureForEdit(id: number | undefined): Observable<GetUnitOfMeasureForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/GetUnitOfMeasureForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUnitOfMeasureForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUnitOfMeasureForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetUnitOfMeasureForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetUnitOfMeasureForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUnitOfMeasureForEdit(response: HttpResponseBase): Observable<GetUnitOfMeasureForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetUnitOfMeasureForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetUnitOfMeasureForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditUnitOfMeasureDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllUnitOfMeasuresForDropdown(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/UnitOfMeasures/GetAllUnitOfMeasuresForDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUnitOfMeasuresForDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUnitOfMeasuresForDropdown(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllUnitOfMeasuresForDropdown(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param permissions (optional)
   * @param role (optional)
   * @param onlyLockedUsers (optional)
   * @param onlyDrivers (optional)
   * @param onlyUsers (optional)
   * @param sorting (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getUsers(
    filter: string | null | undefined,
    permissions: string[] | null | undefined,
    role: number | null | undefined,
    onlyLockedUsers: boolean | undefined,
    onlyDrivers: boolean | undefined,
    onlyUsers: boolean | undefined,
    sorting: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfUserListDto> {
    let url_ = this.baseUrl + '/api/services/app/User/GetUsers?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (permissions !== undefined)
      permissions &&
        permissions.forEach((item) => {
          url_ += 'Permissions=' + encodeURIComponent('' + item) + '&';
        });
    if (role !== undefined) url_ += 'Role=' + encodeURIComponent('' + role) + '&';
    if (onlyLockedUsers === null) throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
    else if (onlyLockedUsers !== undefined) url_ += 'OnlyLockedUsers=' + encodeURIComponent('' + onlyLockedUsers) + '&';
    if (onlyDrivers === null) throw new Error("The parameter 'onlyDrivers' cannot be null.");
    else if (onlyDrivers !== undefined) url_ += 'OnlyDrivers=' + encodeURIComponent('' + onlyDrivers) + '&';
    if (onlyUsers === null) throw new Error("The parameter 'onlyUsers' cannot be null.");
    else if (onlyUsers !== undefined) url_ += 'OnlyUsers=' + encodeURIComponent('' + onlyUsers) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfUserListDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfUserListDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param permissions (optional)
   * @param role (optional)
   * @param onlyLockedUsers (optional)
   * @param onlyDrivers (optional)
   * @param onlyUsers (optional)
   * @param sorting (optional)
   * @return Success
   */
  getUsersToExcel(
    filter: string | null | undefined,
    permissions: string[] | null | undefined,
    role: number | null | undefined,
    onlyLockedUsers: boolean | undefined,
    onlyDrivers: boolean | undefined,
    onlyUsers: boolean | undefined,
    sorting: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/User/GetUsersToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (permissions !== undefined)
      permissions &&
        permissions.forEach((item) => {
          url_ += 'Permissions=' + encodeURIComponent('' + item) + '&';
        });
    if (role !== undefined) url_ += 'Role=' + encodeURIComponent('' + role) + '&';
    if (onlyLockedUsers === null) throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
    else if (onlyLockedUsers !== undefined) url_ += 'OnlyLockedUsers=' + encodeURIComponent('' + onlyLockedUsers) + '&';
    if (onlyDrivers === null) throw new Error("The parameter 'onlyDrivers' cannot be null.");
    else if (onlyDrivers !== undefined) url_ += 'OnlyDrivers=' + encodeURIComponent('' + onlyDrivers) + '&';
    if (onlyUsers === null) throw new Error("The parameter 'onlyUsers' cannot be null.");
    else if (onlyUsers !== undefined) url_ += 'OnlyUsers=' + encodeURIComponent('' + onlyUsers) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUsersToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUsersToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/User/GetUserForEdit?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetUserForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetUserForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetUserForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetUserForEditOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/User/GetUserPermissionsForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserPermissionsForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserPermissionsForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetUserPermissionsForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetUserPermissionsForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/ResetUserSpecificPermissions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetUserSpecificPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetUserSpecificPermissions(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/UpdateUserPermissions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserPermissions(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/CreateOrUpdateUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrUpdateUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrUpdateUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteUser(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/DeleteUser?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/User/UnlockUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnlockUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnlockUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUnlockUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param phoneNumber (optional)
   * @param driverId (optional)
   * @return Success
   */
  checkIfPhoneNumberValid(phoneNumber: string | null | undefined, driverId: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/User/CheckIfPhoneNumberValid?';
    if (phoneNumber !== undefined) url_ += 'phoneNumber=' + encodeURIComponent('' + phoneNumber) + '&';
    if (driverId !== undefined) url_ += 'driverId=' + encodeURIComponent('' + driverId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfPhoneNumberValid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfPhoneNumberValid(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfPhoneNumberValid(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @return Success
   */
  getDriverNationalites(): Observable<SelectItemDto[]> {
    let url_ = this.baseUrl + '/api/services/app/User/GetDriverNationalites';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDriverNationalites(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDriverNationalites(<any>response_);
            } catch (e) {
              return <Observable<SelectItemDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<SelectItemDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDriverNationalites(response: HttpResponseBase): Observable<SelectItemDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(SelectItemDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<SelectItemDto[]>(<any>null);
  }

  /**
   * @param userName (optional)
   * @param userId (optional)
   * @return Success
   */
  checkIfUserNameValid(userName: string | null | undefined, userId: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/User/CheckIfUserNameValid?';
    if (userName !== undefined) url_ += 'userName=' + encodeURIComponent('' + userName) + '&';
    if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfUserNameValid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfUserNameValid(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfUserNameValid(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param email (optional)
   * @return Success
   */
  checkIfEmailisAvailable(email: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/User/CheckIfEmailisAvailable?';
    if (email !== undefined) url_ += 'email=' + encodeURIComponent('' + email) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIfEmailisAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIfEmailisAvailable(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCheckIfEmailisAvailable(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }
}

@Injectable()
export class UserDelegationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @param sorting (optional)
   * @return Success
   */
  getDelegatedUsers(
    maxResultCount: number | undefined,
    skipCount: number | undefined,
    sorting: string | null | undefined
  ): Observable<PagedResultDtoOfUserDelegationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserDelegation/GetDelegatedUsers?';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDelegatedUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDelegatedUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfUserDelegationDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfUserDelegationDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfUserDelegationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UserDelegation/DelegateNewUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelegateNewUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelegateNewUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  removeDelegation(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UserDelegation/RemoveDelegation?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveDelegation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveDelegation(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getActiveUserDelegations(): Observable<UserDelegationDto[]> {
    let url_ = this.baseUrl + '/api/services/app/UserDelegation/GetActiveUserDelegations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveUserDelegations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveUserDelegations(<any>response_);
            } catch (e) {
              return <Observable<UserDelegationDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDelegationDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(UserDelegationDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<UserDelegationDto[]>(<any>null);
  }
}

@Injectable()
export class UserLinkServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  linkToUser(body: LinkToUserInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UserLink/LinkToUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLinkToUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLinkToUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLinkToUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @param sorting (optional)
   * @return Success
   */
  getLinkedUsers(
    maxResultCount: number | undefined,
    skipCount: number | undefined,
    sorting: string | null | undefined
  ): Observable<PagedResultDtoOfLinkedUserDto> {
    let url_ = this.baseUrl + '/api/services/app/UserLink/GetLinkedUsers?';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLinkedUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLinkedUsers(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfLinkedUserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfLinkedUserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
  }

  /**
   * @return Success
   */
  getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
    let url_ = this.baseUrl + '/api/services/app/UserLink/GetRecentlyUsedLinkedUsers';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRecentlyUsedLinkedUsers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRecentlyUsedLinkedUsers(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfLinkedUserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfLinkedUserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/UserLink/UnlinkUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnlinkUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnlinkUser(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class UserLoginServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
    let url_ = this.baseUrl + '/api/services/app/UserLogin/GetRecentUserLoginAttempts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRecentUserLoginAttempts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRecentUserLoginAttempts(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfUserLoginAttemptDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfUserLoginAttemptDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
  }
}

@Injectable()
export class VasesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param hasAmountFilter (optional)
   * @param hasCountFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    hasAmountFilter: number | null | undefined,
    hasCountFilter: number | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetVasForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Vases/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (hasAmountFilter !== undefined) url_ += 'HasAmountFilter=' + encodeURIComponent('' + hasAmountFilter) + '&';
    if (hasCountFilter !== undefined) url_ += 'HasCountFilter=' + encodeURIComponent('' + hasCountFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetVasForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetVasForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVasForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetVasForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetVasForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getVasForView(id: number | undefined): Observable<GetVasForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/Vases/GetVasForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasForView(<any>response_);
            } catch (e) {
              return <Observable<GetVasForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetVasForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasForView(response: HttpResponseBase): Observable<GetVasForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetVasForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetVasForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getVasForEdit(id: number | undefined): Observable<GetVasForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/Vases/GetVasForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetVasForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetVasForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasForEdit(response: HttpResponseBase): Observable<GetVasForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetVasForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetVasForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditVasDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Vases/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Vases/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param hasAmountFilter (optional)
   * @param hasCountFilter (optional)
   * @return Success
   */
  getVasesToExcel(
    filter: string | null | undefined,
    hasAmountFilter: number | null | undefined,
    hasCountFilter: number | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Vases/GetVasesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (hasAmountFilter !== undefined) url_ += 'HasAmountFilter=' + encodeURIComponent('' + hasAmountFilter) + '&';
    if (hasCountFilter !== undefined) url_ += 'HasCountFilter=' + encodeURIComponent('' + hasCountFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class VasPricesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param filter (optional)
   * @param maxPriceFilter (optional)
   * @param minPriceFilter (optional)
   * @param maxAmountFilter (optional)
   * @param minAmountFilter (optional)
   * @param maxCountFilter (optional)
   * @param minCountFilter (optional)
   * @param vasNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllVASs(
    filter: string | null | undefined,
    maxPriceFilter: number | null | undefined,
    minPriceFilter: number | null | undefined,
    maxAmountFilter: number | null | undefined,
    minAmountFilter: number | null | undefined,
    maxCountFilter: number | null | undefined,
    minCountFilter: number | null | undefined,
    vasNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetVasPriceForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetAllVASs?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (maxPriceFilter !== undefined) url_ += 'MaxPriceFilter=' + encodeURIComponent('' + maxPriceFilter) + '&';
    if (minPriceFilter !== undefined) url_ += 'MinPriceFilter=' + encodeURIComponent('' + minPriceFilter) + '&';
    if (maxAmountFilter !== undefined) url_ += 'MaxAmountFilter=' + encodeURIComponent('' + maxAmountFilter) + '&';
    if (minAmountFilter !== undefined) url_ += 'MinAmountFilter=' + encodeURIComponent('' + minAmountFilter) + '&';
    if (maxCountFilter !== undefined) url_ += 'MaxCountFilter=' + encodeURIComponent('' + maxCountFilter) + '&';
    if (minCountFilter !== undefined) url_ += 'MinCountFilter=' + encodeURIComponent('' + minCountFilter) + '&';
    if (vasNameFilter !== undefined) url_ += 'VasNameFilter=' + encodeURIComponent('' + vasNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllVASs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllVASs(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetVasPriceForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetVasPriceForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllVASs(response: HttpResponseBase): Observable<PagedResultDtoOfGetVasPriceForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetVasPriceForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetVasPriceForViewDto>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param maxPriceFilter (optional)
   * @param minPriceFilter (optional)
   * @param maxAmountFilter (optional)
   * @param minAmountFilter (optional)
   * @param maxCountFilter (optional)
   * @param minCountFilter (optional)
   * @param vasNameFilter (optional)
   * @param sorting (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    filter: string | null | undefined,
    maxPriceFilter: number | null | undefined,
    minPriceFilter: number | null | undefined,
    maxAmountFilter: number | null | undefined,
    minAmountFilter: number | null | undefined,
    maxCountFilter: number | null | undefined,
    minCountFilter: number | null | undefined,
    vasNameFilter: string | null | undefined,
    sorting: string | null | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedResultDtoOfGetVasPriceForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetAll?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (maxPriceFilter !== undefined) url_ += 'MaxPriceFilter=' + encodeURIComponent('' + maxPriceFilter) + '&';
    if (minPriceFilter !== undefined) url_ += 'MinPriceFilter=' + encodeURIComponent('' + minPriceFilter) + '&';
    if (maxAmountFilter !== undefined) url_ += 'MaxAmountFilter=' + encodeURIComponent('' + maxAmountFilter) + '&';
    if (minAmountFilter !== undefined) url_ += 'MinAmountFilter=' + encodeURIComponent('' + minAmountFilter) + '&';
    if (maxCountFilter !== undefined) url_ += 'MaxCountFilter=' + encodeURIComponent('' + maxCountFilter) + '&';
    if (minCountFilter !== undefined) url_ += 'MinCountFilter=' + encodeURIComponent('' + minCountFilter) + '&';
    if (vasNameFilter !== undefined) url_ += 'VasNameFilter=' + encodeURIComponent('' + vasNameFilter) + '&';
    if (sorting !== undefined) url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetVasPriceForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetVasPriceForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVasPriceForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetVasPriceForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetVasPriceForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getVasPriceForView(id: number | undefined): Observable<GetVasPriceForViewDto> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetVasPriceForView?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasPriceForView(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasPriceForView(<any>response_);
            } catch (e) {
              return <Observable<GetVasPriceForViewDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetVasPriceForViewDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasPriceForView(response: HttpResponseBase): Observable<GetVasPriceForViewDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetVasPriceForViewDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetVasPriceForViewDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getVasPriceForEdit(id: number | undefined): Observable<GetVasPriceForEditOutput> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetVasPriceForEdit?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasPriceForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasPriceForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetVasPriceForEditOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetVasPriceForEditOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasPriceForEdit(response: HttpResponseBase): Observable<GetVasPriceForEditOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetVasPriceForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetVasPriceForEditOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createOrEdit(body: CreateOrEditVasPriceDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/CreateOrEdit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrEdit(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/Delete?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param filter (optional)
   * @param maxPriceFilter (optional)
   * @param minPriceFilter (optional)
   * @param maxMaxAmountFilter (optional)
   * @param minMaxAmountFilter (optional)
   * @param maxMaxCountFilter (optional)
   * @param minMaxCountFilter (optional)
   * @param vasNameFilter (optional)
   * @return Success
   */
  getVasPricesToExcel(
    filter: string | null | undefined,
    maxPriceFilter: number | null | undefined,
    minPriceFilter: number | null | undefined,
    maxMaxAmountFilter: number | null | undefined,
    minMaxAmountFilter: number | null | undefined,
    maxMaxCountFilter: number | null | undefined,
    minMaxCountFilter: number | null | undefined,
    vasNameFilter: string | null | undefined
  ): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetVasPricesToExcel?';
    if (filter !== undefined) url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (maxPriceFilter !== undefined) url_ += 'MaxPriceFilter=' + encodeURIComponent('' + maxPriceFilter) + '&';
    if (minPriceFilter !== undefined) url_ += 'MinPriceFilter=' + encodeURIComponent('' + minPriceFilter) + '&';
    if (maxMaxAmountFilter !== undefined) url_ += 'MaxMaxAmountFilter=' + encodeURIComponent('' + maxMaxAmountFilter) + '&';
    if (minMaxAmountFilter !== undefined) url_ += 'MinMaxAmountFilter=' + encodeURIComponent('' + minMaxAmountFilter) + '&';
    if (maxMaxCountFilter !== undefined) url_ += 'MaxMaxCountFilter=' + encodeURIComponent('' + maxMaxCountFilter) + '&';
    if (minMaxCountFilter !== undefined) url_ += 'MinMaxCountFilter=' + encodeURIComponent('' + minMaxCountFilter) + '&';
    if (vasNameFilter !== undefined) url_ += 'VasNameFilter=' + encodeURIComponent('' + vasNameFilter) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetVasPricesToExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetVasPricesToExcel(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetVasPricesToExcel(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @return Success
   */
  getAllVasForTableDropdown(): Observable<VasPriceVasLookupTableDto[]> {
    let url_ = this.baseUrl + '/api/services/app/VasPrices/GetAllVasForTableDropdown';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllVasForTableDropdown(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllVasForTableDropdown(<any>response_);
            } catch (e) {
              return <Observable<VasPriceVasLookupTableDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<VasPriceVasLookupTableDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllVasForTableDropdown(response: HttpResponseBase): Observable<VasPriceVasLookupTableDto[]> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(VasPriceVasLookupTableDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<VasPriceVasLookupTableDto[]>(<any>null);
  }
}

@Injectable()
export class WaybillsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param routPointId (optional)
   * @return Success
   */
  getMultipleDropWaybillPdf(routPointId: number | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Waybills/GetMultipleDropWaybillPdf?';
    if (routPointId === null) throw new Error("The parameter 'routPointId' cannot be null.");
    else if (routPointId !== undefined) url_ += 'RoutPointId=' + encodeURIComponent('' + routPointId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMultipleDropWaybillPdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMultipleDropWaybillPdf(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetMultipleDropWaybillPdf(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }

  /**
   * @param shippingRequestTripId (optional)
   * @return Success
   */
  getSingleDropOrMasterWaybillPdf(shippingRequestTripId: number | undefined): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/Waybills/GetSingleDropOrMasterWaybillPdf?';
    if (shippingRequestTripId === null) throw new Error("The parameter 'shippingRequestTripId' cannot be null.");
    else if (shippingRequestTripId !== undefined) url_ += 'shippingRequestTripId=' + encodeURIComponent('' + shippingRequestTripId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSingleDropOrMasterWaybillPdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSingleDropOrMasterWaybillPdf(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSingleDropOrMasterWaybillPdf(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

@Injectable()
export class WebhookEventServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | null | undefined): Observable<WebhookEvent> {
    let url_ = this.baseUrl + '/api/services/app/WebhookEvent/Get?';
    if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<WebhookEvent>>(<any>_observableThrow(e));
            }
          } else return <Observable<WebhookEvent>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WebhookEvent.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<WebhookEvent>(<any>null);
  }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @param subscriptionId (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getAllSendAttempts(
    subscriptionId: string | null | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined
  ): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSendAttempt/GetAllSendAttempts?';
    if (subscriptionId !== undefined) url_ += 'SubscriptionId=' + encodeURIComponent('' + subscriptionId) + '&';
    if (maxResultCount === null) throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined) url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';
    if (skipCount === null) throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined) url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSendAttempts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSendAttempts(<any>response_);
            } catch (e) {
              return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<PagedResultDtoOfGetAllSendAttemptsOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getAllSendAttemptsOfWebhookEvent(id: string | null | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?';
    if (id !== undefined) url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSendAttemptsOfWebhookEvent(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>(<any>null);
  }

  /**
   * @param sendAttemptId (optional)
   * @return Success
   */
  resend(sendAttemptId: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSendAttempt/Resend?';
    if (sendAttemptId !== undefined) url_ += 'sendAttemptId=' + encodeURIComponent('' + sendAttemptId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResend(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResend(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResend(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  publishTestWebhook(): Observable<string> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/PublishTestWebhook';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPublishTestWebhook(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPublishTestWebhook(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/GetAllSubscriptions';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSubscriptions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSubscriptions(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
  }

  /**
   * @param subscriptionId (optional)
   * @return Success
   */
  getSubscription(subscriptionId: string | null | undefined): Observable<WebhookSubscription> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/GetSubscription?';
    if (subscriptionId !== undefined) url_ += 'subscriptionId=' + encodeURIComponent('' + subscriptionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubscription(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubscription(<any>response_);
            } catch (e) {
              return <Observable<WebhookSubscription>>(<any>_observableThrow(e));
            }
          } else return <Observable<WebhookSubscription>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WebhookSubscription.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<WebhookSubscription>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addSubscription(body: WebhookSubscription | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/AddSubscription';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddSubscription(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddSubscription(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddSubscription(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/UpdateSubscription';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSubscription(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSubscription(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/ActivateWebhookSubscription';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivateWebhookSubscription(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivateWebhookSubscription(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param webhookName (optional)
   * @return Success
   */
  isSubscribed(webhookName: string | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/IsSubscribed?';
    if (webhookName !== undefined) url_ += 'webhookName=' + encodeURIComponent('' + webhookName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsSubscribed(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsSubscribed(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param webhookName (optional)
   * @return Success
   */
  getAllSubscriptionsIfFeaturesGranted(webhookName: string | null | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?';
    if (webhookName !== undefined) url_ += 'webhookName=' + encodeURIComponent('' + webhookName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSubscriptionsIfFeaturesGranted(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebhookSubscription/GetAllAvailableWebhooks';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllAvailableWebhooks(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllAvailableWebhooks(<any>response_);
            } catch (e) {
              return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ListResultDtoOfGetAllAvailableWebhooksOutput>(<any>null);
  }
}

@Injectable()
export class WebLogServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
    let url_ = this.baseUrl + '/api/services/app/WebLog/GetLatestWebLogs';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLatestWebLogs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLatestWebLogs(<any>response_);
            } catch (e) {
              return <Observable<GetLatestWebLogsOutput>>(<any>_observableThrow(e));
            }
          } else return <Observable<GetLatestWebLogsOutput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetLatestWebLogsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<GetLatestWebLogsOutput>(<any>null);
  }

  /**
   * @return Success
   */
  downloadWebLogs(): Observable<FileDto> {
    let url_ = this.baseUrl + '/api/services/app/WebLog/DownloadWebLogs';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadWebLogs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadWebLogs(<any>response_);
            } catch (e) {
              return <Observable<FileDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
    const status = response.status;
    const responseBlob = response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FileDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileDto>(<any>null);
  }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName!: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    return data;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export enum TenantAvailabilityState {
  Available = 1,
  InActive = 2,
  NotFound = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state!: TenantAvailabilityState;
  tenantId!: number | undefined;
  serverRootAddress!: string | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data['state'];
      this.tenantId = _data['tenantId'];
      this.serverRootAddress = _data['serverRootAddress'];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['state'] = this.state;
    data['tenantId'] = this.tenantId;
    data['serverRootAddress'] = this.serverRootAddress;
    return data;
  }
}

export interface IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;
  serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
  c!: string | undefined;

  constructor(data?: IResolveTenantIdInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.c = _data['c'];
    }
  }

  static fromJS(data: any): ResolveTenantIdInput {
    data = typeof data === 'object' ? data : {};
    let result = new ResolveTenantIdInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['c'] = this.c;
    return data;
  }
}

export interface IResolveTenantIdInput {
  c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
  name!: string;
  surname!: string;
  userName!: string;
  emailAddress!: string;
  password!: string;
  captchaResponse!: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.password = _data['password'];
      this.captchaResponse = _data['captchaResponse'];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['password'] = this.password;
    data['captchaResponse'] = this.captchaResponse;
    return data;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin!: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data['canLogin'];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canLogin'] = this.canLogin;
    return data;
  }
}

export interface IRegisterOutput {
  canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
  emailAddress!: string;

  constructor(data?: ISendPasswordResetCodeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.emailAddress = _data['emailAddress'];
    }
  }

  static fromJS(data: any): SendPasswordResetCodeInput {
    data = typeof data === 'object' ? data : {};
    let result = new SendPasswordResetCodeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['emailAddress'] = this.emailAddress;
    return data;
  }
}

export interface ISendPasswordResetCodeInput {
  emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
  userId!: number;
  resetCode!: string | undefined;
  password!: string | undefined;
  returnUrl!: string | undefined;
  singleSignIn!: string | undefined;
  c!: string | undefined;

  constructor(data?: IResetPasswordInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.resetCode = _data['resetCode'];
      this.password = _data['password'];
      this.returnUrl = _data['returnUrl'];
      this.singleSignIn = _data['singleSignIn'];
      this.c = _data['c'];
    }
  }

  static fromJS(data: any): ResetPasswordInput {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['resetCode'] = this.resetCode;
    data['password'] = this.password;
    data['returnUrl'] = this.returnUrl;
    data['singleSignIn'] = this.singleSignIn;
    data['c'] = this.c;
    return data;
  }
}

export interface IResetPasswordInput {
  userId: number;
  resetCode: string | undefined;
  password: string | undefined;
  returnUrl: string | undefined;
  singleSignIn: string | undefined;
  c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
  canLogin!: boolean;
  userName!: string | undefined;

  constructor(data?: IResetPasswordOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data['canLogin'];
      this.userName = _data['userName'];
    }
  }

  static fromJS(data: any): ResetPasswordOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canLogin'] = this.canLogin;
    data['userName'] = this.userName;
    return data;
  }
}

export interface IResetPasswordOutput {
  canLogin: boolean;
  userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
  emailAddress!: string;

  constructor(data?: ISendEmailActivationLinkInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.emailAddress = _data['emailAddress'];
    }
  }

  static fromJS(data: any): SendEmailActivationLinkInput {
    data = typeof data === 'object' ? data : {};
    let result = new SendEmailActivationLinkInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['emailAddress'] = this.emailAddress;
    return data;
  }
}

export interface ISendEmailActivationLinkInput {
  emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
  userId!: number;
  confirmationCode!: string | undefined;
  c!: string | undefined;

  constructor(data?: IActivateEmailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.confirmationCode = _data['confirmationCode'];
      this.c = _data['c'];
    }
  }

  static fromJS(data: any): ActivateEmailInput {
    data = typeof data === 'object' ? data : {};
    let result = new ActivateEmailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['confirmationCode'] = this.confirmationCode;
    data['c'] = this.c;
    return data;
  }
}

export interface IActivateEmailInput {
  userId: number;
  confirmationCode: string | undefined;
  c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
  tenantId!: number | undefined;
  userId!: number;

  constructor(data?: IImpersonateInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): ImpersonateInput {
    data = typeof data === 'object' ? data : {};
    let result = new ImpersonateInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IImpersonateInput {
  tenantId: number | undefined;
  userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
  impersonationToken!: string | undefined;
  tenancyName!: string | undefined;

  constructor(data?: IImpersonateOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.impersonationToken = _data['impersonationToken'];
      this.tenancyName = _data['tenancyName'];
    }
  }

  static fromJS(data: any): ImpersonateOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ImpersonateOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['impersonationToken'] = this.impersonationToken;
    data['tenancyName'] = this.tenancyName;
    return data;
  }
}

export interface IImpersonateOutput {
  impersonationToken: string | undefined;
  tenancyName: string | undefined;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
  userDelegationId!: number;

  constructor(data?: IDelegatedImpersonateInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userDelegationId = _data['userDelegationId'];
    }
  }

  static fromJS(data: any): DelegatedImpersonateInput {
    data = typeof data === 'object' ? data : {};
    let result = new DelegatedImpersonateInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userDelegationId'] = this.userDelegationId;
    return data;
  }
}

export interface IDelegatedImpersonateInput {
  userDelegationId: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
  targetTenantId!: number | undefined;
  targetUserId!: number;

  constructor(data?: ISwitchToLinkedAccountInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.targetTenantId = _data['targetTenantId'];
      this.targetUserId = _data['targetUserId'];
    }
  }

  static fromJS(data: any): SwitchToLinkedAccountInput {
    data = typeof data === 'object' ? data : {};
    let result = new SwitchToLinkedAccountInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['targetTenantId'] = this.targetTenantId;
    data['targetUserId'] = this.targetUserId;
    return data;
  }
}

export interface ISwitchToLinkedAccountInput {
  targetTenantId: number | undefined;
  targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
  switchAccountToken!: string | undefined;
  tenancyName!: string | undefined;

  constructor(data?: ISwitchToLinkedAccountOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.switchAccountToken = _data['switchAccountToken'];
      this.tenancyName = _data['tenancyName'];
    }
  }

  static fromJS(data: any): SwitchToLinkedAccountOutput {
    data = typeof data === 'object' ? data : {};
    let result = new SwitchToLinkedAccountOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['switchAccountToken'] = this.switchAccountToken;
    data['tenancyName'] = this.tenancyName;
    return data;
  }
}

export interface ISwitchToLinkedAccountOutput {
  switchAccountToken: string | undefined;
  tenancyName: string | undefined;
}

export enum TerminologyPlatForm {
  AspNetZeroPlatForm = 1,
  TachyonPlatForm = 2,
}

export enum TerminologyAppVersion {
  Angular = 1,
  Mobile = 2,
  Backend = 3,
  BothAngularANDMobile = 4,
  All = 5,
}

export enum TerminologyVersion {
  MVP = 0,
  Phase1 = 1,
  Phase2 = 2,
  Phase3 = 3,
  Phase4 = 4,
  Phase5 = 5,
  Phase6 = 6,
}

export enum TerminologySection {
  None = 0,
  Notification = 1,
  Email = 2,
  SMS = 3,
  Others = 4,
  Error = 5,
  Message = 6,
  Technical = 7,
}

export class AppLocalizationListDto implements IAppLocalizationListDto {
  masterKey!: string | undefined;
  masterValue!: string | undefined;
  value!: string | undefined;
  platForm!: TerminologyPlatForm;
  appVersion!: TerminologyAppVersion;
  version!: TerminologyVersion;
  section!: TerminologySection;
  readonly platFormTitle!: string | undefined;
  readonly appVersionTitle!: string | undefined;
  readonly versionTitle!: string | undefined;
  readonly sectionTitle!: string | undefined;
  id!: number;

  constructor(data?: IAppLocalizationListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterKey = _data['masterKey'];
      this.masterValue = _data['masterValue'];
      this.value = _data['value'];
      this.platForm = _data['platForm'];
      this.appVersion = _data['appVersion'];
      this.version = _data['version'];
      this.section = _data['section'];
      (<any>this).platFormTitle = _data['platFormTitle'];
      (<any>this).appVersionTitle = _data['appVersionTitle'];
      (<any>this).versionTitle = _data['versionTitle'];
      (<any>this).sectionTitle = _data['sectionTitle'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): AppLocalizationListDto {
    data = typeof data === 'object' ? data : {};
    let result = new AppLocalizationListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterKey'] = this.masterKey;
    data['masterValue'] = this.masterValue;
    data['value'] = this.value;
    data['platForm'] = this.platForm;
    data['appVersion'] = this.appVersion;
    data['version'] = this.version;
    data['section'] = this.section;
    data['platFormTitle'] = this.platFormTitle;
    data['appVersionTitle'] = this.appVersionTitle;
    data['versionTitle'] = this.versionTitle;
    data['sectionTitle'] = this.sectionTitle;
    data['id'] = this.id;
    return data;
  }
}

export interface IAppLocalizationListDto {
  masterKey: string | undefined;
  masterValue: string | undefined;
  value: string | undefined;
  platForm: TerminologyPlatForm;
  appVersion: TerminologyAppVersion;
  version: TerminologyVersion;
  section: TerminologySection;
  platFormTitle: string | undefined;
  appVersionTitle: string | undefined;
  versionTitle: string | undefined;
  sectionTitle: string | undefined;
  id: number;
}

export class PagedResultDtoOfAppLocalizationListDto implements IPagedResultDtoOfAppLocalizationListDto {
  totalCount!: number;
  items!: AppLocalizationListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfAppLocalizationListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AppLocalizationListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfAppLocalizationListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfAppLocalizationListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfAppLocalizationListDto {
  totalCount: number;
  items: AppLocalizationListDto[] | undefined;
}

export class TerminologieEditionDto implements ITerminologieEditionDto {
  edition!: string | undefined;
  id!: number;

  constructor(data?: ITerminologieEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TerminologieEditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new TerminologieEditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition;
    data['id'] = this.id;
    return data;
  }
}

export interface ITerminologieEditionDto {
  edition: string | undefined;
  id: number;
}

export class TerminologiePageDto implements ITerminologiePageDto {
  pageUrl!: string | undefined;
  id!: number;

  constructor(data?: ITerminologiePageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageUrl = _data['pageUrl'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TerminologiePageDto {
    data = typeof data === 'object' ? data : {};
    let result = new TerminologiePageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageUrl'] = this.pageUrl;
    data['id'] = this.id;
    return data;
  }
}

export interface ITerminologiePageDto {
  pageUrl: string | undefined;
  id: number;
}

export class AppLocalizationTranslationDto implements IAppLocalizationTranslationDto {
  value!: string;
  language!: string;
  icon!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: IAppLocalizationTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.language = _data['language'];
      this.icon = _data['icon'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): AppLocalizationTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new AppLocalizationTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['language'] = this.language;
    data['icon'] = this.icon;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IAppLocalizationTranslationDto {
  value: string;
  language: string;
  icon: string | undefined;
  displayName: string | undefined;
}

export class AppLocalizationForViewDto implements IAppLocalizationForViewDto {
  masterKey!: string | undefined;
  masterValue!: string | undefined;
  value!: string | undefined;
  terminologieEditions!: TerminologieEditionDto[] | undefined;
  terminologiePages!: TerminologiePageDto[] | undefined;
  translations!: AppLocalizationTranslationDto[] | undefined;
  platForm!: TerminologyPlatForm;
  appVersion!: TerminologyAppVersion;
  version!: TerminologyVersion;
  section!: TerminologySection;
  readonly platFormTitle!: string | undefined;
  readonly appVersionTitle!: string | undefined;
  readonly versionTitle!: string | undefined;
  readonly sectionTitle!: string | undefined;

  constructor(data?: IAppLocalizationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterKey = _data['masterKey'];
      this.masterValue = _data['masterValue'];
      this.value = _data['value'];
      if (Array.isArray(_data['terminologieEditions'])) {
        this.terminologieEditions = [] as any;
        for (let item of _data['terminologieEditions']) this.terminologieEditions!.push(TerminologieEditionDto.fromJS(item));
      }
      if (Array.isArray(_data['terminologiePages'])) {
        this.terminologiePages = [] as any;
        for (let item of _data['terminologiePages']) this.terminologiePages!.push(TerminologiePageDto.fromJS(item));
      }
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(AppLocalizationTranslationDto.fromJS(item));
      }
      this.platForm = _data['platForm'];
      this.appVersion = _data['appVersion'];
      this.version = _data['version'];
      this.section = _data['section'];
      (<any>this).platFormTitle = _data['platFormTitle'];
      (<any>this).appVersionTitle = _data['appVersionTitle'];
      (<any>this).versionTitle = _data['versionTitle'];
      (<any>this).sectionTitle = _data['sectionTitle'];
    }
  }

  static fromJS(data: any): AppLocalizationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new AppLocalizationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterKey'] = this.masterKey;
    data['masterValue'] = this.masterValue;
    data['value'] = this.value;
    if (Array.isArray(this.terminologieEditions)) {
      data['terminologieEditions'] = [];
      for (let item of this.terminologieEditions) data['terminologieEditions'].push(item.toJSON());
    }
    if (Array.isArray(this.terminologiePages)) {
      data['terminologiePages'] = [];
      for (let item of this.terminologiePages) data['terminologiePages'].push(item.toJSON());
    }
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['platForm'] = this.platForm;
    data['appVersion'] = this.appVersion;
    data['version'] = this.version;
    data['section'] = this.section;
    data['platFormTitle'] = this.platFormTitle;
    data['appVersionTitle'] = this.appVersionTitle;
    data['versionTitle'] = this.versionTitle;
    data['sectionTitle'] = this.sectionTitle;
    return data;
  }
}

export interface IAppLocalizationForViewDto {
  masterKey: string | undefined;
  masterValue: string | undefined;
  value: string | undefined;
  terminologieEditions: TerminologieEditionDto[] | undefined;
  terminologiePages: TerminologiePageDto[] | undefined;
  translations: AppLocalizationTranslationDto[] | undefined;
  platForm: TerminologyPlatForm;
  appVersion: TerminologyAppVersion;
  version: TerminologyVersion;
  section: TerminologySection;
  platFormTitle: string | undefined;
  appVersionTitle: string | undefined;
  versionTitle: string | undefined;
  sectionTitle: string | undefined;
}

export class CreateOrEditAppLocalizationDto implements ICreateOrEditAppLocalizationDto {
  masterKey!: string;
  masterValue!: string;
  translations!: AppLocalizationTranslationDto[] | undefined;
  platForm!: TerminologyPlatForm;
  appVersion!: TerminologyAppVersion;
  version!: TerminologyVersion;
  section!: TerminologySection;
  id!: number;

  constructor(data?: ICreateOrEditAppLocalizationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterKey = _data['masterKey'];
      this.masterValue = _data['masterValue'];
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(AppLocalizationTranslationDto.fromJS(item));
      }
      this.platForm = _data['platForm'];
      this.appVersion = _data['appVersion'];
      this.version = _data['version'];
      this.section = _data['section'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditAppLocalizationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditAppLocalizationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterKey'] = this.masterKey;
    data['masterValue'] = this.masterValue;
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['platForm'] = this.platForm;
    data['appVersion'] = this.appVersion;
    data['version'] = this.version;
    data['section'] = this.section;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditAppLocalizationDto {
  masterKey: string;
  masterValue: string;
  translations: AppLocalizationTranslationDto[] | undefined;
  platForm: TerminologyPlatForm;
  appVersion: TerminologyAppVersion;
  version: TerminologyVersion;
  section: TerminologySection;
  id: number;
}

export class AppLocalizationFilterInput implements IAppLocalizationFilterInput {
  filter!: string | undefined;
  editionId!: number | undefined;
  page!: string | undefined;
  platForm!: TerminologyPlatForm;
  appVersion!: TerminologyAppVersion;
  version!: TerminologyVersion;
  section!: TerminologySection;
  sorting!: string | undefined;
  skipCount!: number;
  maxResultCount!: number;

  constructor(data?: IAppLocalizationFilterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.filter = _data['filter'];
      this.editionId = _data['editionId'];
      this.page = _data['page'];
      this.platForm = _data['platForm'];
      this.appVersion = _data['appVersion'];
      this.version = _data['version'];
      this.section = _data['section'];
      this.sorting = _data['sorting'];
      this.skipCount = _data['skipCount'];
      this.maxResultCount = _data['maxResultCount'];
    }
  }

  static fromJS(data: any): AppLocalizationFilterInput {
    data = typeof data === 'object' ? data : {};
    let result = new AppLocalizationFilterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['filter'] = this.filter;
    data['editionId'] = this.editionId;
    data['page'] = this.page;
    data['platForm'] = this.platForm;
    data['appVersion'] = this.appVersion;
    data['version'] = this.version;
    data['section'] = this.section;
    data['sorting'] = this.sorting;
    data['skipCount'] = this.skipCount;
    data['maxResultCount'] = this.maxResultCount;
    return data;
  }
}

export interface IAppLocalizationFilterInput {
  filter: string | undefined;
  editionId: number | undefined;
  page: string | undefined;
  platForm: TerminologyPlatForm;
  appVersion: TerminologyAppVersion;
  version: TerminologyVersion;
  section: TerminologySection;
  sorting: string | undefined;
  skipCount: number;
  maxResultCount: number;
}

export class FileDto implements IFileDto {
  fileName!: string;
  fileType!: string | undefined;
  fileToken!: string;

  constructor(data?: IFileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileName = _data['fileName'];
      this.fileType = _data['fileType'];
      this.fileToken = _data['fileToken'];
    }
  }

  static fromJS(data: any): FileDto {
    data = typeof data === 'object' ? data : {};
    let result = new FileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileName'] = this.fileName;
    data['fileType'] = this.fileType;
    data['fileToken'] = this.fileToken;
    return data;
  }
}

export interface IFileDto {
  fileName: string;
  fileType: string | undefined;
  fileToken: string;
}

export class TerminologieMonitorInput implements ITerminologieMonitorInput {
  key!: string | undefined;
  pageUrl!: string | undefined;

  constructor(data?: ITerminologieMonitorInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data['key'];
      this.pageUrl = _data['pageUrl'];
    }
  }

  static fromJS(data: any): TerminologieMonitorInput {
    data = typeof data === 'object' ? data : {};
    let result = new TerminologieMonitorInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['key'] = this.key;
    data['pageUrl'] = this.pageUrl;
    return data;
  }
}

export interface ITerminologieMonitorInput {
  key: string | undefined;
  pageUrl: string | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
  userId!: number | undefined;
  userName!: string | undefined;
  impersonatorTenantId!: number | undefined;
  impersonatorUserId!: number | undefined;
  serviceName!: string | undefined;
  methodName!: string | undefined;
  parameters!: string | undefined;
  executionTime!: moment.Moment;
  executionDuration!: number;
  clientIpAddress!: string | undefined;
  clientName!: string | undefined;
  browserInfo!: string | undefined;
  exception!: string | undefined;
  customData!: string | undefined;
  id!: number;

  constructor(data?: IAuditLogListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.impersonatorTenantId = _data['impersonatorTenantId'];
      this.impersonatorUserId = _data['impersonatorUserId'];
      this.serviceName = _data['serviceName'];
      this.methodName = _data['methodName'];
      this.parameters = _data['parameters'];
      this.executionTime = _data['executionTime'] ? moment(_data['executionTime'].toString()) : <any>undefined;
      this.executionDuration = _data['executionDuration'];
      this.clientIpAddress = _data['clientIpAddress'];
      this.clientName = _data['clientName'];
      this.browserInfo = _data['browserInfo'];
      this.exception = _data['exception'];
      this.customData = _data['customData'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): AuditLogListDto {
    data = typeof data === 'object' ? data : {};
    let result = new AuditLogListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['impersonatorTenantId'] = this.impersonatorTenantId;
    data['impersonatorUserId'] = this.impersonatorUserId;
    data['serviceName'] = this.serviceName;
    data['methodName'] = this.methodName;
    data['parameters'] = this.parameters;
    data['executionTime'] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
    data['executionDuration'] = this.executionDuration;
    data['clientIpAddress'] = this.clientIpAddress;
    data['clientName'] = this.clientName;
    data['browserInfo'] = this.browserInfo;
    data['exception'] = this.exception;
    data['customData'] = this.customData;
    data['id'] = this.id;
    return data;
  }
}

export interface IAuditLogListDto {
  userId: number | undefined;
  userName: string | undefined;
  impersonatorTenantId: number | undefined;
  impersonatorUserId: number | undefined;
  serviceName: string | undefined;
  methodName: string | undefined;
  parameters: string | undefined;
  executionTime: moment.Moment;
  executionDuration: number;
  clientIpAddress: string | undefined;
  clientName: string | undefined;
  browserInfo: string | undefined;
  exception: string | undefined;
  customData: string | undefined;
  id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
  totalCount!: number;
  items!: AuditLogListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfAuditLogListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AuditLogListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfAuditLogListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfAuditLogListDto {
  totalCount: number;
  items: AuditLogListDto[] | undefined;
}

export class NameValueDto implements INameValueDto {
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: INameValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): NameValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new NameValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface INameValueDto {
  name: string | undefined;
  value: string | undefined;
}

export enum EntityChangeType {
  Created = 0,
  Updated = 1,
  Deleted = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
  userId!: number | undefined;
  userName!: string | undefined;
  changeTime!: moment.Moment;
  entityTypeFullName!: string | undefined;
  changeType!: EntityChangeType;
  readonly changeTypeName!: string | undefined;
  entityChangeSetId!: number;
  id!: number;

  constructor(data?: IEntityChangeListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.changeTime = _data['changeTime'] ? moment(_data['changeTime'].toString()) : <any>undefined;
      this.entityTypeFullName = _data['entityTypeFullName'];
      this.changeType = _data['changeType'];
      (<any>this).changeTypeName = _data['changeTypeName'];
      this.entityChangeSetId = _data['entityChangeSetId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityChangeListDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityChangeListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['changeTime'] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
    data['entityTypeFullName'] = this.entityTypeFullName;
    data['changeType'] = this.changeType;
    data['changeTypeName'] = this.changeTypeName;
    data['entityChangeSetId'] = this.entityChangeSetId;
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityChangeListDto {
  userId: number | undefined;
  userName: string | undefined;
  changeTime: moment.Moment;
  entityTypeFullName: string | undefined;
  changeType: EntityChangeType;
  changeTypeName: string | undefined;
  entityChangeSetId: number;
  id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
  totalCount!: number;
  items!: EntityChangeListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EntityChangeListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfEntityChangeListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfEntityChangeListDto {
  totalCount: number;
  items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
  entityChangeId!: number;
  newValue!: string | undefined;
  originalValue!: string | undefined;
  propertyName!: string | undefined;
  propertyTypeFullName!: string | undefined;
  tenantId!: number | undefined;
  id!: number;

  constructor(data?: IEntityPropertyChangeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityChangeId = _data['entityChangeId'];
      this.newValue = _data['newValue'];
      this.originalValue = _data['originalValue'];
      this.propertyName = _data['propertyName'];
      this.propertyTypeFullName = _data['propertyTypeFullName'];
      this.tenantId = _data['tenantId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityPropertyChangeDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityPropertyChangeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['entityChangeId'] = this.entityChangeId;
    data['newValue'] = this.newValue;
    data['originalValue'] = this.originalValue;
    data['propertyName'] = this.propertyName;
    data['propertyTypeFullName'] = this.propertyTypeFullName;
    data['tenantId'] = this.tenantId;
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityPropertyChangeDto {
  entityChangeId: number;
  newValue: string | undefined;
  originalValue: string | undefined;
  propertyName: string | undefined;
  propertyTypeFullName: string | undefined;
  tenantId: number | undefined;
  id: number;
}

export class BalanceRechargeListDto implements IBalanceRechargeListDto {
  tenantName!: string;
  amount!: number;
  creationTime!: moment.Moment;
  referenceNo!: string | undefined;
  id!: number;

  constructor(data?: IBalanceRechargeListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantName = _data['tenantName'];
      this.amount = _data['amount'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.referenceNo = _data['referenceNo'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): BalanceRechargeListDto {
    data = typeof data === 'object' ? data : {};
    let result = new BalanceRechargeListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantName'] = this.tenantName;
    data['amount'] = this.amount;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['referenceNo'] = this.referenceNo;
    data['id'] = this.id;
    return data;
  }
}

export interface IBalanceRechargeListDto {
  tenantName: string;
  amount: number;
  creationTime: moment.Moment;
  referenceNo: string | undefined;
  id: number;
}

export class PagedResultDtoOfBalanceRechargeListDto implements IPagedResultDtoOfBalanceRechargeListDto {
  totalCount!: number;
  items!: BalanceRechargeListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfBalanceRechargeListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(BalanceRechargeListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfBalanceRechargeListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfBalanceRechargeListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfBalanceRechargeListDto {
  totalCount: number;
  items: BalanceRechargeListDto[] | undefined;
}

export class CreateBalanceRechargeInput implements ICreateBalanceRechargeInput {
  tenantId!: number;
  amount!: number;
  referenceNo!: string | undefined;

  constructor(data?: ICreateBalanceRechargeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.amount = _data['amount'];
      this.referenceNo = _data['referenceNo'];
    }
  }

  static fromJS(data: any): CreateBalanceRechargeInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateBalanceRechargeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['amount'] = this.amount;
    data['referenceNo'] = this.referenceNo;
    return data;
  }
}

export interface ICreateBalanceRechargeInput {
  tenantId: number;
  amount: number;
  referenceNo: string | undefined;
}

export class GetAllBalanceRechargeInput implements IGetAllBalanceRechargeInput {
  tenantId!: number | undefined;
  fromDate!: moment.Moment | undefined;
  toDate!: moment.Moment | undefined;
  referenceNo!: string | undefined;
  minLongitude!: number | undefined;
  maxLongitude!: number | undefined;
  sorting!: string | undefined;
  skipCount!: number;
  maxResultCount!: number;

  constructor(data?: IGetAllBalanceRechargeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.fromDate = _data['fromDate'] ? moment(_data['fromDate'].toString()) : <any>undefined;
      this.toDate = _data['toDate'] ? moment(_data['toDate'].toString()) : <any>undefined;
      this.referenceNo = _data['referenceNo'];
      this.minLongitude = _data['minLongitude'];
      this.maxLongitude = _data['maxLongitude'];
      this.sorting = _data['sorting'];
      this.skipCount = _data['skipCount'];
      this.maxResultCount = _data['maxResultCount'];
    }
  }

  static fromJS(data: any): GetAllBalanceRechargeInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllBalanceRechargeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['fromDate'] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
    data['toDate'] = this.toDate ? this.toDate.toISOString() : <any>undefined;
    data['referenceNo'] = this.referenceNo;
    data['minLongitude'] = this.minLongitude;
    data['maxLongitude'] = this.maxLongitude;
    data['sorting'] = this.sorting;
    data['skipCount'] = this.skipCount;
    data['maxResultCount'] = this.maxResultCount;
    return data;
  }
}

export interface IGetAllBalanceRechargeInput {
  tenantId: number | undefined;
  fromDate: moment.Moment | undefined;
  toDate: moment.Moment | undefined;
  referenceNo: string | undefined;
  minLongitude: number | undefined;
  maxLongitude: number | undefined;
  sorting: string | undefined;
  skipCount: number;
  maxResultCount: number;
}

export class CacheDto implements ICacheDto {
  name!: string | undefined;

  constructor(data?: ICacheDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): CacheDto {
    data = typeof data === 'object' ? data : {};
    let result = new CacheDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ICacheDto {
  name: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
  items!: CacheDto[] | undefined;

  constructor(data?: IListResultDtoOfCacheDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CacheDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfCacheDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfCacheDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfCacheDto {
  items: CacheDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
  id!: string | undefined;

  constructor(data?: IEntityDtoOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDtoOfString {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDtoOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDtoOfString {
  id: string | undefined;
}

export class CapacityDto implements ICapacityDto {
  displayName!: string | undefined;
  trucksTypeId!: number;
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ICapacityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CapacityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CapacityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['trucksTypeId'] = this.trucksTypeId;
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICapacityDto {
  displayName: string | undefined;
  trucksTypeId: number;
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetCapacityForViewDto implements IGetCapacityForViewDto {
  capacity!: CapacityDto;
  truckTypeDisplayName!: string | undefined;

  constructor(data?: IGetCapacityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.capacity = _data['capacity'] ? CapacityDto.fromJS(_data['capacity']) : <any>undefined;
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetCapacityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetCapacityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['capacity'] = this.capacity ? this.capacity.toJSON() : <any>undefined;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    return data;
  }
}

export interface IGetCapacityForViewDto {
  capacity: CapacityDto;
  truckTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetCapacityForViewDto implements IPagedResultDtoOfGetCapacityForViewDto {
  totalCount!: number;
  items!: GetCapacityForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetCapacityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetCapacityForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetCapacityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetCapacityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetCapacityForViewDto {
  totalCount: number;
  items: GetCapacityForViewDto[] | undefined;
}

export class CreateOrEditCapacityDto implements ICreateOrEditCapacityDto {
  displayName!: string;
  trucksTypeId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditCapacityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditCapacityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditCapacityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['trucksTypeId'] = this.trucksTypeId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditCapacityDto {
  displayName: string;
  trucksTypeId: number;
  id: number | undefined;
}

export class GetCapacityForEditOutput implements IGetCapacityForEditOutput {
  capacity!: CreateOrEditCapacityDto;
  truckTypeDisplayName!: string | undefined;

  constructor(data?: IGetCapacityForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.capacity = _data['capacity'] ? CreateOrEditCapacityDto.fromJS(_data['capacity']) : <any>undefined;
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetCapacityForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCapacityForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['capacity'] = this.capacity ? this.capacity.toJSON() : <any>undefined;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    return data;
  }
}

export interface IGetCapacityForEditOutput {
  capacity: CreateOrEditCapacityDto;
  truckTypeDisplayName: string | undefined;
}

export class ISelectItemDto implements IISelectItemDto {
  id!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: IISelectItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): ISelectItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ISelectItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IISelectItemDto {
  id: string | undefined;
  displayName: string | undefined;
}

export enum FriendshipState {
  Accepted = 1,
  Blocked = 2,
}

export class FriendDto implements IFriendDto {
  friendUserId!: number;
  friendTenantId!: number | undefined;
  friendUserName!: string | undefined;
  friendTenancyName!: string | undefined;
  friendProfilePictureId!: string | undefined;
  unreadMessageCount!: number;
  isOnline!: boolean;
  state!: FriendshipState;

  constructor(data?: IFriendDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.friendUserId = _data['friendUserId'];
      this.friendTenantId = _data['friendTenantId'];
      this.friendUserName = _data['friendUserName'];
      this.friendTenancyName = _data['friendTenancyName'];
      this.friendProfilePictureId = _data['friendProfilePictureId'];
      this.unreadMessageCount = _data['unreadMessageCount'];
      this.isOnline = _data['isOnline'];
      this.state = _data['state'];
    }
  }

  static fromJS(data: any): FriendDto {
    data = typeof data === 'object' ? data : {};
    let result = new FriendDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['friendUserId'] = this.friendUserId;
    data['friendTenantId'] = this.friendTenantId;
    data['friendUserName'] = this.friendUserName;
    data['friendTenancyName'] = this.friendTenancyName;
    data['friendProfilePictureId'] = this.friendProfilePictureId;
    data['unreadMessageCount'] = this.unreadMessageCount;
    data['isOnline'] = this.isOnline;
    data['state'] = this.state;
    return data;
  }
}

export interface IFriendDto {
  friendUserId: number;
  friendTenantId: number | undefined;
  friendUserName: string | undefined;
  friendTenancyName: string | undefined;
  friendProfilePictureId: string | undefined;
  unreadMessageCount: number;
  isOnline: boolean;
  state: FriendshipState;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
  serverTime!: moment.Moment;
  friends!: FriendDto[] | undefined;

  constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serverTime = _data['serverTime'] ? moment(_data['serverTime'].toString()) : <any>undefined;
      if (Array.isArray(_data['friends'])) {
        this.friends = [] as any;
        for (let item of _data['friends']) this.friends!.push(FriendDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserChatFriendsWithSettingsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serverTime'] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
    if (Array.isArray(this.friends)) {
      data['friends'] = [];
      for (let item of this.friends) data['friends'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetUserChatFriendsWithSettingsOutput {
  serverTime: moment.Moment;
  friends: FriendDto[] | undefined;
}

export enum ChatSide {
  Sender = 1,
  Receiver = 2,
}

export enum ChatMessageReadState {
  Unread = 1,
  Read = 2,
}

export class ChatMessageDto implements IChatMessageDto {
  userId!: number;
  tenantId!: number | undefined;
  targetUserId!: number;
  targetTenantId!: number | undefined;
  side!: ChatSide;
  readState!: ChatMessageReadState;
  receiverReadState!: ChatMessageReadState;
  message!: string | undefined;
  creationTime!: moment.Moment;
  sharedMessageId!: string | undefined;
  id!: number;

  constructor(data?: IChatMessageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
      this.targetUserId = _data['targetUserId'];
      this.targetTenantId = _data['targetTenantId'];
      this.side = _data['side'];
      this.readState = _data['readState'];
      this.receiverReadState = _data['receiverReadState'];
      this.message = _data['message'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.sharedMessageId = _data['sharedMessageId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ChatMessageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChatMessageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    data['targetUserId'] = this.targetUserId;
    data['targetTenantId'] = this.targetTenantId;
    data['side'] = this.side;
    data['readState'] = this.readState;
    data['receiverReadState'] = this.receiverReadState;
    data['message'] = this.message;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['sharedMessageId'] = this.sharedMessageId;
    data['id'] = this.id;
    return data;
  }
}

export interface IChatMessageDto {
  userId: number;
  tenantId: number | undefined;
  targetUserId: number;
  targetTenantId: number | undefined;
  side: ChatSide;
  readState: ChatMessageReadState;
  receiverReadState: ChatMessageReadState;
  message: string | undefined;
  creationTime: moment.Moment;
  sharedMessageId: string | undefined;
  id: number;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
  items!: ChatMessageDto[] | undefined;

  constructor(data?: IListResultDtoOfChatMessageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ChatMessageDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfChatMessageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfChatMessageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfChatMessageDto {
  items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
  tenantId!: number | undefined;
  userId!: number;

  constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
    data = typeof data === 'object' ? data : {};
    let result = new MarkAllUnreadMessagesOfUserAsReadInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
  tenantId: number | undefined;
  userId: number;
}

export class CityDto implements ICityDto {
  displayName!: string | undefined;
  code!: string | undefined;
  latitude!: string | undefined;
  longitude!: string | undefined;
  countyId!: number;
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ICityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.code = _data['code'];
      this.latitude = _data['latitude'];
      this.longitude = _data['longitude'];
      this.countyId = _data['countyId'];
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['code'] = this.code;
    data['latitude'] = this.latitude;
    data['longitude'] = this.longitude;
    data['countyId'] = this.countyId;
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICityDto {
  displayName: string | undefined;
  code: string | undefined;
  latitude: string | undefined;
  longitude: string | undefined;
  countyId: number;
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetCityForViewDto implements IGetCityForViewDto {
  city!: CityDto;
  countyDisplayName!: string | undefined;

  constructor(data?: IGetCityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data['city'] ? CityDto.fromJS(_data['city']) : <any>undefined;
      this.countyDisplayName = _data['countyDisplayName'];
    }
  }

  static fromJS(data: any): GetCityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetCityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['city'] = this.city ? this.city.toJSON() : <any>undefined;
    data['countyDisplayName'] = this.countyDisplayName;
    return data;
  }
}

export interface IGetCityForViewDto {
  city: CityDto;
  countyDisplayName: string | undefined;
}

export class PagedResultDtoOfGetCityForViewDto implements IPagedResultDtoOfGetCityForViewDto {
  totalCount!: number;
  items!: GetCityForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetCityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetCityForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetCityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetCityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetCityForViewDto {
  totalCount: number;
  items: GetCityForViewDto[] | undefined;
}

export class CreateOrEditCityDto implements ICreateOrEditCityDto {
  displayName!: string;
  code!: string | undefined;
  latitude!: string | undefined;
  longitude!: string | undefined;
  countyId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditCityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.code = _data['code'];
      this.latitude = _data['latitude'];
      this.longitude = _data['longitude'];
      this.countyId = _data['countyId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditCityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditCityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['code'] = this.code;
    data['latitude'] = this.latitude;
    data['longitude'] = this.longitude;
    data['countyId'] = this.countyId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditCityDto {
  displayName: string;
  code: string | undefined;
  latitude: string | undefined;
  longitude: string | undefined;
  countyId: number;
  id: number | undefined;
}

export class GetCityForEditOutput implements IGetCityForEditOutput {
  city!: CreateOrEditCityDto;
  countyDisplayName!: string | undefined;

  constructor(data?: IGetCityForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data['city'] ? CreateOrEditCityDto.fromJS(_data['city']) : <any>undefined;
      this.countyDisplayName = _data['countyDisplayName'];
    }
  }

  static fromJS(data: any): GetCityForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCityForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['city'] = this.city ? this.city.toJSON() : <any>undefined;
    data['countyDisplayName'] = this.countyDisplayName;
    return data;
  }
}

export interface IGetCityForEditOutput {
  city: CreateOrEditCityDto;
  countyDisplayName: string | undefined;
}

export class CityCountyLookupTableDto implements ICityCountyLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ICityCountyLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): CityCountyLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new CityCountyLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ICityCountyLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class CitiesTranslationDto implements ICitiesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: ICitiesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CitiesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CitiesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICitiesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetCitiesTranslationForViewDto implements IGetCitiesTranslationForViewDto {
  citiesTranslation!: CitiesTranslationDto;
  cityDisplayName!: string | undefined;

  constructor(data?: IGetCitiesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citiesTranslation = _data['citiesTranslation'] ? CitiesTranslationDto.fromJS(_data['citiesTranslation']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
    }
  }

  static fromJS(data: any): GetCitiesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetCitiesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['citiesTranslation'] = this.citiesTranslation ? this.citiesTranslation.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    return data;
  }
}

export interface IGetCitiesTranslationForViewDto {
  citiesTranslation: CitiesTranslationDto;
  cityDisplayName: string | undefined;
}

export class PagedResultDtoOfGetCitiesTranslationForViewDto implements IPagedResultDtoOfGetCitiesTranslationForViewDto {
  totalCount!: number;
  items!: GetCitiesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetCitiesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetCitiesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetCitiesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetCitiesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetCitiesTranslationForViewDto {
  totalCount: number;
  items: GetCitiesTranslationForViewDto[] | undefined;
}

export class CreateOrEditCitiesTranslationDto implements ICreateOrEditCitiesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditCitiesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditCitiesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditCitiesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditCitiesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetCitiesTranslationForEditOutput implements IGetCitiesTranslationForEditOutput {
  citiesTranslation!: CreateOrEditCitiesTranslationDto;
  cityDisplayName!: string | undefined;

  constructor(data?: IGetCitiesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citiesTranslation = _data['citiesTranslation'] ? CreateOrEditCitiesTranslationDto.fromJS(_data['citiesTranslation']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
    }
  }

  static fromJS(data: any): GetCitiesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCitiesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['citiesTranslation'] = this.citiesTranslation ? this.citiesTranslation.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    return data;
  }
}

export interface IGetCitiesTranslationForEditOutput {
  citiesTranslation: CreateOrEditCitiesTranslationDto;
  cityDisplayName: string | undefined;
}

export class CitiesTranslationCityLookupTableDto implements ICitiesTranslationCityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ICitiesTranslationCityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): CitiesTranslationCityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new CitiesTranslationCityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ICitiesTranslationCityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
  isFree!: boolean | undefined;
  value!: string | undefined;
  displayText!: string | undefined;
  isSelected!: boolean;

  constructor(data?: ISubscribableEditionComboboxItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isFree = _data['isFree'];
      this.value = _data['value'];
      this.displayText = _data['displayText'];
      this.isSelected = _data['isSelected'];
    }
  }

  static fromJS(data: any): SubscribableEditionComboboxItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscribableEditionComboboxItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isFree'] = this.isFree;
    data['value'] = this.value;
    data['displayText'] = this.displayText;
    data['isSelected'] = this.isSelected;
    return data;
  }
}

export interface ISubscribableEditionComboboxItemDto {
  isFree: boolean | undefined;
  value: string | undefined;
  displayText: string | undefined;
  isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
  items!: SubscribableEditionComboboxItemDto[] | undefined;

  constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
  items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
  tenantId!: number | undefined;
  excludeCurrentUser!: boolean;
  maxResultCount!: number;
  skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IFindUsersInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.excludeCurrentUser = _data['excludeCurrentUser'];
      this.maxResultCount = _data['maxResultCount'];
      this.skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): FindUsersInput {
    data = typeof data === 'object' ? data : {};
    let result = new FindUsersInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['excludeCurrentUser'] = this.excludeCurrentUser;
    data['maxResultCount'] = this.maxResultCount;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IFindUsersInput {
  tenantId: number | undefined;
  excludeCurrentUser: boolean;
  maxResultCount: number;
  skipCount: number;
  filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
  totalCount!: number;
  items!: NameValueDto[] | undefined;

  constructor(data?: IPagedResultDtoOfNameValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfNameValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfNameValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfNameValueDto {
  totalCount: number;
  items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
  name!: string | undefined;

  constructor(data?: IGetDefaultEditionNameOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): GetDefaultEditionNameOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDefaultEditionNameOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface IGetDefaultEditionNameOutput {
  name: string | undefined;
}

export class SelectItemDto implements ISelectItemDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: ISelectItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): SelectItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new SelectItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ISelectItemDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class CountyDto implements ICountyDto {
  displayName!: string | undefined;
  code!: string | undefined;
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ICountyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.code = _data['code'];
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CountyDto {
    data = typeof data === 'object' ? data : {};
    let result = new CountyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['code'] = this.code;
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICountyDto {
  displayName: string | undefined;
  code: string | undefined;
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetCountyForViewDto implements IGetCountyForViewDto {
  county!: CountyDto;

  constructor(data?: IGetCountyForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.county = _data['county'] ? CountyDto.fromJS(_data['county']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetCountyForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetCountyForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['county'] = this.county ? this.county.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetCountyForViewDto {
  county: CountyDto;
}

export class PagedResultDtoOfGetCountyForViewDto implements IPagedResultDtoOfGetCountyForViewDto {
  totalCount!: number;
  items!: GetCountyForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetCountyForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetCountyForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetCountyForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetCountyForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetCountyForViewDto {
  totalCount: number;
  items: GetCountyForViewDto[] | undefined;
}

export class CreateOrEditCountyDto implements ICreateOrEditCountyDto {
  displayName!: string;
  code!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditCountyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.code = _data['code'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditCountyDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditCountyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['code'] = this.code;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditCountyDto {
  displayName: string;
  code: string;
  id: number | undefined;
}

export class GetCountyForEditOutput implements IGetCountyForEditOutput {
  county!: CreateOrEditCountyDto;

  constructor(data?: IGetCountyForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.county = _data['county'] ? CreateOrEditCountyDto.fromJS(_data['county']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetCountyForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCountyForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['county'] = this.county ? this.county.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetCountyForEditOutput {
  county: CreateOrEditCountyDto;
}

export class CountriesTranslationDto implements ICountriesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: ICountriesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CountriesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CountriesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICountriesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetCountriesTranslationForViewDto implements IGetCountriesTranslationForViewDto {
  countriesTranslation!: CountriesTranslationDto;
  countyDisplayName!: string | undefined;

  constructor(data?: IGetCountriesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countriesTranslation = _data['countriesTranslation'] ? CountriesTranslationDto.fromJS(_data['countriesTranslation']) : <any>undefined;
      this.countyDisplayName = _data['countyDisplayName'];
    }
  }

  static fromJS(data: any): GetCountriesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetCountriesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['countriesTranslation'] = this.countriesTranslation ? this.countriesTranslation.toJSON() : <any>undefined;
    data['countyDisplayName'] = this.countyDisplayName;
    return data;
  }
}

export interface IGetCountriesTranslationForViewDto {
  countriesTranslation: CountriesTranslationDto;
  countyDisplayName: string | undefined;
}

export class PagedResultDtoOfGetCountriesTranslationForViewDto implements IPagedResultDtoOfGetCountriesTranslationForViewDto {
  totalCount!: number;
  items!: GetCountriesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetCountriesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetCountriesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetCountriesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetCountriesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetCountriesTranslationForViewDto {
  totalCount: number;
  items: GetCountriesTranslationForViewDto[] | undefined;
}

export class CreateOrEditCountriesTranslationDto implements ICreateOrEditCountriesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditCountriesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditCountriesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditCountriesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditCountriesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetCountriesTranslationForEditOutput implements IGetCountriesTranslationForEditOutput {
  countriesTranslation!: CreateOrEditCountriesTranslationDto;
  countyDisplayName!: string | undefined;

  constructor(data?: IGetCountriesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countriesTranslation = _data['countriesTranslation']
        ? CreateOrEditCountriesTranslationDto.fromJS(_data['countriesTranslation'])
        : <any>undefined;
      this.countyDisplayName = _data['countyDisplayName'];
    }
  }

  static fromJS(data: any): GetCountriesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCountriesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['countriesTranslation'] = this.countriesTranslation ? this.countriesTranslation.toJSON() : <any>undefined;
    data['countyDisplayName'] = this.countyDisplayName;
    return data;
  }
}

export interface IGetCountriesTranslationForEditOutput {
  countriesTranslation: CreateOrEditCountriesTranslationDto;
  countyDisplayName: string | undefined;
}

export class CountriesTranslationCountyLookupTableDto implements ICountriesTranslationCountyLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ICountriesTranslationCountyLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): CountriesTranslationCountyLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new CountriesTranslationCountyLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ICountriesTranslationCountyLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class Widget implements IWidget {
  widgetId!: string | undefined;
  height!: number;
  width!: number;
  positionX!: number;
  positionY!: number;

  constructor(data?: IWidget) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.widgetId = _data['widgetId'];
      this.height = _data['height'];
      this.width = _data['width'];
      this.positionX = _data['positionX'];
      this.positionY = _data['positionY'];
    }
  }

  static fromJS(data: any): Widget {
    data = typeof data === 'object' ? data : {};
    let result = new Widget();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['widgetId'] = this.widgetId;
    data['height'] = this.height;
    data['width'] = this.width;
    data['positionX'] = this.positionX;
    data['positionY'] = this.positionY;
    return data;
  }
}

export interface IWidget {
  widgetId: string | undefined;
  height: number;
  width: number;
  positionX: number;
  positionY: number;
}

export class Page implements IPage {
  id!: string | undefined;
  name!: string | undefined;
  widgets!: Widget[] | undefined;

  constructor(data?: IPage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['widgets'])) {
        this.widgets = [] as any;
        for (let item of _data['widgets']) this.widgets!.push(Widget.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Page {
    data = typeof data === 'object' ? data : {};
    let result = new Page();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.widgets)) {
      data['widgets'] = [];
      for (let item of this.widgets) data['widgets'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPage {
  id: string | undefined;
  name: string | undefined;
  widgets: Widget[] | undefined;
}

export class Dashboard implements IDashboard {
  dashboardName!: string | undefined;
  pages!: Page[] | undefined;

  constructor(data?: IDashboard) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardName = _data['dashboardName'];
      if (Array.isArray(_data['pages'])) {
        this.pages = [] as any;
        for (let item of _data['pages']) this.pages!.push(Page.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Dashboard {
    data = typeof data === 'object' ? data : {};
    let result = new Dashboard();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dashboardName'] = this.dashboardName;
    if (Array.isArray(this.pages)) {
      data['pages'] = [];
      for (let item of this.pages) data['pages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDashboard {
  dashboardName: string | undefined;
  pages: Page[] | undefined;
}

export class SavePageInput implements ISavePageInput {
  dashboardName!: string | undefined;
  application!: string | undefined;
  pages!: Page[] | undefined;

  constructor(data?: ISavePageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardName = _data['dashboardName'];
      this.application = _data['application'];
      if (Array.isArray(_data['pages'])) {
        this.pages = [] as any;
        for (let item of _data['pages']) this.pages!.push(Page.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SavePageInput {
    data = typeof data === 'object' ? data : {};
    let result = new SavePageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dashboardName'] = this.dashboardName;
    data['application'] = this.application;
    if (Array.isArray(this.pages)) {
      data['pages'] = [];
      for (let item of this.pages) data['pages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISavePageInput {
  dashboardName: string | undefined;
  application: string | undefined;
  pages: Page[] | undefined;
}

export class RenamePageInput implements IRenamePageInput {
  dashboardName!: string | undefined;
  id!: string | undefined;
  name!: string | undefined;
  application!: string | undefined;

  constructor(data?: IRenamePageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardName = _data['dashboardName'];
      this.id = _data['id'];
      this.name = _data['name'];
      this.application = _data['application'];
    }
  }

  static fromJS(data: any): RenamePageInput {
    data = typeof data === 'object' ? data : {};
    let result = new RenamePageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dashboardName'] = this.dashboardName;
    data['id'] = this.id;
    data['name'] = this.name;
    data['application'] = this.application;
    return data;
  }
}

export interface IRenamePageInput {
  dashboardName: string | undefined;
  id: string | undefined;
  name: string | undefined;
  application: string | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
  dashboardName!: string | undefined;
  name!: string | undefined;
  application!: string | undefined;

  constructor(data?: IAddNewPageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dashboardName = _data['dashboardName'];
      this.name = _data['name'];
      this.application = _data['application'];
    }
  }

  static fromJS(data: any): AddNewPageInput {
    data = typeof data === 'object' ? data : {};
    let result = new AddNewPageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dashboardName'] = this.dashboardName;
    data['name'] = this.name;
    data['application'] = this.application;
    return data;
  }
}

export interface IAddNewPageInput {
  dashboardName: string | undefined;
  name: string | undefined;
  application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
  pageId!: string | undefined;

  constructor(data?: IAddNewPageOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageId = _data['pageId'];
    }
  }

  static fromJS(data: any): AddNewPageOutput {
    data = typeof data === 'object' ? data : {};
    let result = new AddNewPageOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageId'] = this.pageId;
    return data;
  }
}

export interface IAddNewPageOutput {
  pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
  widgetId!: string | undefined;
  pageId!: string | undefined;
  dashboardName!: string | undefined;
  width!: number;
  height!: number;
  application!: string | undefined;

  constructor(data?: IAddWidgetInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.widgetId = _data['widgetId'];
      this.pageId = _data['pageId'];
      this.dashboardName = _data['dashboardName'];
      this.width = _data['width'];
      this.height = _data['height'];
      this.application = _data['application'];
    }
  }

  static fromJS(data: any): AddWidgetInput {
    data = typeof data === 'object' ? data : {};
    let result = new AddWidgetInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['widgetId'] = this.widgetId;
    data['pageId'] = this.pageId;
    data['dashboardName'] = this.dashboardName;
    data['width'] = this.width;
    data['height'] = this.height;
    data['application'] = this.application;
    return data;
  }
}

export interface IAddWidgetInput {
  widgetId: string | undefined;
  pageId: string | undefined;
  dashboardName: string | undefined;
  width: number;
  height: number;
  application: string | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
  id!: string | undefined;
  name!: string | undefined;

  constructor(data?: IWidgetFilterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): WidgetFilterOutput {
    data = typeof data === 'object' ? data : {};
    let result = new WidgetFilterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IWidgetFilterOutput {
  id: string | undefined;
  name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
  id!: string | undefined;
  name!: string | undefined;
  description!: string | undefined;
  filters!: WidgetFilterOutput[] | undefined;

  constructor(data?: IWidgetOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(WidgetFilterOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): WidgetOutput {
    data = typeof data === 'object' ? data : {};
    let result = new WidgetOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWidgetOutput {
  id: string | undefined;
  name: string | undefined;
  description: string | undefined;
  filters: WidgetFilterOutput[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
  name!: string | undefined;
  widgets!: WidgetOutput[] | undefined;

  constructor(data?: IDashboardOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (Array.isArray(_data['widgets'])) {
        this.widgets = [] as any;
        for (let item of _data['widgets']) this.widgets!.push(WidgetOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DashboardOutput {
    data = typeof data === 'object' ? data : {};
    let result = new DashboardOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (Array.isArray(this.widgets)) {
      data['widgets'] = [];
      for (let item of this.widgets) data['widgets'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDashboardOutput {
  name: string | undefined;
  widgets: WidgetOutput[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
  dateString!: string | undefined;

  constructor(data?: IDateToStringOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateString = _data['dateString'];
    }
  }

  static fromJS(data: any): DateToStringOutput {
    data = typeof data === 'object' ? data : {};
    let result = new DateToStringOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dateString'] = this.dateString;
    return data;
  }
}

export interface IDateToStringOutput {
  dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: INameValueOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): NameValueOfString {
    data = typeof data === 'object' ? data : {};
    let result = new NameValueOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface INameValueOfString {
  name: string | undefined;
  value: string | undefined;
}

export class StringOutput implements IStringOutput {
  output!: string | undefined;

  constructor(data?: IStringOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.output = _data['output'];
    }
  }

  static fromJS(data: any): StringOutput {
    data = typeof data === 'object' ? data : {};
    let result = new StringOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['output'] = this.output;
    return data;
  }
}

export interface IStringOutput {
  output: string | undefined;
}

export enum DocumentsEntitiesEnum {
  Tenant = 1,
  Driver = 2,
  Truck = 3,
}

export class DocumentFileDto implements IDocumentFileDto {
  name!: string | undefined;
  extn!: string | undefined;
  binaryObjectId!: string | undefined;
  expirationDate!: moment.Moment | undefined;
  isAccepted!: boolean;
  isRejected!: boolean;
  rejectionReason!: string | undefined;
  documentTypeId!: number;
  truckId!: number | undefined;
  trailerId!: number | undefined;
  userId!: number | undefined;
  number!: string | undefined;
  notes!: string | undefined;
  hijriExpirationDate!: string | undefined;
  creationTime!: moment.Moment;
  id!: string;

  constructor(data?: IDocumentFileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.extn = _data['extn'];
      this.binaryObjectId = _data['binaryObjectId'];
      this.expirationDate = _data['expirationDate'] ? moment(_data['expirationDate'].toString()) : <any>undefined;
      this.isAccepted = _data['isAccepted'];
      this.isRejected = _data['isRejected'];
      this.rejectionReason = _data['rejectionReason'];
      this.documentTypeId = _data['documentTypeId'];
      this.truckId = _data['truckId'];
      this.trailerId = _data['trailerId'];
      this.userId = _data['userId'];
      this.number = _data['number'];
      this.notes = _data['notes'];
      this.hijriExpirationDate = _data['hijriExpirationDate'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DocumentFileDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['extn'] = this.extn;
    data['binaryObjectId'] = this.binaryObjectId;
    data['expirationDate'] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
    data['isAccepted'] = this.isAccepted;
    data['isRejected'] = this.isRejected;
    data['rejectionReason'] = this.rejectionReason;
    data['documentTypeId'] = this.documentTypeId;
    data['truckId'] = this.truckId;
    data['trailerId'] = this.trailerId;
    data['userId'] = this.userId;
    data['number'] = this.number;
    data['notes'] = this.notes;
    data['hijriExpirationDate'] = this.hijriExpirationDate;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IDocumentFileDto {
  name: string | undefined;
  extn: string | undefined;
  binaryObjectId: string | undefined;
  expirationDate: moment.Moment | undefined;
  isAccepted: boolean;
  isRejected: boolean;
  rejectionReason: string | undefined;
  documentTypeId: number;
  truckId: number | undefined;
  trailerId: number | undefined;
  userId: number | undefined;
  number: string | undefined;
  notes: string | undefined;
  hijriExpirationDate: string | undefined;
  creationTime: moment.Moment;
  id: string;
}

export class UserInGetDocumentFileForViewDto implements IUserInGetDocumentFileForViewDto {
  name!: string | undefined;
  surname!: string | undefined;
  userName!: string | undefined;
  emailAddress!: string | undefined;
  phoneNumber!: string | undefined;
  isActive!: boolean;
  id!: number;

  constructor(data?: IUserInGetDocumentFileForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.phoneNumber = _data['phoneNumber'];
      this.isActive = _data['isActive'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserInGetDocumentFileForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserInGetDocumentFileForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['phoneNumber'] = this.phoneNumber;
    data['isActive'] = this.isActive;
    data['id'] = this.id;
    return data;
  }
}

export interface IUserInGetDocumentFileForViewDto {
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  isActive: boolean;
  id: number;
}

export class DocumentTypeDto implements IDocumentTypeDto {
  name!: string | undefined;
  language!: string | undefined;
  displayName!: string | undefined;
  isRequired!: boolean;
  hasExpirationDate!: boolean;
  requiredFrom!: string | undefined;
  edition!: string | undefined;
  hasNumber!: boolean;
  hasNotes!: boolean;
  isNumberUnique!: boolean;
  specialConstant!: string | undefined;
  numberMinDigits!: number | undefined;
  numberMaxDigits!: number | undefined;
  expirationAlertDays!: number | undefined;
  inActiveAccountExpired!: boolean;
  inActiveToleranceDays!: number | undefined;
  hasHijriExpirationDate!: boolean;
  id!: number;

  constructor(data?: IDocumentTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.language = _data['language'];
      this.displayName = _data['displayName'];
      this.isRequired = _data['isRequired'];
      this.hasExpirationDate = _data['hasExpirationDate'];
      this.requiredFrom = _data['requiredFrom'];
      this.edition = _data['edition'];
      this.hasNumber = _data['hasNumber'];
      this.hasNotes = _data['hasNotes'];
      this.isNumberUnique = _data['isNumberUnique'];
      this.specialConstant = _data['specialConstant'];
      this.numberMinDigits = _data['numberMinDigits'];
      this.numberMaxDigits = _data['numberMaxDigits'];
      this.expirationAlertDays = _data['expirationAlertDays'];
      this.inActiveAccountExpired = _data['inActiveAccountExpired'];
      this.inActiveToleranceDays = _data['inActiveToleranceDays'];
      this.hasHijriExpirationDate = _data['hasHijriExpirationDate'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DocumentTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['language'] = this.language;
    data['displayName'] = this.displayName;
    data['isRequired'] = this.isRequired;
    data['hasExpirationDate'] = this.hasExpirationDate;
    data['requiredFrom'] = this.requiredFrom;
    data['edition'] = this.edition;
    data['hasNumber'] = this.hasNumber;
    data['hasNotes'] = this.hasNotes;
    data['isNumberUnique'] = this.isNumberUnique;
    data['specialConstant'] = this.specialConstant;
    data['numberMinDigits'] = this.numberMinDigits;
    data['numberMaxDigits'] = this.numberMaxDigits;
    data['expirationAlertDays'] = this.expirationAlertDays;
    data['inActiveAccountExpired'] = this.inActiveAccountExpired;
    data['inActiveToleranceDays'] = this.inActiveToleranceDays;
    data['hasHijriExpirationDate'] = this.hasHijriExpirationDate;
    data['id'] = this.id;
    return data;
  }
}

export interface IDocumentTypeDto {
  name: string | undefined;
  language: string | undefined;
  displayName: string | undefined;
  isRequired: boolean;
  hasExpirationDate: boolean;
  requiredFrom: string | undefined;
  edition: string | undefined;
  hasNumber: boolean;
  hasNotes: boolean;
  isNumberUnique: boolean;
  specialConstant: string | undefined;
  numberMinDigits: number | undefined;
  numberMaxDigits: number | undefined;
  expirationAlertDays: number | undefined;
  inActiveAccountExpired: boolean;
  inActiveToleranceDays: number | undefined;
  hasHijriExpirationDate: boolean;
  id: number;
}

export class GetDocumentFileForViewDto implements IGetDocumentFileForViewDto {
  documentFile!: DocumentFileDto;
  submitterTenatTenancyName!: string | undefined;
  documentEntityDisplayName!: string | undefined;
  truckId!: string | undefined;
  plateNumber!: string | undefined;
  trailerTrailerCode!: string | undefined;
  userName!: string | undefined;
  user!: UserInGetDocumentFileForViewDto;
  documentType!: DocumentTypeDto;

  constructor(data?: IGetDocumentFileForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentFile = _data['documentFile'] ? DocumentFileDto.fromJS(_data['documentFile']) : <any>undefined;
      this.submitterTenatTenancyName = _data['submitterTenatTenancyName'];
      this.documentEntityDisplayName = _data['documentEntityDisplayName'];
      this.truckId = _data['truckId'];
      this.plateNumber = _data['plateNumber'];
      this.trailerTrailerCode = _data['trailerTrailerCode'];
      this.userName = _data['userName'];
      this.user = _data['user'] ? UserInGetDocumentFileForViewDto.fromJS(_data['user']) : <any>undefined;
      this.documentType = _data['documentType'] ? DocumentTypeDto.fromJS(_data['documentType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentFileForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentFileForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentFile'] = this.documentFile ? this.documentFile.toJSON() : <any>undefined;
    data['submitterTenatTenancyName'] = this.submitterTenatTenancyName;
    data['documentEntityDisplayName'] = this.documentEntityDisplayName;
    data['truckId'] = this.truckId;
    data['plateNumber'] = this.plateNumber;
    data['trailerTrailerCode'] = this.trailerTrailerCode;
    data['userName'] = this.userName;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    data['documentType'] = this.documentType ? this.documentType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentFileForViewDto {
  documentFile: DocumentFileDto;
  submitterTenatTenancyName: string | undefined;
  documentEntityDisplayName: string | undefined;
  truckId: string | undefined;
  plateNumber: string | undefined;
  trailerTrailerCode: string | undefined;
  userName: string | undefined;
  user: UserInGetDocumentFileForViewDto;
  documentType: DocumentTypeDto;
}

export class PagedResultDtoOfGetDocumentFileForViewDto implements IPagedResultDtoOfGetDocumentFileForViewDto {
  totalCount!: number;
  items!: GetDocumentFileForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetDocumentFileForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetDocumentFileForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetDocumentFileForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetDocumentFileForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetDocumentFileForViewDto {
  totalCount: number;
  items: GetDocumentFileForViewDto[] | undefined;
}

export class UpdateDocumentFileInput implements IUpdateDocumentFileInput {
  fileToken!: string | undefined;

  constructor(data?: IUpdateDocumentFileInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileToken = _data['fileToken'];
    }
  }

  static fromJS(data: any): UpdateDocumentFileInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDocumentFileInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileToken'] = this.fileToken;
    return data;
  }
}

export interface IUpdateDocumentFileInput {
  fileToken: string | undefined;
}

export class CreateOrEditDocumentFileDto implements ICreateOrEditDocumentFileDto {
  documentTypeDto!: DocumentTypeDto;
  updateDocumentFileInput!: UpdateDocumentFileInput;
  name!: string;
  extn!: string;
  binaryObjectId!: string;
  expirationDate!: moment.Moment | undefined;
  isAccepted!: boolean;
  isRejected!: boolean;
  documentTypeId!: number | undefined;
  truckId!: number | undefined;
  trailerId!: number | undefined;
  userId!: number | undefined;
  routStepId!: number | undefined;
  shippingRequestTripId!: number | undefined;
  number!: string | undefined;
  notes!: string | undefined;
  hijriExpirationDate!: string | undefined;
  entityId!: string | undefined;
  entityType!: DocumentsEntitiesEnum;
  id!: string | undefined;

  constructor(data?: ICreateOrEditDocumentFileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentTypeDto = _data['documentTypeDto'] ? DocumentTypeDto.fromJS(_data['documentTypeDto']) : <any>undefined;
      this.updateDocumentFileInput = _data['updateDocumentFileInput']
        ? UpdateDocumentFileInput.fromJS(_data['updateDocumentFileInput'])
        : <any>undefined;
      this.name = _data['name'];
      this.extn = _data['extn'];
      this.binaryObjectId = _data['binaryObjectId'];
      this.expirationDate = _data['expirationDate'] ? moment(_data['expirationDate'].toString()) : <any>undefined;
      this.isAccepted = _data['isAccepted'];
      this.isRejected = _data['isRejected'];
      this.documentTypeId = _data['documentTypeId'];
      this.truckId = _data['truckId'];
      this.trailerId = _data['trailerId'];
      this.userId = _data['userId'];
      this.routStepId = _data['routStepId'];
      this.shippingRequestTripId = _data['shippingRequestTripId'];
      this.number = _data['number'];
      this.notes = _data['notes'];
      this.hijriExpirationDate = _data['hijriExpirationDate'];
      this.entityId = _data['entityId'];
      this.entityType = _data['entityType'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditDocumentFileDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditDocumentFileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentTypeDto'] = this.documentTypeDto ? this.documentTypeDto.toJSON() : <any>undefined;
    data['updateDocumentFileInput'] = this.updateDocumentFileInput ? this.updateDocumentFileInput.toJSON() : <any>undefined;
    data['name'] = this.name;
    data['extn'] = this.extn;
    data['binaryObjectId'] = this.binaryObjectId;
    data['expirationDate'] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
    data['isAccepted'] = this.isAccepted;
    data['isRejected'] = this.isRejected;
    data['documentTypeId'] = this.documentTypeId;
    data['truckId'] = this.truckId;
    data['trailerId'] = this.trailerId;
    data['userId'] = this.userId;
    data['routStepId'] = this.routStepId;
    data['shippingRequestTripId'] = this.shippingRequestTripId;
    data['number'] = this.number;
    data['notes'] = this.notes;
    data['hijriExpirationDate'] = this.hijriExpirationDate;
    data['entityId'] = this.entityId;
    data['entityType'] = this.entityType;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditDocumentFileDto {
  documentTypeDto: DocumentTypeDto;
  updateDocumentFileInput: UpdateDocumentFileInput;
  name: string;
  extn: string;
  binaryObjectId: string;
  expirationDate: moment.Moment | undefined;
  isAccepted: boolean;
  isRejected: boolean;
  documentTypeId: number | undefined;
  truckId: number | undefined;
  trailerId: number | undefined;
  userId: number | undefined;
  routStepId: number | undefined;
  shippingRequestTripId: number | undefined;
  number: string | undefined;
  notes: string | undefined;
  hijriExpirationDate: string | undefined;
  entityId: string | undefined;
  entityType: DocumentsEntitiesEnum;
  id: string | undefined;
}

export class GetDocumentFileForEditOutput implements IGetDocumentFileForEditOutput {
  documentFile!: CreateOrEditDocumentFileDto;

  constructor(data?: IGetDocumentFileForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentFile = _data['documentFile'] ? CreateOrEditDocumentFileDto.fromJS(_data['documentFile']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentFileForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentFileForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentFile'] = this.documentFile ? this.documentFile.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentFileForEditOutput {
  documentFile: CreateOrEditDocumentFileDto;
}

export class DocumentFileDocumentTypeLookupTableDto implements IDocumentFileDocumentTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IDocumentFileDocumentTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentFileDocumentTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileDocumentTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentFileDocumentTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class DocumentFileTruckLookupTableDto implements IDocumentFileTruckLookupTableDto {
  id!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: IDocumentFileTruckLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentFileTruckLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileTruckLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentFileTruckLookupTableDto {
  id: string | undefined;
  displayName: string | undefined;
}

export class DocumentFileTrailerLookupTableDto implements IDocumentFileTrailerLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IDocumentFileTrailerLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentFileTrailerLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileTrailerLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentFileTrailerLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class DocumentFileUserLookupTableDto implements IDocumentFileUserLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IDocumentFileUserLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentFileUserLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileUserLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentFileUserLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class DocumentFileRoutStepLookupTableDto implements IDocumentFileRoutStepLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IDocumentFileRoutStepLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentFileRoutStepLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentFileRoutStepLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentFileRoutStepLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class GetTenantSubmittedDocumnetForView implements IGetTenantSubmittedDocumnetForView {
  id!: string;
  name!: string | undefined;
  extn!: string | undefined;
  isAccepted!: boolean;
  isRejected!: boolean;
  expirationDate!: moment.Moment | undefined;
  rejectionReason!: string | undefined;
  documentTypeDto!: DocumentTypeDto;

  constructor(data?: IGetTenantSubmittedDocumnetForView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.extn = _data['extn'];
      this.isAccepted = _data['isAccepted'];
      this.isRejected = _data['isRejected'];
      this.expirationDate = _data['expirationDate'] ? moment(_data['expirationDate'].toString()) : <any>undefined;
      this.rejectionReason = _data['rejectionReason'];
      this.documentTypeDto = _data['documentTypeDto'] ? DocumentTypeDto.fromJS(_data['documentTypeDto']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTenantSubmittedDocumnetForView {
    data = typeof data === 'object' ? data : {};
    let result = new GetTenantSubmittedDocumnetForView();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['extn'] = this.extn;
    data['isAccepted'] = this.isAccepted;
    data['isRejected'] = this.isRejected;
    data['expirationDate'] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
    data['rejectionReason'] = this.rejectionReason;
    data['documentTypeDto'] = this.documentTypeDto ? this.documentTypeDto.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTenantSubmittedDocumnetForView {
  id: string;
  name: string | undefined;
  extn: string | undefined;
  isAccepted: boolean;
  isRejected: boolean;
  expirationDate: moment.Moment | undefined;
  rejectionReason: string | undefined;
  documentTypeDto: DocumentTypeDto;
}

export class DocumentUniqueCheckOutput implements IDocumentUniqueCheckOutput {
  documentTypeId!: string | undefined;
  number!: string | undefined;

  constructor(data?: IDocumentUniqueCheckOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentTypeId = _data['documentTypeId'];
      this.number = _data['number'];
    }
  }

  static fromJS(data: any): DocumentUniqueCheckOutput {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentUniqueCheckOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentTypeId'] = this.documentTypeId;
    data['number'] = this.number;
    return data;
  }
}

export interface IDocumentUniqueCheckOutput {
  documentTypeId: string | undefined;
  number: string | undefined;
}

export class DocumentsEntityDto implements IDocumentsEntityDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IDocumentsEntityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DocumentsEntityDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentsEntityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IDocumentsEntityDto {
  displayName: string | undefined;
  id: number;
}

export class GetDocumentsEntityForViewDto implements IGetDocumentsEntityForViewDto {
  documentsEntity!: DocumentsEntityDto;

  constructor(data?: IGetDocumentsEntityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentsEntity = _data['documentsEntity'] ? DocumentsEntityDto.fromJS(_data['documentsEntity']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentsEntityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentsEntityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentsEntity'] = this.documentsEntity ? this.documentsEntity.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentsEntityForViewDto {
  documentsEntity: DocumentsEntityDto;
}

export class PagedResultDtoOfGetDocumentsEntityForViewDto implements IPagedResultDtoOfGetDocumentsEntityForViewDto {
  totalCount!: number;
  items!: GetDocumentsEntityForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetDocumentsEntityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetDocumentsEntityForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetDocumentsEntityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetDocumentsEntityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetDocumentsEntityForViewDto {
  totalCount: number;
  items: GetDocumentsEntityForViewDto[] | undefined;
}

export class CreateOrEditDocumentsEntityDto implements ICreateOrEditDocumentsEntityDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditDocumentsEntityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditDocumentsEntityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditDocumentsEntityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditDocumentsEntityDto {
  displayName: string;
  id: number | undefined;
}

export class GetDocumentsEntityForEditOutput implements IGetDocumentsEntityForEditOutput {
  documentsEntity!: CreateOrEditDocumentsEntityDto;

  constructor(data?: IGetDocumentsEntityForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentsEntity = _data['documentsEntity'] ? CreateOrEditDocumentsEntityDto.fromJS(_data['documentsEntity']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentsEntityForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentsEntityForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentsEntity'] = this.documentsEntity ? this.documentsEntity.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentsEntityForEditOutput {
  documentsEntity: CreateOrEditDocumentsEntityDto;
}

export class GetDocumentTypeForViewDto implements IGetDocumentTypeForViewDto {
  documentType!: DocumentTypeDto;

  constructor(data?: IGetDocumentTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentType = _data['documentType'] ? DocumentTypeDto.fromJS(_data['documentType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentType'] = this.documentType ? this.documentType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentTypeForViewDto {
  documentType: DocumentTypeDto;
}

export class PagedResultDtoOfGetDocumentTypeForViewDto implements IPagedResultDtoOfGetDocumentTypeForViewDto {
  totalCount!: number;
  items!: GetDocumentTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetDocumentTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetDocumentTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetDocumentTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetDocumentTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetDocumentTypeForViewDto {
  totalCount: number;
  items: GetDocumentTypeForViewDto[] | undefined;
}

export class CreateOrEditDocumentTypeDto implements ICreateOrEditDocumentTypeDto {
  displayName!: string;
  isRequired!: boolean;
  hasExpirationDate!: boolean;
  documentsEntityId!: number;
  editionId!: number | undefined;
  hasNumber!: boolean;
  hasNotes!: boolean;
  isNumberUnique!: boolean;
  specialConstant!: string | undefined;
  numberMinDigits!: number | undefined;
  numberMaxDigits!: number | undefined;
  expirationAlertDays!: number | undefined;
  inActiveAccountExpired!: boolean;
  inActiveToleranceDays!: number | undefined;
  hasHijriExpirationDate!: boolean;
  id!: number | undefined;

  constructor(data?: ICreateOrEditDocumentTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.isRequired = _data['isRequired'];
      this.hasExpirationDate = _data['hasExpirationDate'];
      this.documentsEntityId = _data['documentsEntityId'];
      this.editionId = _data['editionId'];
      this.hasNumber = _data['hasNumber'];
      this.hasNotes = _data['hasNotes'];
      this.isNumberUnique = _data['isNumberUnique'];
      this.specialConstant = _data['specialConstant'];
      this.numberMinDigits = _data['numberMinDigits'];
      this.numberMaxDigits = _data['numberMaxDigits'];
      this.expirationAlertDays = _data['expirationAlertDays'];
      this.inActiveAccountExpired = _data['inActiveAccountExpired'];
      this.inActiveToleranceDays = _data['inActiveToleranceDays'];
      this.hasHijriExpirationDate = _data['hasHijriExpirationDate'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditDocumentTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditDocumentTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['isRequired'] = this.isRequired;
    data['hasExpirationDate'] = this.hasExpirationDate;
    data['documentsEntityId'] = this.documentsEntityId;
    data['editionId'] = this.editionId;
    data['hasNumber'] = this.hasNumber;
    data['hasNotes'] = this.hasNotes;
    data['isNumberUnique'] = this.isNumberUnique;
    data['specialConstant'] = this.specialConstant;
    data['numberMinDigits'] = this.numberMinDigits;
    data['numberMaxDigits'] = this.numberMaxDigits;
    data['expirationAlertDays'] = this.expirationAlertDays;
    data['inActiveAccountExpired'] = this.inActiveAccountExpired;
    data['inActiveToleranceDays'] = this.inActiveToleranceDays;
    data['hasHijriExpirationDate'] = this.hasHijriExpirationDate;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditDocumentTypeDto {
  displayName: string;
  isRequired: boolean;
  hasExpirationDate: boolean;
  documentsEntityId: number;
  editionId: number | undefined;
  hasNumber: boolean;
  hasNotes: boolean;
  isNumberUnique: boolean;
  specialConstant: string | undefined;
  numberMinDigits: number | undefined;
  numberMaxDigits: number | undefined;
  expirationAlertDays: number | undefined;
  inActiveAccountExpired: boolean;
  inActiveToleranceDays: number | undefined;
  hasHijriExpirationDate: boolean;
  id: number | undefined;
}

export class GetDocumentTypeForEditOutput implements IGetDocumentTypeForEditOutput {
  documentType!: CreateOrEditDocumentTypeDto;

  constructor(data?: IGetDocumentTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentType = _data['documentType'] ? CreateOrEditDocumentTypeDto.fromJS(_data['documentType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetDocumentTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentType'] = this.documentType ? this.documentType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetDocumentTypeForEditOutput {
  documentType: CreateOrEditDocumentTypeDto;
}

export class DocumentTypeTranslationDto implements IDocumentTypeTranslationDto {
  name!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: IDocumentTypeTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DocumentTypeTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentTypeTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface IDocumentTypeTranslationDto {
  name: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetDocumentTypeTranslationForViewDto implements IGetDocumentTypeTranslationForViewDto {
  documentTypeTranslation!: DocumentTypeTranslationDto;
  documentTypeDisplayName!: string | undefined;

  constructor(data?: IGetDocumentTypeTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentTypeTranslation = _data['documentTypeTranslation']
        ? DocumentTypeTranslationDto.fromJS(_data['documentTypeTranslation'])
        : <any>undefined;
      this.documentTypeDisplayName = _data['documentTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetDocumentTypeTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentTypeTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentTypeTranslation'] = this.documentTypeTranslation ? this.documentTypeTranslation.toJSON() : <any>undefined;
    data['documentTypeDisplayName'] = this.documentTypeDisplayName;
    return data;
  }
}

export interface IGetDocumentTypeTranslationForViewDto {
  documentTypeTranslation: DocumentTypeTranslationDto;
  documentTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetDocumentTypeTranslationForViewDto implements IPagedResultDtoOfGetDocumentTypeTranslationForViewDto {
  totalCount!: number;
  items!: GetDocumentTypeTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetDocumentTypeTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetDocumentTypeTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetDocumentTypeTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetDocumentTypeTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetDocumentTypeTranslationForViewDto {
  totalCount: number;
  items: GetDocumentTypeTranslationForViewDto[] | undefined;
}

export class CreateOrEditDocumentTypeTranslationDto implements ICreateOrEditDocumentTypeTranslationDto {
  name!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditDocumentTypeTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditDocumentTypeTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditDocumentTypeTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditDocumentTypeTranslationDto {
  name: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetDocumentTypeTranslationForEditOutput implements IGetDocumentTypeTranslationForEditOutput {
  documentTypeTranslation!: CreateOrEditDocumentTypeTranslationDto;
  documentTypeDisplayName!: string | undefined;

  constructor(data?: IGetDocumentTypeTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentTypeTranslation = _data['documentTypeTranslation']
        ? CreateOrEditDocumentTypeTranslationDto.fromJS(_data['documentTypeTranslation'])
        : <any>undefined;
      this.documentTypeDisplayName = _data['documentTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetDocumentTypeTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDocumentTypeTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentTypeTranslation'] = this.documentTypeTranslation ? this.documentTypeTranslation.toJSON() : <any>undefined;
    data['documentTypeDisplayName'] = this.documentTypeDisplayName;
    return data;
  }
}

export interface IGetDocumentTypeTranslationForEditOutput {
  documentTypeTranslation: CreateOrEditDocumentTypeTranslationDto;
  documentTypeDisplayName: string | undefined;
}

export class DocumentTypeTranslationDocumentTypeLookupTableDto implements IDocumentTypeTranslationDocumentTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IDocumentTypeTranslationDocumentTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): DocumentTypeTranslationDocumentTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new DocumentTypeTranslationDocumentTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IDocumentTypeTranslationDocumentTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class DriverDetailDto implements IDriverDetailDto {
  fullName!: string | undefined;
  phoneNumber!: string | undefined;
  emailAddress!: string | undefined;
  plateNumber!: string | undefined;
  picture!: string | undefined;
  trucksType!: string | undefined;
  langaugeCode!: string | undefined;
  langaugeName!: string | undefined;
  langaugeNative!: string | undefined;

  constructor(data?: IDriverDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName'];
      this.phoneNumber = _data['phoneNumber'];
      this.emailAddress = _data['emailAddress'];
      this.plateNumber = _data['plateNumber'];
      this.picture = _data['picture'];
      this.trucksType = _data['trucksType'];
      this.langaugeCode = _data['langaugeCode'];
      this.langaugeName = _data['langaugeName'];
      this.langaugeNative = _data['langaugeNative'];
    }
  }

  static fromJS(data: any): DriverDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new DriverDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName;
    data['phoneNumber'] = this.phoneNumber;
    data['emailAddress'] = this.emailAddress;
    data['plateNumber'] = this.plateNumber;
    data['picture'] = this.picture;
    data['trucksType'] = this.trucksType;
    data['langaugeCode'] = this.langaugeCode;
    data['langaugeName'] = this.langaugeName;
    data['langaugeNative'] = this.langaugeNative;
    return data;
  }
}

export interface IDriverDetailDto {
  fullName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  plateNumber: string | undefined;
  picture: string | undefined;
  trucksType: string | undefined;
  langaugeCode: string | undefined;
  langaugeName: string | undefined;
  langaugeNative: string | undefined;
}

export class UserDeviceTokenDto implements IUserDeviceTokenDto {
  userId!: number;
  deviceId!: string | undefined;
  token!: string | undefined;
  expireDate!: moment.Moment | undefined;

  constructor(data?: IUserDeviceTokenDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.deviceId = _data['deviceId'];
      this.token = _data['token'];
      this.expireDate = _data['expireDate'] ? moment(_data['expireDate'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): UserDeviceTokenDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDeviceTokenDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['deviceId'] = this.deviceId;
    data['token'] = this.token;
    data['expireDate'] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUserDeviceTokenDto {
  userId: number;
  deviceId: string | undefined;
  token: string | undefined;
  expireDate: moment.Moment | undefined;
}

export class DynamicParameterDto implements IDynamicParameterDto {
  parameterName!: string | undefined;
  inputType!: string | undefined;
  permission!: string | undefined;
  tenantId!: number | undefined;
  id!: number;

  constructor(data?: IDynamicParameterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parameterName = _data['parameterName'];
      this.inputType = _data['inputType'];
      this.permission = _data['permission'];
      this.tenantId = _data['tenantId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DynamicParameterDto {
    data = typeof data === 'object' ? data : {};
    let result = new DynamicParameterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parameterName'] = this.parameterName;
    data['inputType'] = this.inputType;
    data['permission'] = this.permission;
    data['tenantId'] = this.tenantId;
    data['id'] = this.id;
    return data;
  }
}

export interface IDynamicParameterDto {
  parameterName: string | undefined;
  inputType: string | undefined;
  permission: string | undefined;
  tenantId: number | undefined;
  id: number;
}

export class ListResultDtoOfDynamicParameterDto implements IListResultDtoOfDynamicParameterDto {
  items!: DynamicParameterDto[] | undefined;

  constructor(data?: IListResultDtoOfDynamicParameterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DynamicParameterDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfDynamicParameterDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfDynamicParameterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfDynamicParameterDto {
  items: DynamicParameterDto[] | undefined;
}

export class IValueValidator implements IIValueValidator {
  readonly name!: string | undefined;
  readonly attributes!: { [key: string]: any } | undefined;

  constructor(data?: IIValueValidator) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data['name'];
      if (_data['attributes']) {
        (<any>this).attributes = {} as any;
        for (let key in _data['attributes']) {
          if (_data['attributes'].hasOwnProperty(key)) (<any>this).attributes![key] = _data['attributes'][key];
        }
      }
    }
  }

  static fromJS(data: any): IValueValidator {
    data = typeof data === 'object' ? data : {};
    let result = new IValueValidator();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (this.attributes) {
      data['attributes'] = {};
      for (let key in this.attributes) {
        if (this.attributes.hasOwnProperty(key)) data['attributes'][key] = this.attributes[key];
      }
    }
    return data;
  }
}

export interface IIValueValidator {
  name: string | undefined;
  attributes: { [key: string]: any } | undefined;
}

export class IInputType implements IIInputType {
  readonly name!: string | undefined;
  readonly attributes!: { [key: string]: any } | undefined;
  validator!: IValueValidator;

  constructor(data?: IIInputType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data['name'];
      if (_data['attributes']) {
        (<any>this).attributes = {} as any;
        for (let key in _data['attributes']) {
          if (_data['attributes'].hasOwnProperty(key)) (<any>this).attributes![key] = _data['attributes'][key];
        }
      }
      this.validator = _data['validator'] ? IValueValidator.fromJS(_data['validator']) : <any>undefined;
    }
  }

  static fromJS(data: any): IInputType {
    data = typeof data === 'object' ? data : {};
    let result = new IInputType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (this.attributes) {
      data['attributes'] = {};
      for (let key in this.attributes) {
        if (this.attributes.hasOwnProperty(key)) data['attributes'][key] = this.attributes[key];
      }
    }
    data['validator'] = this.validator ? this.validator.toJSON() : <any>undefined;
    return data;
  }
}

export interface IIInputType {
  name: string | undefined;
  attributes: { [key: string]: any } | undefined;
  validator: IValueValidator;
}

export class DynamicParameterValueDto implements IDynamicParameterValueDto {
  value!: string | undefined;
  tenantId!: number | undefined;
  dynamicParameterId!: number;
  id!: number;

  constructor(data?: IDynamicParameterValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.tenantId = _data['tenantId'];
      this.dynamicParameterId = _data['dynamicParameterId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DynamicParameterValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new DynamicParameterValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['tenantId'] = this.tenantId;
    data['dynamicParameterId'] = this.dynamicParameterId;
    data['id'] = this.id;
    return data;
  }
}

export interface IDynamicParameterValueDto {
  value: string | undefined;
  tenantId: number | undefined;
  dynamicParameterId: number;
  id: number;
}

export class ListResultDtoOfDynamicParameterValueDto implements IListResultDtoOfDynamicParameterValueDto {
  items!: DynamicParameterValueDto[] | undefined;

  constructor(data?: IListResultDtoOfDynamicParameterValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DynamicParameterValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfDynamicParameterValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfDynamicParameterValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfDynamicParameterValueDto {
  items: DynamicParameterValueDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
  name!: string | undefined;
  displayName!: string | undefined;
  dailyPrice!: number | undefined;
  weeklyPrice!: number | undefined;
  monthlyPrice!: number | undefined;
  annualPrice!: number | undefined;
  waitingDayAfterExpire!: number | undefined;
  trialDayCount!: number | undefined;
  expiringEditionDisplayName!: string | undefined;
  id!: number;

  constructor(data?: IEditionListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.dailyPrice = _data['dailyPrice'];
      this.weeklyPrice = _data['weeklyPrice'];
      this.monthlyPrice = _data['monthlyPrice'];
      this.annualPrice = _data['annualPrice'];
      this.waitingDayAfterExpire = _data['waitingDayAfterExpire'];
      this.trialDayCount = _data['trialDayCount'];
      this.expiringEditionDisplayName = _data['expiringEditionDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EditionListDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['dailyPrice'] = this.dailyPrice;
    data['weeklyPrice'] = this.weeklyPrice;
    data['monthlyPrice'] = this.monthlyPrice;
    data['annualPrice'] = this.annualPrice;
    data['waitingDayAfterExpire'] = this.waitingDayAfterExpire;
    data['trialDayCount'] = this.trialDayCount;
    data['expiringEditionDisplayName'] = this.expiringEditionDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IEditionListDto {
  name: string | undefined;
  displayName: string | undefined;
  dailyPrice: number | undefined;
  weeklyPrice: number | undefined;
  monthlyPrice: number | undefined;
  annualPrice: number | undefined;
  waitingDayAfterExpire: number | undefined;
  trialDayCount: number | undefined;
  expiringEditionDisplayName: string | undefined;
  id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
  items!: EditionListDto[] | undefined;

  constructor(data?: IListResultDtoOfEditionListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EditionListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfEditionListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfEditionListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfEditionListDto {
  items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
  id!: number | undefined;
  displayName!: string;
  expiringEditionId!: number | undefined;

  constructor(data?: IEditionEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.expiringEditionId = _data['expiringEditionId'];
    }
  }

  static fromJS(data: any): EditionEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['expiringEditionId'] = this.expiringEditionId;
    return data;
  }
}

export interface IEditionEditDto {
  id: number | undefined;
  displayName: string;
  expiringEditionId: number | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
  value!: string | undefined;
  displayText!: string | undefined;

  constructor(data?: ILocalizableComboboxItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.displayText = _data['displayText'];
    }
  }

  static fromJS(data: any): LocalizableComboboxItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizableComboboxItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['displayText'] = this.displayText;
    return data;
  }
}

export interface ILocalizableComboboxItemDto {
  value: string | undefined;
  displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
  items!: LocalizableComboboxItemDto[] | undefined;

  constructor(data?: ILocalizableComboboxItemSourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LocalizableComboboxItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): LocalizableComboboxItemSourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizableComboboxItemSourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface ILocalizableComboboxItemSourceDto {
  items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
  name!: string | undefined;
  attributes!: { [key: string]: any } | undefined;
  validator!: IValueValidator;
  itemSource!: LocalizableComboboxItemSourceDto;

  constructor(data?: IFeatureInputTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (_data['attributes']) {
        this.attributes = {} as any;
        for (let key in _data['attributes']) {
          if (_data['attributes'].hasOwnProperty(key)) this.attributes![key] = _data['attributes'][key];
        }
      }
      this.validator = _data['validator'] ? IValueValidator.fromJS(_data['validator']) : <any>undefined;
      this.itemSource = _data['itemSource'] ? LocalizableComboboxItemSourceDto.fromJS(_data['itemSource']) : <any>undefined;
    }
  }

  static fromJS(data: any): FeatureInputTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new FeatureInputTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (this.attributes) {
      data['attributes'] = {};
      for (let key in this.attributes) {
        if (this.attributes.hasOwnProperty(key)) data['attributes'][key] = this.attributes[key];
      }
    }
    data['validator'] = this.validator ? this.validator.toJSON() : <any>undefined;
    data['itemSource'] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
    return data;
  }
}

export interface IFeatureInputTypeDto {
  name: string | undefined;
  attributes: { [key: string]: any } | undefined;
  validator: IValueValidator;
  itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
  parentName!: string | undefined;
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;
  defaultValue!: string | undefined;
  inputType!: FeatureInputTypeDto;

  constructor(data?: IFlatFeatureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentName = _data['parentName'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.defaultValue = _data['defaultValue'];
      this.inputType = _data['inputType'] ? FeatureInputTypeDto.fromJS(_data['inputType']) : <any>undefined;
    }
  }

  static fromJS(data: any): FlatFeatureDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatFeatureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentName'] = this.parentName;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['defaultValue'] = this.defaultValue;
    data['inputType'] = this.inputType ? this.inputType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IFlatFeatureDto {
  parentName: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  defaultValue: string | undefined;
  inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
  edition!: EditionEditDto;
  featureValues!: NameValueDto[] | undefined;
  features!: FlatFeatureDto[] | undefined;

  constructor(data?: IGetEditionEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'] ? EditionEditDto.fromJS(_data['edition']) : <any>undefined;
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
      if (Array.isArray(_data['features'])) {
        this.features = [] as any;
        for (let item of _data['features']) this.features!.push(FlatFeatureDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEditionEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetEditionEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    if (Array.isArray(this.features)) {
      data['features'] = [];
      for (let item of this.features) data['features'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetEditionEditOutput {
  edition: EditionEditDto;
  featureValues: NameValueDto[] | undefined;
  features: FlatFeatureDto[] | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
  id!: number | undefined;
  displayName!: string;
  dailyPrice!: number | undefined;
  weeklyPrice!: number | undefined;
  monthlyPrice!: number | undefined;
  annualPrice!: number | undefined;
  trialDayCount!: number | undefined;
  waitingDayAfterExpire!: number | undefined;
  expiringEditionId!: number | undefined;

  constructor(data?: IEditionCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.dailyPrice = _data['dailyPrice'];
      this.weeklyPrice = _data['weeklyPrice'];
      this.monthlyPrice = _data['monthlyPrice'];
      this.annualPrice = _data['annualPrice'];
      this.trialDayCount = _data['trialDayCount'];
      this.waitingDayAfterExpire = _data['waitingDayAfterExpire'];
      this.expiringEditionId = _data['expiringEditionId'];
    }
  }

  static fromJS(data: any): EditionCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['dailyPrice'] = this.dailyPrice;
    data['weeklyPrice'] = this.weeklyPrice;
    data['monthlyPrice'] = this.monthlyPrice;
    data['annualPrice'] = this.annualPrice;
    data['trialDayCount'] = this.trialDayCount;
    data['waitingDayAfterExpire'] = this.waitingDayAfterExpire;
    data['expiringEditionId'] = this.expiringEditionId;
    return data;
  }
}

export interface IEditionCreateDto {
  id: number | undefined;
  displayName: string;
  dailyPrice: number | undefined;
  weeklyPrice: number | undefined;
  monthlyPrice: number | undefined;
  annualPrice: number | undefined;
  trialDayCount: number | undefined;
  waitingDayAfterExpire: number | undefined;
  expiringEditionId: number | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
  edition!: EditionCreateDto;
  featureValues!: NameValueDto[];

  constructor(data?: ICreateEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.edition = new EditionCreateDto();
      this.featureValues = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'] ? EditionCreateDto.fromJS(_data['edition']) : new EditionCreateDto();
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateEditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateEditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateEditionDto {
  edition: EditionCreateDto;
  featureValues: NameValueDto[];
}

export class UpdateEditionDto implements IUpdateEditionDto {
  edition!: EditionEditDto;
  featureValues!: NameValueDto[];

  constructor(data?: IUpdateEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.edition = new EditionEditDto();
      this.featureValues = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'] ? EditionEditDto.fromJS(_data['edition']) : new EditionEditDto();
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdateEditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateEditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateEditionDto {
  edition: EditionEditDto;
  featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
  sourceEditionId!: number;
  targetEditionId!: number;

  constructor(data?: IMoveTenantsToAnotherEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sourceEditionId = _data['sourceEditionId'];
      this.targetEditionId = _data['targetEditionId'];
    }
  }

  static fromJS(data: any): MoveTenantsToAnotherEditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new MoveTenantsToAnotherEditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sourceEditionId'] = this.sourceEditionId;
    data['targetEditionId'] = this.targetEditionId;
    return data;
  }
}

export interface IMoveTenantsToAnotherEditionDto {
  sourceEditionId: number;
  targetEditionId: number;
}

export class EntityDynamicParameterDto implements IEntityDynamicParameterDto {
  entityFullName!: string | undefined;
  dynamicParameterName!: string | undefined;
  dynamicParameterId!: number;
  tenantId!: number | undefined;
  id!: number;

  constructor(data?: IEntityDynamicParameterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityFullName = _data['entityFullName'];
      this.dynamicParameterName = _data['dynamicParameterName'];
      this.dynamicParameterId = _data['dynamicParameterId'];
      this.tenantId = _data['tenantId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDynamicParameterDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDynamicParameterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['entityFullName'] = this.entityFullName;
    data['dynamicParameterName'] = this.dynamicParameterName;
    data['dynamicParameterId'] = this.dynamicParameterId;
    data['tenantId'] = this.tenantId;
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDynamicParameterDto {
  entityFullName: string | undefined;
  dynamicParameterName: string | undefined;
  dynamicParameterId: number;
  tenantId: number | undefined;
  id: number;
}

export class ListResultDtoOfEntityDynamicParameterDto implements IListResultDtoOfEntityDynamicParameterDto {
  items!: EntityDynamicParameterDto[] | undefined;

  constructor(data?: IListResultDtoOfEntityDynamicParameterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EntityDynamicParameterDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfEntityDynamicParameterDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfEntityDynamicParameterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfEntityDynamicParameterDto {
  items: EntityDynamicParameterDto[] | undefined;
}

export class EntityDynamicParameterValueDto implements IEntityDynamicParameterValueDto {
  value!: string | undefined;
  entityId!: string | undefined;
  entityDynamicParameterId!: number;
  id!: number;

  constructor(data?: IEntityDynamicParameterValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.entityId = _data['entityId'];
      this.entityDynamicParameterId = _data['entityDynamicParameterId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDynamicParameterValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDynamicParameterValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['entityId'] = this.entityId;
    data['entityDynamicParameterId'] = this.entityDynamicParameterId;
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDynamicParameterValueDto {
  value: string | undefined;
  entityId: string | undefined;
  entityDynamicParameterId: number;
  id: number;
}

export class ListResultDtoOfEntityDynamicParameterValueDto implements IListResultDtoOfEntityDynamicParameterValueDto {
  items!: EntityDynamicParameterValueDto[] | undefined;

  constructor(data?: IListResultDtoOfEntityDynamicParameterValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(EntityDynamicParameterValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfEntityDynamicParameterValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfEntityDynamicParameterValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfEntityDynamicParameterValueDto {
  items: EntityDynamicParameterValueDto[] | undefined;
}

export class GetAllEntityDynamicParameterValuesOutputItem implements IGetAllEntityDynamicParameterValuesOutputItem {
  entityDynamicParameterId!: number;
  parameterName!: string | undefined;
  inputType!: IInputType;
  selectedValues!: string[] | undefined;
  allValuesInputTypeHas!: string[] | undefined;

  constructor(data?: IGetAllEntityDynamicParameterValuesOutputItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityDynamicParameterId = _data['entityDynamicParameterId'];
      this.parameterName = _data['parameterName'];
      this.inputType = _data['inputType'] ? IInputType.fromJS(_data['inputType']) : <any>undefined;
      if (Array.isArray(_data['selectedValues'])) {
        this.selectedValues = [] as any;
        for (let item of _data['selectedValues']) this.selectedValues!.push(item);
      }
      if (Array.isArray(_data['allValuesInputTypeHas'])) {
        this.allValuesInputTypeHas = [] as any;
        for (let item of _data['allValuesInputTypeHas']) this.allValuesInputTypeHas!.push(item);
      }
    }
  }

  static fromJS(data: any): GetAllEntityDynamicParameterValuesOutputItem {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllEntityDynamicParameterValuesOutputItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['entityDynamicParameterId'] = this.entityDynamicParameterId;
    data['parameterName'] = this.parameterName;
    data['inputType'] = this.inputType ? this.inputType.toJSON() : <any>undefined;
    if (Array.isArray(this.selectedValues)) {
      data['selectedValues'] = [];
      for (let item of this.selectedValues) data['selectedValues'].push(item);
    }
    if (Array.isArray(this.allValuesInputTypeHas)) {
      data['allValuesInputTypeHas'] = [];
      for (let item of this.allValuesInputTypeHas) data['allValuesInputTypeHas'].push(item);
    }
    return data;
  }
}

export interface IGetAllEntityDynamicParameterValuesOutputItem {
  entityDynamicParameterId: number;
  parameterName: string | undefined;
  inputType: IInputType;
  selectedValues: string[] | undefined;
  allValuesInputTypeHas: string[] | undefined;
}

export class GetAllEntityDynamicParameterValuesOutput implements IGetAllEntityDynamicParameterValuesOutput {
  items!: GetAllEntityDynamicParameterValuesOutputItem[] | undefined;

  constructor(data?: IGetAllEntityDynamicParameterValuesOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetAllEntityDynamicParameterValuesOutputItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetAllEntityDynamicParameterValuesOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllEntityDynamicParameterValuesOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetAllEntityDynamicParameterValuesOutput {
  items: GetAllEntityDynamicParameterValuesOutputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
  entityId!: string | undefined;
  entityDynamicParameterId!: number;
  values!: string[] | undefined;

  constructor(data?: IInsertOrUpdateAllValuesInputItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityId = _data['entityId'];
      this.entityDynamicParameterId = _data['entityDynamicParameterId'];
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(item);
      }
    }
  }

  static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
    data = typeof data === 'object' ? data : {};
    let result = new InsertOrUpdateAllValuesInputItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['entityId'] = this.entityId;
    data['entityDynamicParameterId'] = this.entityDynamicParameterId;
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item);
    }
    return data;
  }
}

export interface IInsertOrUpdateAllValuesInputItem {
  entityId: string | undefined;
  entityDynamicParameterId: number;
  values: string[] | undefined;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
  items!: InsertOrUpdateAllValuesInputItem[] | undefined;

  constructor(data?: IInsertOrUpdateAllValuesInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): InsertOrUpdateAllValuesInput {
    data = typeof data === 'object' ? data : {};
    let result = new InsertOrUpdateAllValuesInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IInsertOrUpdateAllValuesInput {
  items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class CleanValuesInput implements ICleanValuesInput {
  entityDynamicParameterId!: number;
  entityId!: string | undefined;

  constructor(data?: ICleanValuesInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityDynamicParameterId = _data['entityDynamicParameterId'];
      this.entityId = _data['entityId'];
    }
  }

  static fromJS(data: any): CleanValuesInput {
    data = typeof data === 'object' ? data : {};
    let result = new CleanValuesInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['entityDynamicParameterId'] = this.entityDynamicParameterId;
    data['entityId'] = this.entityId;
    return data;
  }
}

export interface ICleanValuesInput {
  entityDynamicParameterId: number;
  entityId: string | undefined;
}

export class FacilityDto implements IFacilityDto {
  name!: string | undefined;
  address!: string | undefined;
  longitude!: number;
  latitude!: number;
  cityId!: number;
  id!: number;

  constructor(data?: IFacilityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.address = _data['address'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.cityId = _data['cityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): FacilityDto {
    data = typeof data === 'object' ? data : {};
    let result = new FacilityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['address'] = this.address;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['cityId'] = this.cityId;
    data['id'] = this.id;
    return data;
  }
}

export interface IFacilityDto {
  name: string | undefined;
  address: string | undefined;
  longitude: number;
  latitude: number;
  cityId: number;
  id: number;
}

export class GetFacilityForViewOutput implements IGetFacilityForViewOutput {
  facility!: FacilityDto;
  cityDisplayName!: string | undefined;
  country!: string | undefined;
  facilityName!: string | undefined;
  longitude!: number | undefined;
  latitude!: number | undefined;
  creationTime!: moment.Moment;

  constructor(data?: IGetFacilityForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.facility = _data['facility'] ? FacilityDto.fromJS(_data['facility']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
      this.country = _data['country'];
      this.facilityName = _data['facilityName'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetFacilityForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetFacilityForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['facility'] = this.facility ? this.facility.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    data['country'] = this.country;
    data['facilityName'] = this.facilityName;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetFacilityForViewOutput {
  facility: FacilityDto;
  cityDisplayName: string | undefined;
  country: string | undefined;
  facilityName: string | undefined;
  longitude: number | undefined;
  latitude: number | undefined;
  creationTime: moment.Moment;
}

export class PagedResultDtoOfGetFacilityForViewOutput implements IPagedResultDtoOfGetFacilityForViewOutput {
  totalCount!: number;
  items!: GetFacilityForViewOutput[] | undefined;

  constructor(data?: IPagedResultDtoOfGetFacilityForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetFacilityForViewOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetFacilityForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetFacilityForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetFacilityForViewOutput {
  totalCount: number;
  items: GetFacilityForViewOutput[] | undefined;
}

export class CreateOrEditFacilityDto implements ICreateOrEditFacilityDto {
  name!: string;
  address!: string;
  longitude!: number;
  latitude!: number;
  cityId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditFacilityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.address = _data['address'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.cityId = _data['cityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditFacilityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditFacilityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['address'] = this.address;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['cityId'] = this.cityId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditFacilityDto {
  name: string;
  address: string;
  longitude: number;
  latitude: number;
  cityId: number;
  id: number | undefined;
}

export class GetFacilityForEditOutput implements IGetFacilityForEditOutput {
  facility!: CreateOrEditFacilityDto;
  cityDisplayName!: string | undefined;

  constructor(data?: IGetFacilityForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.facility = _data['facility'] ? CreateOrEditFacilityDto.fromJS(_data['facility']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
    }
  }

  static fromJS(data: any): GetFacilityForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetFacilityForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['facility'] = this.facility ? this.facility.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    return data;
  }
}

export interface IGetFacilityForEditOutput {
  facility: CreateOrEditFacilityDto;
  cityDisplayName: string | undefined;
}

export class FacilityCityLookupTableDto implements IFacilityCityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IFacilityCityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): FacilityCityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new FacilityCityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IFacilityCityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
  userId!: number;
  tenantId!: number | undefined;

  constructor(data?: ICreateFriendshipRequestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): CreateFriendshipRequestInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateFriendshipRequestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    return data;
  }
}

export interface ICreateFriendshipRequestInput {
  userId: number;
  tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
  tenancyName!: string;
  userName!: string | undefined;

  constructor(data?: ICreateFriendshipRequestByUserNameInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.userName = _data['userName'];
    }
  }

  static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateFriendshipRequestByUserNameInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['userName'] = this.userName;
    return data;
  }
}

export interface ICreateFriendshipRequestByUserNameInput {
  tenancyName: string;
  userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
  userId!: number;
  tenantId!: number | undefined;

  constructor(data?: IBlockUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): BlockUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new BlockUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    return data;
  }
}

export interface IBlockUserInput {
  userId: number;
  tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
  userId!: number;
  tenantId!: number | undefined;

  constructor(data?: IUnblockUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): UnblockUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new UnblockUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    return data;
  }
}

export interface IUnblockUserInput {
  userId: number;
  tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
  userId!: number;
  tenantId!: number | undefined;

  constructor(data?: IAcceptFriendshipRequestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): AcceptFriendshipRequestInput {
    data = typeof data === 'object' ? data : {};
    let result = new AcceptFriendshipRequestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['tenantId'] = this.tenantId;
    return data;
  }
}

export interface IAcceptFriendshipRequestInput {
  userId: number;
  tenantId: number | undefined;
}

export class GoodCategoryDto implements IGoodCategoryDto {
  displayName!: string | undefined;
  fatherId!: number | undefined;
  id!: number;

  constructor(data?: IGoodCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.fatherId = _data['fatherId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GoodCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new GoodCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['fatherId'] = this.fatherId;
    data['id'] = this.id;
    return data;
  }
}

export interface IGoodCategoryDto {
  displayName: string | undefined;
  fatherId: number | undefined;
  id: number;
}

export class GetGoodCategoryForViewDto implements IGetGoodCategoryForViewDto {
  goodCategory!: GoodCategoryDto;
  fatherCategoryName!: string | undefined;

  constructor(data?: IGetGoodCategoryForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.goodCategory = _data['goodCategory'] ? GoodCategoryDto.fromJS(_data['goodCategory']) : <any>undefined;
      this.fatherCategoryName = _data['fatherCategoryName'];
    }
  }

  static fromJS(data: any): GetGoodCategoryForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetGoodCategoryForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['goodCategory'] = this.goodCategory ? this.goodCategory.toJSON() : <any>undefined;
    data['fatherCategoryName'] = this.fatherCategoryName;
    return data;
  }
}

export interface IGetGoodCategoryForViewDto {
  goodCategory: GoodCategoryDto;
  fatherCategoryName: string | undefined;
}

export class PagedResultDtoOfGetGoodCategoryForViewDto implements IPagedResultDtoOfGetGoodCategoryForViewDto {
  totalCount!: number;
  items!: GetGoodCategoryForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetGoodCategoryForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetGoodCategoryForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetGoodCategoryForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetGoodCategoryForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetGoodCategoryForViewDto {
  totalCount: number;
  items: GetGoodCategoryForViewDto[] | undefined;
}

export class GoodCategoryTranslationDto implements IGoodCategoryTranslationDto {
  displayName!: string | undefined;
  language!: string | undefined;
  languageDisplayName!: string | undefined;
  icon!: string | undefined;
  id!: number | undefined;

  constructor(data?: IGoodCategoryTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.language = _data['language'];
      this.languageDisplayName = _data['languageDisplayName'];
      this.icon = _data['icon'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GoodCategoryTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new GoodCategoryTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['language'] = this.language;
    data['languageDisplayName'] = this.languageDisplayName;
    data['icon'] = this.icon;
    data['id'] = this.id;
    return data;
  }
}

export interface IGoodCategoryTranslationDto {
  displayName: string | undefined;
  language: string | undefined;
  languageDisplayName: string | undefined;
  icon: string | undefined;
  id: number | undefined;
}

export class CreateOrEditGoodCategoryDto implements ICreateOrEditGoodCategoryDto {
  fatherId!: number | undefined;
  translations!: GoodCategoryTranslationDto[] | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditGoodCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fatherId = _data['fatherId'];
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(GoodCategoryTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditGoodCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditGoodCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fatherId'] = this.fatherId;
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditGoodCategoryDto {
  fatherId: number | undefined;
  translations: GoodCategoryTranslationDto[] | undefined;
  id: number | undefined;
}

export class GetGoodCategoryForEditOutput implements IGetGoodCategoryForEditOutput {
  goodCategory!: CreateOrEditGoodCategoryDto;

  constructor(data?: IGetGoodCategoryForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.goodCategory = _data['goodCategory'] ? CreateOrEditGoodCategoryDto.fromJS(_data['goodCategory']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetGoodCategoryForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetGoodCategoryForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['goodCategory'] = this.goodCategory ? this.goodCategory.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetGoodCategoryForEditOutput {
  goodCategory: CreateOrEditGoodCategoryDto;
}

export class GetAllGoodsCategoriesForDropDownOutput implements IGetAllGoodsCategoriesForDropDownOutput {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IGetAllGoodsCategoriesForDropDownOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GetAllGoodsCategoriesForDropDownOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllGoodsCategoriesForDropDownOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IGetAllGoodsCategoriesForDropDownOutput {
  displayName: string | undefined;
  id: number;
}

export class GoodsDetailDto implements IGoodsDetailDto {
  description!: string | undefined;
  amount!: number;
  weight!: number;
  dimentions!: string | undefined;
  isDangerousGood!: boolean;
  dangerousGoodsCode!: string | undefined;
  goodCategoryId!: number | undefined;
  goodCategory!: string | undefined;
  routPointId!: number;
  unitOfMeasureId!: number;
  unitOfMeasure!: string | undefined;
  id!: number;

  constructor(data?: IGoodsDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.amount = _data['amount'];
      this.weight = _data['weight'];
      this.dimentions = _data['dimentions'];
      this.isDangerousGood = _data['isDangerousGood'];
      this.dangerousGoodsCode = _data['dangerousGoodsCode'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.goodCategory = _data['goodCategory'];
      this.routPointId = _data['routPointId'];
      this.unitOfMeasureId = _data['unitOfMeasureId'];
      this.unitOfMeasure = _data['unitOfMeasure'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GoodsDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new GoodsDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['amount'] = this.amount;
    data['weight'] = this.weight;
    data['dimentions'] = this.dimentions;
    data['isDangerousGood'] = this.isDangerousGood;
    data['dangerousGoodsCode'] = this.dangerousGoodsCode;
    data['goodCategoryId'] = this.goodCategoryId;
    data['goodCategory'] = this.goodCategory;
    data['routPointId'] = this.routPointId;
    data['unitOfMeasureId'] = this.unitOfMeasureId;
    data['unitOfMeasure'] = this.unitOfMeasure;
    data['id'] = this.id;
    return data;
  }
}

export interface IGoodsDetailDto {
  description: string | undefined;
  amount: number;
  weight: number;
  dimentions: string | undefined;
  isDangerousGood: boolean;
  dangerousGoodsCode: string | undefined;
  goodCategoryId: number | undefined;
  goodCategory: string | undefined;
  routPointId: number;
  unitOfMeasureId: number;
  unitOfMeasure: string | undefined;
  id: number;
}

export class GetGoodsDetailForViewDto implements IGetGoodsDetailForViewDto {
  goodsDetail!: GoodsDetailDto;
  routPointDisplayName!: string | undefined;
  goodCategoryDisplayName!: string | undefined;
  unitOfMeasureDisplayName!: string | undefined;

  constructor(data?: IGetGoodsDetailForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.goodsDetail = _data['goodsDetail'] ? GoodsDetailDto.fromJS(_data['goodsDetail']) : <any>undefined;
      this.routPointDisplayName = _data['routPointDisplayName'];
      this.goodCategoryDisplayName = _data['goodCategoryDisplayName'];
      this.unitOfMeasureDisplayName = _data['unitOfMeasureDisplayName'];
    }
  }

  static fromJS(data: any): GetGoodsDetailForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetGoodsDetailForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['goodsDetail'] = this.goodsDetail ? this.goodsDetail.toJSON() : <any>undefined;
    data['routPointDisplayName'] = this.routPointDisplayName;
    data['goodCategoryDisplayName'] = this.goodCategoryDisplayName;
    data['unitOfMeasureDisplayName'] = this.unitOfMeasureDisplayName;
    return data;
  }
}

export interface IGetGoodsDetailForViewDto {
  goodsDetail: GoodsDetailDto;
  routPointDisplayName: string | undefined;
  goodCategoryDisplayName: string | undefined;
  unitOfMeasureDisplayName: string | undefined;
}

export class PagedResultDtoOfGetGoodsDetailForViewDto implements IPagedResultDtoOfGetGoodsDetailForViewDto {
  totalCount!: number;
  items!: GetGoodsDetailForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetGoodsDetailForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetGoodsDetailForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetGoodsDetailForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetGoodsDetailForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetGoodsDetailForViewDto {
  totalCount: number;
  items: GetGoodsDetailForViewDto[] | undefined;
}

export class CreateOrEditGoodsDetailDto implements ICreateOrEditGoodsDetailDto {
  description!: string | undefined;
  amount!: number;
  weight!: number;
  dimentions!: string | undefined;
  isDangerousGood!: boolean;
  dangerousGoodsCode!: string | undefined;
  goodCategoryId!: number | undefined;
  unitOfMeasureId!: number;
  routPointId!: number | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditGoodsDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.amount = _data['amount'];
      this.weight = _data['weight'];
      this.dimentions = _data['dimentions'];
      this.isDangerousGood = _data['isDangerousGood'];
      this.dangerousGoodsCode = _data['dangerousGoodsCode'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.unitOfMeasureId = _data['unitOfMeasureId'];
      this.routPointId = _data['routPointId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditGoodsDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditGoodsDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['amount'] = this.amount;
    data['weight'] = this.weight;
    data['dimentions'] = this.dimentions;
    data['isDangerousGood'] = this.isDangerousGood;
    data['dangerousGoodsCode'] = this.dangerousGoodsCode;
    data['goodCategoryId'] = this.goodCategoryId;
    data['unitOfMeasureId'] = this.unitOfMeasureId;
    data['routPointId'] = this.routPointId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditGoodsDetailDto {
  description: string | undefined;
  amount: number;
  weight: number;
  dimentions: string | undefined;
  isDangerousGood: boolean;
  dangerousGoodsCode: string | undefined;
  goodCategoryId: number | undefined;
  unitOfMeasureId: number;
  routPointId: number | undefined;
  id: number | undefined;
}

export class GetGoodsDetailForEditOutput implements IGetGoodsDetailForEditOutput {
  goodsDetail!: CreateOrEditGoodsDetailDto;
  goodCategoryDisplayName!: string | undefined;

  constructor(data?: IGetGoodsDetailForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.goodsDetail = _data['goodsDetail'] ? CreateOrEditGoodsDetailDto.fromJS(_data['goodsDetail']) : <any>undefined;
      this.goodCategoryDisplayName = _data['goodCategoryDisplayName'];
    }
  }

  static fromJS(data: any): GetGoodsDetailForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetGoodsDetailForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['goodsDetail'] = this.goodsDetail ? this.goodsDetail.toJSON() : <any>undefined;
    data['goodCategoryDisplayName'] = this.goodCategoryDisplayName;
    return data;
  }
}

export interface IGetGoodsDetailForEditOutput {
  goodsDetail: CreateOrEditGoodsDetailDto;
  goodCategoryDisplayName: string | undefined;
}

export class GetGoodsDetailsForWaybillsOutput implements IGetGoodsDetailsForWaybillsOutput {
  description!: string | undefined;
  totalAmount!: number;
  unitOfMeasureDisplayName!: string | undefined;

  constructor(data?: IGetGoodsDetailsForWaybillsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.totalAmount = _data['totalAmount'];
      this.unitOfMeasureDisplayName = _data['unitOfMeasureDisplayName'];
    }
  }

  static fromJS(data: any): GetGoodsDetailsForWaybillsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetGoodsDetailsForWaybillsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['totalAmount'] = this.totalAmount;
    data['unitOfMeasureDisplayName'] = this.unitOfMeasureDisplayName;
    return data;
  }
}

export interface IGetGoodsDetailsForWaybillsOutput {
  description: string | undefined;
  totalAmount: number;
  unitOfMeasureDisplayName: string | undefined;
}

export class TopStatsData implements ITopStatsData {
  newTenantsCount!: number;
  newSubscriptionAmount!: number;
  dashboardPlaceholder1!: number;
  dashboardPlaceholder2!: number;

  constructor(data?: ITopStatsData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.newTenantsCount = _data['newTenantsCount'];
      this.newSubscriptionAmount = _data['newSubscriptionAmount'];
      this.dashboardPlaceholder1 = _data['dashboardPlaceholder1'];
      this.dashboardPlaceholder2 = _data['dashboardPlaceholder2'];
    }
  }

  static fromJS(data: any): TopStatsData {
    data = typeof data === 'object' ? data : {};
    let result = new TopStatsData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['newTenantsCount'] = this.newTenantsCount;
    data['newSubscriptionAmount'] = this.newSubscriptionAmount;
    data['dashboardPlaceholder1'] = this.dashboardPlaceholder1;
    data['dashboardPlaceholder2'] = this.dashboardPlaceholder2;
    return data;
  }
}

export interface ITopStatsData {
  newTenantsCount: number;
  newSubscriptionAmount: number;
  dashboardPlaceholder1: number;
  dashboardPlaceholder2: number;
}

export class RecentTenant implements IRecentTenant {
  id!: number;
  name!: string | undefined;
  creationTime!: moment.Moment;

  constructor(data?: IRecentTenant) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): RecentTenant {
    data = typeof data === 'object' ? data : {};
    let result = new RecentTenant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IRecentTenant {
  id: number;
  name: string | undefined;
  creationTime: moment.Moment;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
  recentTenantsDayCount!: number;
  maxRecentTenantsShownCount!: number;
  tenantCreationStartDate!: moment.Moment;
  recentTenants!: RecentTenant[] | undefined;

  constructor(data?: IGetRecentTenantsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.recentTenantsDayCount = _data['recentTenantsDayCount'];
      this.maxRecentTenantsShownCount = _data['maxRecentTenantsShownCount'];
      this.tenantCreationStartDate = _data['tenantCreationStartDate'] ? moment(_data['tenantCreationStartDate'].toString()) : <any>undefined;
      if (Array.isArray(_data['recentTenants'])) {
        this.recentTenants = [] as any;
        for (let item of _data['recentTenants']) this.recentTenants!.push(RecentTenant.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetRecentTenantsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRecentTenantsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['recentTenantsDayCount'] = this.recentTenantsDayCount;
    data['maxRecentTenantsShownCount'] = this.maxRecentTenantsShownCount;
    data['tenantCreationStartDate'] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
    if (Array.isArray(this.recentTenants)) {
      data['recentTenants'] = [];
      for (let item of this.recentTenants) data['recentTenants'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetRecentTenantsOutput {
  recentTenantsDayCount: number;
  maxRecentTenantsShownCount: number;
  tenantCreationStartDate: moment.Moment;
  recentTenants: RecentTenant[] | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
  tenantName!: string | undefined;
  remainingDayCount!: number;

  constructor(data?: IExpiringTenant) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantName = _data['tenantName'];
      this.remainingDayCount = _data['remainingDayCount'];
    }
  }

  static fromJS(data: any): ExpiringTenant {
    data = typeof data === 'object' ? data : {};
    let result = new ExpiringTenant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantName'] = this.tenantName;
    data['remainingDayCount'] = this.remainingDayCount;
    return data;
  }
}

export interface IExpiringTenant {
  tenantName: string | undefined;
  remainingDayCount: number;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
  expiringTenants!: ExpiringTenant[] | undefined;
  subscriptionEndAlertDayCount!: number;
  maxExpiringTenantsShownCount!: number;
  subscriptionEndDateStart!: moment.Moment;
  subscriptionEndDateEnd!: moment.Moment;

  constructor(data?: IGetExpiringTenantsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['expiringTenants'])) {
        this.expiringTenants = [] as any;
        for (let item of _data['expiringTenants']) this.expiringTenants!.push(ExpiringTenant.fromJS(item));
      }
      this.subscriptionEndAlertDayCount = _data['subscriptionEndAlertDayCount'];
      this.maxExpiringTenantsShownCount = _data['maxExpiringTenantsShownCount'];
      this.subscriptionEndDateStart = _data['subscriptionEndDateStart'] ? moment(_data['subscriptionEndDateStart'].toString()) : <any>undefined;
      this.subscriptionEndDateEnd = _data['subscriptionEndDateEnd'] ? moment(_data['subscriptionEndDateEnd'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetExpiringTenantsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetExpiringTenantsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.expiringTenants)) {
      data['expiringTenants'] = [];
      for (let item of this.expiringTenants) data['expiringTenants'].push(item.toJSON());
    }
    data['subscriptionEndAlertDayCount'] = this.subscriptionEndAlertDayCount;
    data['maxExpiringTenantsShownCount'] = this.maxExpiringTenantsShownCount;
    data['subscriptionEndDateStart'] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
    data['subscriptionEndDateEnd'] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetExpiringTenantsOutput {
  expiringTenants: ExpiringTenant[] | undefined;
  subscriptionEndAlertDayCount: number;
  maxExpiringTenantsShownCount: number;
  subscriptionEndDateStart: moment.Moment;
  subscriptionEndDateEnd: moment.Moment;
}

export enum ChartDateInterval {
  Daily = 1,
  Weekly = 2,
  Monthly = 3,
}

export class IncomeStastistic implements IIncomeStastistic {
  label!: string | undefined;
  date!: moment.Moment;
  amount!: number;

  constructor(data?: IIncomeStastistic) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.label = _data['label'];
      this.date = _data['date'] ? moment(_data['date'].toString()) : <any>undefined;
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): IncomeStastistic {
    data = typeof data === 'object' ? data : {};
    let result = new IncomeStastistic();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['label'] = this.label;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['amount'] = this.amount;
    return data;
  }
}

export interface IIncomeStastistic {
  label: string | undefined;
  date: moment.Moment;
  amount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
  incomeStatistics!: IncomeStastistic[] | undefined;

  constructor(data?: IGetIncomeStatisticsDataOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['incomeStatistics'])) {
        this.incomeStatistics = [] as any;
        for (let item of _data['incomeStatistics']) this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetIncomeStatisticsDataOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetIncomeStatisticsDataOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.incomeStatistics)) {
      data['incomeStatistics'] = [];
      for (let item of this.incomeStatistics) data['incomeStatistics'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetIncomeStatisticsDataOutput {
  incomeStatistics: IncomeStastistic[] | undefined;
}

export class TenantEdition implements ITenantEdition {
  label!: string | undefined;
  value!: number;

  constructor(data?: ITenantEdition) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.label = _data['label'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): TenantEdition {
    data = typeof data === 'object' ? data : {};
    let result = new TenantEdition();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['label'] = this.label;
    data['value'] = this.value;
    return data;
  }
}

export interface ITenantEdition {
  label: string | undefined;
  value: number;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
  editionStatistics!: TenantEdition[] | undefined;

  constructor(data?: IGetEditionTenantStatisticsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['editionStatistics'])) {
        this.editionStatistics = [] as any;
        for (let item of _data['editionStatistics']) this.editionStatistics!.push(TenantEdition.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEditionTenantStatisticsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetEditionTenantStatisticsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.editionStatistics)) {
      data['editionStatistics'] = [];
      for (let item of this.editionStatistics) data['editionStatistics'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetEditionTenantStatisticsOutput {
  editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
  timezone!: string | undefined;
  timezoneForComparison!: string | undefined;

  constructor(data?: IGeneralSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timezone = _data['timezone'];
      this.timezoneForComparison = _data['timezoneForComparison'];
    }
  }

  static fromJS(data: any): GeneralSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new GeneralSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timezone'] = this.timezone;
    data['timezoneForComparison'] = this.timezoneForComparison;
    return data;
  }
}

export interface IGeneralSettingsEditDto {
  timezone: string | undefined;
  timezoneForComparison: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
  isEnabled!: boolean;
  timeOutSecond!: number;
  showTimeOutNotificationSecond!: number;
  showLockScreenWhenTimedOut!: boolean;

  constructor(data?: ISessionTimeOutSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isEnabled = _data['isEnabled'];
      this.timeOutSecond = _data['timeOutSecond'];
      this.showTimeOutNotificationSecond = _data['showTimeOutNotificationSecond'];
      this.showLockScreenWhenTimedOut = _data['showLockScreenWhenTimedOut'];
    }
  }

  static fromJS(data: any): SessionTimeOutSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new SessionTimeOutSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isEnabled'] = this.isEnabled;
    data['timeOutSecond'] = this.timeOutSecond;
    data['showTimeOutNotificationSecond'] = this.showTimeOutNotificationSecond;
    data['showLockScreenWhenTimedOut'] = this.showLockScreenWhenTimedOut;
    return data;
  }
}

export interface ISessionTimeOutSettingsEditDto {
  isEnabled: boolean;
  timeOutSecond: number;
  showTimeOutNotificationSecond: number;
  showLockScreenWhenTimedOut: boolean;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
  isEmailConfirmationRequiredForLogin!: boolean;
  smsVerificationEnabled!: boolean;
  isCookieConsentEnabled!: boolean;
  isQuickThemeSelectEnabled!: boolean;
  useCaptchaOnLogin!: boolean;
  allowUsingGravatarProfilePicture!: boolean;
  sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

  constructor(data?: IHostUserManagementSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isEmailConfirmationRequiredForLogin = _data['isEmailConfirmationRequiredForLogin'];
      this.smsVerificationEnabled = _data['smsVerificationEnabled'];
      this.isCookieConsentEnabled = _data['isCookieConsentEnabled'];
      this.isQuickThemeSelectEnabled = _data['isQuickThemeSelectEnabled'];
      this.useCaptchaOnLogin = _data['useCaptchaOnLogin'];
      this.allowUsingGravatarProfilePicture = _data['allowUsingGravatarProfilePicture'];
      this.sessionTimeOutSettings = _data['sessionTimeOutSettings']
        ? SessionTimeOutSettingsEditDto.fromJS(_data['sessionTimeOutSettings'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): HostUserManagementSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new HostUserManagementSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isEmailConfirmationRequiredForLogin'] = this.isEmailConfirmationRequiredForLogin;
    data['smsVerificationEnabled'] = this.smsVerificationEnabled;
    data['isCookieConsentEnabled'] = this.isCookieConsentEnabled;
    data['isQuickThemeSelectEnabled'] = this.isQuickThemeSelectEnabled;
    data['useCaptchaOnLogin'] = this.useCaptchaOnLogin;
    data['allowUsingGravatarProfilePicture'] = this.allowUsingGravatarProfilePicture;
    data['sessionTimeOutSettings'] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
    return data;
  }
}

export interface IHostUserManagementSettingsEditDto {
  isEmailConfirmationRequiredForLogin: boolean;
  smsVerificationEnabled: boolean;
  isCookieConsentEnabled: boolean;
  isQuickThemeSelectEnabled: boolean;
  useCaptchaOnLogin: boolean;
  allowUsingGravatarProfilePicture: boolean;
  sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
  defaultFromAddress!: string | undefined;
  defaultFromDisplayName!: string | undefined;
  smtpHost!: string | undefined;
  smtpPort!: number;
  smtpUserName!: string | undefined;
  smtpPassword!: string | undefined;
  smtpDomain!: string | undefined;
  smtpEnableSsl!: boolean;
  smtpUseDefaultCredentials!: boolean;

  constructor(data?: IEmailSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.defaultFromAddress = _data['defaultFromAddress'];
      this.defaultFromDisplayName = _data['defaultFromDisplayName'];
      this.smtpHost = _data['smtpHost'];
      this.smtpPort = _data['smtpPort'];
      this.smtpUserName = _data['smtpUserName'];
      this.smtpPassword = _data['smtpPassword'];
      this.smtpDomain = _data['smtpDomain'];
      this.smtpEnableSsl = _data['smtpEnableSsl'];
      this.smtpUseDefaultCredentials = _data['smtpUseDefaultCredentials'];
    }
  }

  static fromJS(data: any): EmailSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new EmailSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['defaultFromAddress'] = this.defaultFromAddress;
    data['defaultFromDisplayName'] = this.defaultFromDisplayName;
    data['smtpHost'] = this.smtpHost;
    data['smtpPort'] = this.smtpPort;
    data['smtpUserName'] = this.smtpUserName;
    data['smtpPassword'] = this.smtpPassword;
    data['smtpDomain'] = this.smtpDomain;
    data['smtpEnableSsl'] = this.smtpEnableSsl;
    data['smtpUseDefaultCredentials'] = this.smtpUseDefaultCredentials;
    return data;
  }
}

export interface IEmailSettingsEditDto {
  defaultFromAddress: string | undefined;
  defaultFromDisplayName: string | undefined;
  smtpHost: string | undefined;
  smtpPort: number;
  smtpUserName: string | undefined;
  smtpPassword: string | undefined;
  smtpDomain: string | undefined;
  smtpEnableSsl: boolean;
  smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
  allowSelfRegistration!: boolean;
  isNewRegisteredTenantActiveByDefault!: boolean;
  useCaptchaOnRegistration!: boolean;
  defaultEditionId!: number | undefined;

  constructor(data?: ITenantManagementSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.allowSelfRegistration = _data['allowSelfRegistration'];
      this.isNewRegisteredTenantActiveByDefault = _data['isNewRegisteredTenantActiveByDefault'];
      this.useCaptchaOnRegistration = _data['useCaptchaOnRegistration'];
      this.defaultEditionId = _data['defaultEditionId'];
    }
  }

  static fromJS(data: any): TenantManagementSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantManagementSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['allowSelfRegistration'] = this.allowSelfRegistration;
    data['isNewRegisteredTenantActiveByDefault'] = this.isNewRegisteredTenantActiveByDefault;
    data['useCaptchaOnRegistration'] = this.useCaptchaOnRegistration;
    data['defaultEditionId'] = this.defaultEditionId;
    return data;
  }
}

export interface ITenantManagementSettingsEditDto {
  allowSelfRegistration: boolean;
  isNewRegisteredTenantActiveByDefault: boolean;
  useCaptchaOnRegistration: boolean;
  defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
  requireDigit!: boolean;
  requireLowercase!: boolean;
  requireNonAlphanumeric!: boolean;
  requireUppercase!: boolean;
  requiredLength!: number;

  constructor(data?: IPasswordComplexitySetting) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.requireDigit = _data['requireDigit'];
      this.requireLowercase = _data['requireLowercase'];
      this.requireNonAlphanumeric = _data['requireNonAlphanumeric'];
      this.requireUppercase = _data['requireUppercase'];
      this.requiredLength = _data['requiredLength'];
    }
  }

  static fromJS(data: any): PasswordComplexitySetting {
    data = typeof data === 'object' ? data : {};
    let result = new PasswordComplexitySetting();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['requireDigit'] = this.requireDigit;
    data['requireLowercase'] = this.requireLowercase;
    data['requireNonAlphanumeric'] = this.requireNonAlphanumeric;
    data['requireUppercase'] = this.requireUppercase;
    data['requiredLength'] = this.requiredLength;
    return data;
  }
}

export interface IPasswordComplexitySetting {
  requireDigit: boolean;
  requireLowercase: boolean;
  requireNonAlphanumeric: boolean;
  requireUppercase: boolean;
  requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
  isEnabled!: boolean;
  maxFailedAccessAttemptsBeforeLockout!: number;
  defaultAccountLockoutSeconds!: number;

  constructor(data?: IUserLockOutSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isEnabled = _data['isEnabled'];
      this.maxFailedAccessAttemptsBeforeLockout = _data['maxFailedAccessAttemptsBeforeLockout'];
      this.defaultAccountLockoutSeconds = _data['defaultAccountLockoutSeconds'];
    }
  }

  static fromJS(data: any): UserLockOutSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserLockOutSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isEnabled'] = this.isEnabled;
    data['maxFailedAccessAttemptsBeforeLockout'] = this.maxFailedAccessAttemptsBeforeLockout;
    data['defaultAccountLockoutSeconds'] = this.defaultAccountLockoutSeconds;
    return data;
  }
}

export interface IUserLockOutSettingsEditDto {
  isEnabled: boolean;
  maxFailedAccessAttemptsBeforeLockout: number;
  defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
  isEnabledForApplication!: boolean;
  isEnabled!: boolean;
  isEmailProviderEnabled!: boolean;
  isSmsProviderEnabled!: boolean;
  isRememberBrowserEnabled!: boolean;
  isGoogleAuthenticatorEnabled!: boolean;

  constructor(data?: ITwoFactorLoginSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isEnabledForApplication = _data['isEnabledForApplication'];
      this.isEnabled = _data['isEnabled'];
      this.isEmailProviderEnabled = _data['isEmailProviderEnabled'];
      this.isSmsProviderEnabled = _data['isSmsProviderEnabled'];
      this.isRememberBrowserEnabled = _data['isRememberBrowserEnabled'];
      this.isGoogleAuthenticatorEnabled = _data['isGoogleAuthenticatorEnabled'];
    }
  }

  static fromJS(data: any): TwoFactorLoginSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TwoFactorLoginSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isEnabledForApplication'] = this.isEnabledForApplication;
    data['isEnabled'] = this.isEnabled;
    data['isEmailProviderEnabled'] = this.isEmailProviderEnabled;
    data['isSmsProviderEnabled'] = this.isSmsProviderEnabled;
    data['isRememberBrowserEnabled'] = this.isRememberBrowserEnabled;
    data['isGoogleAuthenticatorEnabled'] = this.isGoogleAuthenticatorEnabled;
    return data;
  }
}

export interface ITwoFactorLoginSettingsEditDto {
  isEnabledForApplication: boolean;
  isEnabled: boolean;
  isEmailProviderEnabled: boolean;
  isSmsProviderEnabled: boolean;
  isRememberBrowserEnabled: boolean;
  isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
  allowOneConcurrentLoginPerUser!: boolean;
  useDefaultPasswordComplexitySettings!: boolean;
  passwordComplexity!: PasswordComplexitySetting;
  defaultPasswordComplexity!: PasswordComplexitySetting;
  userLockOut!: UserLockOutSettingsEditDto;
  twoFactorLogin!: TwoFactorLoginSettingsEditDto;

  constructor(data?: ISecuritySettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.allowOneConcurrentLoginPerUser = _data['allowOneConcurrentLoginPerUser'];
      this.useDefaultPasswordComplexitySettings = _data['useDefaultPasswordComplexitySettings'];
      this.passwordComplexity = _data['passwordComplexity'] ? PasswordComplexitySetting.fromJS(_data['passwordComplexity']) : <any>undefined;
      this.defaultPasswordComplexity = _data['defaultPasswordComplexity']
        ? PasswordComplexitySetting.fromJS(_data['defaultPasswordComplexity'])
        : <any>undefined;
      this.userLockOut = _data['userLockOut'] ? UserLockOutSettingsEditDto.fromJS(_data['userLockOut']) : <any>undefined;
      this.twoFactorLogin = _data['twoFactorLogin'] ? TwoFactorLoginSettingsEditDto.fromJS(_data['twoFactorLogin']) : <any>undefined;
    }
  }

  static fromJS(data: any): SecuritySettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new SecuritySettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['allowOneConcurrentLoginPerUser'] = this.allowOneConcurrentLoginPerUser;
    data['useDefaultPasswordComplexitySettings'] = this.useDefaultPasswordComplexitySettings;
    data['passwordComplexity'] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
    data['defaultPasswordComplexity'] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
    data['userLockOut'] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
    data['twoFactorLogin'] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
    return data;
  }
}

export interface ISecuritySettingsEditDto {
  allowOneConcurrentLoginPerUser: boolean;
  useDefaultPasswordComplexitySettings: boolean;
  passwordComplexity: PasswordComplexitySetting;
  defaultPasswordComplexity: PasswordComplexitySetting;
  userLockOut: UserLockOutSettingsEditDto;
  twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
  legalName!: string | undefined;
  address!: string | undefined;
  taxVat!: string | undefined;

  constructor(data?: IHostBillingSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.legalName = _data['legalName'];
      this.address = _data['address'];
      this.taxVat = _data['taxVat'];
    }
  }

  static fromJS(data: any): HostBillingSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new HostBillingSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['legalName'] = this.legalName;
    data['address'] = this.address;
    data['taxVat'] = this.taxVat;
    return data;
  }
}

export interface IHostBillingSettingsEditDto {
  legalName: string | undefined;
  address: string | undefined;
  taxVat: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
  isQuickThemeSelectEnabled!: boolean;

  constructor(data?: IOtherSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isQuickThemeSelectEnabled = _data['isQuickThemeSelectEnabled'];
    }
  }

  static fromJS(data: any): OtherSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new OtherSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isQuickThemeSelectEnabled'] = this.isQuickThemeSelectEnabled;
    return data;
  }
}

export interface IOtherSettingsEditDto {
  isQuickThemeSelectEnabled: boolean;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
  appId!: string | undefined;
  appSecret!: string | undefined;

  constructor(data?: IFacebookExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.appId = _data['appId'];
      this.appSecret = _data['appSecret'];
    }
  }

  static fromJS(data: any): FacebookExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new FacebookExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['appId'] = this.appId;
    data['appSecret'] = this.appSecret;
    return data;
  }
}

export interface IFacebookExternalLoginProviderSettings {
  appId: string | undefined;
  appSecret: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
  clientId!: string | undefined;
  clientSecret!: string | undefined;
  userInfoEndpoint!: string | undefined;

  constructor(data?: IGoogleExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data['clientId'];
      this.clientSecret = _data['clientSecret'];
      this.userInfoEndpoint = _data['userInfoEndpoint'];
    }
  }

  static fromJS(data: any): GoogleExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new GoogleExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientId'] = this.clientId;
    data['clientSecret'] = this.clientSecret;
    data['userInfoEndpoint'] = this.userInfoEndpoint;
    return data;
  }
}

export interface IGoogleExternalLoginProviderSettings {
  clientId: string | undefined;
  clientSecret: string | undefined;
  userInfoEndpoint: string | undefined;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
  consumerKey!: string | undefined;
  consumerSecret!: string | undefined;

  constructor(data?: ITwitterExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.consumerKey = _data['consumerKey'];
      this.consumerSecret = _data['consumerSecret'];
    }
  }

  static fromJS(data: any): TwitterExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new TwitterExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['consumerKey'] = this.consumerKey;
    data['consumerSecret'] = this.consumerSecret;
    return data;
  }
}

export interface ITwitterExternalLoginProviderSettings {
  consumerKey: string | undefined;
  consumerSecret: string | undefined;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
  clientId!: string | undefined;
  clientSecret!: string | undefined;

  constructor(data?: IMicrosoftExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data['clientId'];
      this.clientSecret = _data['clientSecret'];
    }
  }

  static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new MicrosoftExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientId'] = this.clientId;
    data['clientSecret'] = this.clientSecret;
    return data;
  }
}

export interface IMicrosoftExternalLoginProviderSettings {
  clientId: string | undefined;
  clientSecret: string | undefined;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
  clientId!: string | undefined;
  clientSecret!: string | undefined;
  authority!: string | undefined;
  loginUrl!: string | undefined;
  validateIssuer!: boolean;

  constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data['clientId'];
      this.clientSecret = _data['clientSecret'];
      this.authority = _data['authority'];
      this.loginUrl = _data['loginUrl'];
      this.validateIssuer = _data['validateIssuer'];
    }
  }

  static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new OpenIdConnectExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientId'] = this.clientId;
    data['clientSecret'] = this.clientSecret;
    data['authority'] = this.authority;
    data['loginUrl'] = this.loginUrl;
    data['validateIssuer'] = this.validateIssuer;
    return data;
  }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
  clientId: string | undefined;
  clientSecret: string | undefined;
  authority: string | undefined;
  loginUrl: string | undefined;
  validateIssuer: boolean;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
  claim!: string | undefined;
  key!: string | undefined;

  constructor(data?: IJsonClaimMapDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.claim = _data['claim'];
      this.key = _data['key'];
    }
  }

  static fromJS(data: any): JsonClaimMapDto {
    data = typeof data === 'object' ? data : {};
    let result = new JsonClaimMapDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['claim'] = this.claim;
    data['key'] = this.key;
    return data;
  }
}

export interface IJsonClaimMapDto {
  claim: string | undefined;
  key: string | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
  clientId!: string | undefined;
  tenant!: string | undefined;
  metaDataAddress!: string | undefined;
  wtrealm!: string | undefined;
  authority!: string | undefined;

  constructor(data?: IWsFederationExternalLoginProviderSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data['clientId'];
      this.tenant = _data['tenant'];
      this.metaDataAddress = _data['metaDataAddress'];
      this.wtrealm = _data['wtrealm'];
      this.authority = _data['authority'];
    }
  }

  static fromJS(data: any): WsFederationExternalLoginProviderSettings {
    data = typeof data === 'object' ? data : {};
    let result = new WsFederationExternalLoginProviderSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientId'] = this.clientId;
    data['tenant'] = this.tenant;
    data['metaDataAddress'] = this.metaDataAddress;
    data['wtrealm'] = this.wtrealm;
    data['authority'] = this.authority;
    return data;
  }
}

export interface IWsFederationExternalLoginProviderSettings {
  clientId: string | undefined;
  tenant: string | undefined;
  metaDataAddress: string | undefined;
  wtrealm: string | undefined;
  authority: string | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
  facebook!: FacebookExternalLoginProviderSettings;
  google!: GoogleExternalLoginProviderSettings;
  twitter!: TwitterExternalLoginProviderSettings;
  microsoft!: MicrosoftExternalLoginProviderSettings;
  openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
  openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
  wsFederation!: WsFederationExternalLoginProviderSettings;
  wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

  constructor(data?: IExternalLoginProviderSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.facebook = _data['facebook'] ? FacebookExternalLoginProviderSettings.fromJS(_data['facebook']) : <any>undefined;
      this.google = _data['google'] ? GoogleExternalLoginProviderSettings.fromJS(_data['google']) : <any>undefined;
      this.twitter = _data['twitter'] ? TwitterExternalLoginProviderSettings.fromJS(_data['twitter']) : <any>undefined;
      this.microsoft = _data['microsoft'] ? MicrosoftExternalLoginProviderSettings.fromJS(_data['microsoft']) : <any>undefined;
      this.openIdConnect = _data['openIdConnect'] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data['openIdConnect']) : <any>undefined;
      if (Array.isArray(_data['openIdConnectClaimsMapping'])) {
        this.openIdConnectClaimsMapping = [] as any;
        for (let item of _data['openIdConnectClaimsMapping']) this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
      }
      this.wsFederation = _data['wsFederation'] ? WsFederationExternalLoginProviderSettings.fromJS(_data['wsFederation']) : <any>undefined;
      if (Array.isArray(_data['wsFederationClaimsMapping'])) {
        this.wsFederationClaimsMapping = [] as any;
        for (let item of _data['wsFederationClaimsMapping']) this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginProviderSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['facebook'] = this.facebook ? this.facebook.toJSON() : <any>undefined;
    data['google'] = this.google ? this.google.toJSON() : <any>undefined;
    data['twitter'] = this.twitter ? this.twitter.toJSON() : <any>undefined;
    data['microsoft'] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
    data['openIdConnect'] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
    if (Array.isArray(this.openIdConnectClaimsMapping)) {
      data['openIdConnectClaimsMapping'] = [];
      for (let item of this.openIdConnectClaimsMapping) data['openIdConnectClaimsMapping'].push(item.toJSON());
    }
    data['wsFederation'] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
    if (Array.isArray(this.wsFederationClaimsMapping)) {
      data['wsFederationClaimsMapping'] = [];
      for (let item of this.wsFederationClaimsMapping) data['wsFederationClaimsMapping'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExternalLoginProviderSettingsEditDto {
  facebook: FacebookExternalLoginProviderSettings;
  google: GoogleExternalLoginProviderSettings;
  twitter: TwitterExternalLoginProviderSettings;
  microsoft: MicrosoftExternalLoginProviderSettings;
  openIdConnect: OpenIdConnectExternalLoginProviderSettings;
  openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
  wsFederation: WsFederationExternalLoginProviderSettings;
  wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class SmsSettingsEditDto implements ISmsSettingsEditDto {
  unifonicAppSid!: string | undefined;
  unifonicSenderId!: string | undefined;
  unifonicAdvertisingSenderId!: string | undefined;
  unifonicNotificationSenderId!: string | undefined;

  constructor(data?: ISmsSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.unifonicAppSid = _data['unifonicAppSid'];
      this.unifonicSenderId = _data['unifonicSenderId'];
      this.unifonicAdvertisingSenderId = _data['unifonicAdvertisingSenderId'];
      this.unifonicNotificationSenderId = _data['unifonicNotificationSenderId'];
    }
  }

  static fromJS(data: any): SmsSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new SmsSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['unifonicAppSid'] = this.unifonicAppSid;
    data['unifonicSenderId'] = this.unifonicSenderId;
    data['unifonicAdvertisingSenderId'] = this.unifonicAdvertisingSenderId;
    data['unifonicNotificationSenderId'] = this.unifonicNotificationSenderId;
    return data;
  }
}

export interface ISmsSettingsEditDto {
  unifonicAppSid: string | undefined;
  unifonicSenderId: string | undefined;
  unifonicAdvertisingSenderId: string | undefined;
  unifonicNotificationSenderId: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
  general!: GeneralSettingsEditDto;
  userManagement!: HostUserManagementSettingsEditDto;
  email!: EmailSettingsEditDto;
  tenantManagement!: TenantManagementSettingsEditDto;
  security!: SecuritySettingsEditDto;
  billing!: HostBillingSettingsEditDto;
  otherSettings!: OtherSettingsEditDto;
  externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;
  smsSettings!: SmsSettingsEditDto;

  constructor(data?: IHostSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.general = new GeneralSettingsEditDto();
      this.userManagement = new HostUserManagementSettingsEditDto();
      this.email = new EmailSettingsEditDto();
      this.tenantManagement = new TenantManagementSettingsEditDto();
      this.security = new SecuritySettingsEditDto();
      this.smsSettings = new SmsSettingsEditDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.general = _data['general'] ? GeneralSettingsEditDto.fromJS(_data['general']) : new GeneralSettingsEditDto();
      this.userManagement = _data['userManagement']
        ? HostUserManagementSettingsEditDto.fromJS(_data['userManagement'])
        : new HostUserManagementSettingsEditDto();
      this.email = _data['email'] ? EmailSettingsEditDto.fromJS(_data['email']) : new EmailSettingsEditDto();
      this.tenantManagement = _data['tenantManagement']
        ? TenantManagementSettingsEditDto.fromJS(_data['tenantManagement'])
        : new TenantManagementSettingsEditDto();
      this.security = _data['security'] ? SecuritySettingsEditDto.fromJS(_data['security']) : new SecuritySettingsEditDto();
      this.billing = _data['billing'] ? HostBillingSettingsEditDto.fromJS(_data['billing']) : <any>undefined;
      this.otherSettings = _data['otherSettings'] ? OtherSettingsEditDto.fromJS(_data['otherSettings']) : <any>undefined;
      this.externalLoginProviderSettings = _data['externalLoginProviderSettings']
        ? ExternalLoginProviderSettingsEditDto.fromJS(_data['externalLoginProviderSettings'])
        : <any>undefined;
      this.smsSettings = _data['smsSettings'] ? SmsSettingsEditDto.fromJS(_data['smsSettings']) : new SmsSettingsEditDto();
    }
  }

  static fromJS(data: any): HostSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new HostSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['general'] = this.general ? this.general.toJSON() : <any>undefined;
    data['userManagement'] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
    data['email'] = this.email ? this.email.toJSON() : <any>undefined;
    data['tenantManagement'] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
    data['security'] = this.security ? this.security.toJSON() : <any>undefined;
    data['billing'] = this.billing ? this.billing.toJSON() : <any>undefined;
    data['otherSettings'] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
    data['externalLoginProviderSettings'] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
    data['smsSettings'] = this.smsSettings ? this.smsSettings.toJSON() : <any>undefined;
    return data;
  }
}

export interface IHostSettingsEditDto {
  general: GeneralSettingsEditDto;
  userManagement: HostUserManagementSettingsEditDto;
  email: EmailSettingsEditDto;
  tenantManagement: TenantManagementSettingsEditDto;
  security: SecuritySettingsEditDto;
  billing: HostBillingSettingsEditDto;
  otherSettings: OtherSettingsEditDto;
  externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
  smsSettings: SmsSettingsEditDto;
}

export class TestUnifonicSmsInput implements ITestUnifonicSmsInput {
  text!: string | undefined;
  number!: string | undefined;

  constructor(data?: ITestUnifonicSmsInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.text = _data['text'];
      this.number = _data['number'];
    }
  }

  static fromJS(data: any): TestUnifonicSmsInput {
    data = typeof data === 'object' ? data : {};
    let result = new TestUnifonicSmsInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['text'] = this.text;
    data['number'] = this.number;
    return data;
  }
}

export interface ITestUnifonicSmsInput {
  text: string | undefined;
  number: string | undefined;
}

export class UnifonicResponseRootData implements IUnifonicResponseRootData {
  messageID!: number;
  correlationID!: string | undefined;
  status!: string | undefined;
  numberOfUnits!: number;
  cost!: number;
  balance!: number;
  recipient!: string | undefined;
  timeCreated!: string | undefined;
  currencyCode!: string | undefined;

  constructor(data?: IUnifonicResponseRootData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.messageID = _data['messageID'];
      this.correlationID = _data['correlationID'];
      this.status = _data['status'];
      this.numberOfUnits = _data['numberOfUnits'];
      this.cost = _data['cost'];
      this.balance = _data['balance'];
      this.recipient = _data['recipient'];
      this.timeCreated = _data['timeCreated'];
      this.currencyCode = _data['currencyCode'];
    }
  }

  static fromJS(data: any): UnifonicResponseRootData {
    data = typeof data === 'object' ? data : {};
    let result = new UnifonicResponseRootData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['messageID'] = this.messageID;
    data['correlationID'] = this.correlationID;
    data['status'] = this.status;
    data['numberOfUnits'] = this.numberOfUnits;
    data['cost'] = this.cost;
    data['balance'] = this.balance;
    data['recipient'] = this.recipient;
    data['timeCreated'] = this.timeCreated;
    data['currencyCode'] = this.currencyCode;
    return data;
  }
}

export interface IUnifonicResponseRootData {
  messageID: number;
  correlationID: string | undefined;
  status: string | undefined;
  numberOfUnits: number;
  cost: number;
  balance: number;
  recipient: string | undefined;
  timeCreated: string | undefined;
  currencyCode: string | undefined;
}

export class UnifonicResponseRoot implements IUnifonicResponseRoot {
  success!: boolean;
  message!: string | undefined;
  errorCode!: string | undefined;
  data!: UnifonicResponseRootData;

  constructor(data?: IUnifonicResponseRoot) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data['success'];
      this.message = _data['message'];
      this.errorCode = _data['errorCode'];
      this.data = _data['data'] ? UnifonicResponseRootData.fromJS(_data['data']) : <any>undefined;
    }
  }

  static fromJS(data: any): UnifonicResponseRoot {
    data = typeof data === 'object' ? data : {};
    let result = new UnifonicResponseRoot();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['success'] = this.success;
    data['message'] = this.message;
    data['errorCode'] = this.errorCode;
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUnifonicResponseRoot {
  success: boolean;
  message: string | undefined;
  errorCode: string | undefined;
  data: UnifonicResponseRootData;
}

export class SendTestEmailInput implements ISendTestEmailInput {
  emailAddress!: string;

  constructor(data?: ISendTestEmailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.emailAddress = _data['emailAddress'];
    }
  }

  static fromJS(data: any): SendTestEmailInput {
    data = typeof data === 'object' ? data : {};
    let result = new SendTestEmailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['emailAddress'] = this.emailAddress;
    return data;
  }
}

export interface ISendTestEmailInput {
  emailAddress: string;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
  enabledSocialLoginSettings!: string[] | undefined;

  constructor(data?: IExternalLoginSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['enabledSocialLoginSettings'])) {
        this.enabledSocialLoginSettings = [] as any;
        for (let item of _data['enabledSocialLoginSettings']) this.enabledSocialLoginSettings!.push(item);
      }
    }
  }

  static fromJS(data: any): ExternalLoginSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.enabledSocialLoginSettings)) {
      data['enabledSocialLoginSettings'] = [];
      for (let item of this.enabledSocialLoginSettings) data['enabledSocialLoginSettings'].push(item);
    }
    return data;
  }
}

export interface IExternalLoginSettingsDto {
  enabledSocialLoginSettings: string[] | undefined;
}

export class InstallDto implements IInstallDto {
  connectionString!: string;
  adminPassword!: string;
  webSiteUrl!: string;
  serverUrl!: string | undefined;
  defaultLanguage!: string;
  smtpSettings!: EmailSettingsEditDto;
  billInfo!: HostBillingSettingsEditDto;

  constructor(data?: IInstallDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.connectionString = _data['connectionString'];
      this.adminPassword = _data['adminPassword'];
      this.webSiteUrl = _data['webSiteUrl'];
      this.serverUrl = _data['serverUrl'];
      this.defaultLanguage = _data['defaultLanguage'];
      this.smtpSettings = _data['smtpSettings'] ? EmailSettingsEditDto.fromJS(_data['smtpSettings']) : <any>undefined;
      this.billInfo = _data['billInfo'] ? HostBillingSettingsEditDto.fromJS(_data['billInfo']) : <any>undefined;
    }
  }

  static fromJS(data: any): InstallDto {
    data = typeof data === 'object' ? data : {};
    let result = new InstallDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['connectionString'] = this.connectionString;
    data['adminPassword'] = this.adminPassword;
    data['webSiteUrl'] = this.webSiteUrl;
    data['serverUrl'] = this.serverUrl;
    data['defaultLanguage'] = this.defaultLanguage;
    data['smtpSettings'] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
    data['billInfo'] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IInstallDto {
  connectionString: string;
  adminPassword: string;
  webSiteUrl: string;
  serverUrl: string | undefined;
  defaultLanguage: string;
  smtpSettings: EmailSettingsEditDto;
  billInfo: HostBillingSettingsEditDto;
}

export class NameValue implements INameValue {
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: INameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): NameValue {
    data = typeof data === 'object' ? data : {};
    let result = new NameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface INameValue {
  name: string | undefined;
  value: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
  webSiteUrl!: string | undefined;
  serverSiteUrl!: string | undefined;
  languages!: NameValue[] | undefined;

  constructor(data?: IAppSettingsJsonDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webSiteUrl = _data['webSiteUrl'];
      this.serverSiteUrl = _data['serverSiteUrl'];
      if (Array.isArray(_data['languages'])) {
        this.languages = [] as any;
        for (let item of _data['languages']) this.languages!.push(NameValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AppSettingsJsonDto {
    data = typeof data === 'object' ? data : {};
    let result = new AppSettingsJsonDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['webSiteUrl'] = this.webSiteUrl;
    data['serverSiteUrl'] = this.serverSiteUrl;
    if (Array.isArray(this.languages)) {
      data['languages'] = [];
      for (let item of this.languages) data['languages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IAppSettingsJsonDto {
  webSiteUrl: string | undefined;
  serverSiteUrl: string | undefined;
  languages: NameValue[] | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
  isDatabaseExist!: boolean;

  constructor(data?: ICheckDatabaseOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isDatabaseExist = _data['isDatabaseExist'];
    }
  }

  static fromJS(data: any): CheckDatabaseOutput {
    data = typeof data === 'object' ? data : {};
    let result = new CheckDatabaseOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isDatabaseExist'] = this.isDatabaseExist;
    return data;
  }
}

export interface ICheckDatabaseOutput {
  isDatabaseExist: boolean;
}

export class InvoiceDto implements IInvoiceDto {
  amount!: number;
  editionDisplayName!: string | undefined;
  invoiceNo!: string | undefined;
  invoiceDate!: moment.Moment;
  tenantLegalName!: string | undefined;
  tenantAddress!: string[] | undefined;
  tenantTaxNo!: string | undefined;
  hostLegalName!: string | undefined;
  hostAddress!: string[] | undefined;

  constructor(data?: IInvoiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data['amount'];
      this.editionDisplayName = _data['editionDisplayName'];
      this.invoiceNo = _data['invoiceNo'];
      this.invoiceDate = _data['invoiceDate'] ? moment(_data['invoiceDate'].toString()) : <any>undefined;
      this.tenantLegalName = _data['tenantLegalName'];
      if (Array.isArray(_data['tenantAddress'])) {
        this.tenantAddress = [] as any;
        for (let item of _data['tenantAddress']) this.tenantAddress!.push(item);
      }
      this.tenantTaxNo = _data['tenantTaxNo'];
      this.hostLegalName = _data['hostLegalName'];
      if (Array.isArray(_data['hostAddress'])) {
        this.hostAddress = [] as any;
        for (let item of _data['hostAddress']) this.hostAddress!.push(item);
      }
    }
  }

  static fromJS(data: any): InvoiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['amount'] = this.amount;
    data['editionDisplayName'] = this.editionDisplayName;
    data['invoiceNo'] = this.invoiceNo;
    data['invoiceDate'] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
    data['tenantLegalName'] = this.tenantLegalName;
    if (Array.isArray(this.tenantAddress)) {
      data['tenantAddress'] = [];
      for (let item of this.tenantAddress) data['tenantAddress'].push(item);
    }
    data['tenantTaxNo'] = this.tenantTaxNo;
    data['hostLegalName'] = this.hostLegalName;
    if (Array.isArray(this.hostAddress)) {
      data['hostAddress'] = [];
      for (let item of this.hostAddress) data['hostAddress'].push(item);
    }
    return data;
  }
}

export interface IInvoiceDto {
  amount: number;
  editionDisplayName: string | undefined;
  invoiceNo: string | undefined;
  invoiceDate: moment.Moment;
  tenantLegalName: string | undefined;
  tenantAddress: string[] | undefined;
  tenantTaxNo: string | undefined;
  hostLegalName: string | undefined;
  hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
  subscriptionPaymentId!: number;

  constructor(data?: ICreateInvoiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subscriptionPaymentId = _data['subscriptionPaymentId'];
    }
  }

  static fromJS(data: any): CreateInvoiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateInvoiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['subscriptionPaymentId'] = this.subscriptionPaymentId;
    return data;
  }
}

export interface ICreateInvoiceDto {
  subscriptionPaymentId: number;
}

export enum InvoiceAccountType {
  AccountReceivable = 1,
  AccountPayable = 2,
}

export class InvoiceListDto implements IInvoiceListDto {
  invoiceNumber!: number;
  periodId!: number;
  tenantName!: string | undefined;
  period!: string | undefined;
  dueDate!: moment.Moment;
  isPaid!: boolean;
  accountType!: InvoiceAccountType;
  readonly accountTypeTitle!: string | undefined;
  totalAmount!: number;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number;

  constructor(data?: IInvoiceListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceNumber = _data['invoiceNumber'];
      this.periodId = _data['periodId'];
      this.tenantName = _data['tenantName'];
      this.period = _data['period'];
      this.dueDate = _data['dueDate'] ? moment(_data['dueDate'].toString()) : <any>undefined;
      this.isPaid = _data['isPaid'];
      this.accountType = _data['accountType'];
      (<any>this).accountTypeTitle = _data['accountTypeTitle'];
      this.totalAmount = _data['totalAmount'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): InvoiceListDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['invoiceNumber'] = this.invoiceNumber;
    data['periodId'] = this.periodId;
    data['tenantName'] = this.tenantName;
    data['period'] = this.period;
    data['dueDate'] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
    data['isPaid'] = this.isPaid;
    data['accountType'] = this.accountType;
    data['accountTypeTitle'] = this.accountTypeTitle;
    data['totalAmount'] = this.totalAmount;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface IInvoiceListDto {
  invoiceNumber: number;
  periodId: number;
  tenantName: string | undefined;
  period: string | undefined;
  dueDate: moment.Moment;
  isPaid: boolean;
  accountType: InvoiceAccountType;
  accountTypeTitle: string | undefined;
  totalAmount: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number;
}

export class PagedResultDtoOfInvoiceListDto implements IPagedResultDtoOfInvoiceListDto {
  totalCount!: number;
  items!: InvoiceListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfInvoiceListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoiceListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfInvoiceListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfInvoiceListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfInvoiceListDto {
  totalCount: number;
  items: InvoiceListDto[] | undefined;
}

export class InvoiceItemDto implements IInvoiceItemDto {
  sequence!: string | undefined;
  wayBillNumber!: string | undefined;
  subTotalAmount!: number;
  vatAmount!: number;
  totalAmount!: number;
  truckType!: string | undefined;
  source!: string | undefined;
  destination!: string | undefined;
  dateWork!: string | undefined;
  remarks!: string | undefined;

  constructor(data?: IInvoiceItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sequence = _data['sequence'];
      this.wayBillNumber = _data['wayBillNumber'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.totalAmount = _data['totalAmount'];
      this.truckType = _data['truckType'];
      this.source = _data['source'];
      this.destination = _data['destination'];
      this.dateWork = _data['dateWork'];
      this.remarks = _data['remarks'];
    }
  }

  static fromJS(data: any): InvoiceItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sequence'] = this.sequence;
    data['wayBillNumber'] = this.wayBillNumber;
    data['subTotalAmount'] = this.subTotalAmount;
    data['vatAmount'] = this.vatAmount;
    data['totalAmount'] = this.totalAmount;
    data['truckType'] = this.truckType;
    data['source'] = this.source;
    data['destination'] = this.destination;
    data['dateWork'] = this.dateWork;
    data['remarks'] = this.remarks;
    return data;
  }
}

export interface IInvoiceItemDto {
  sequence: string | undefined;
  wayBillNumber: string | undefined;
  subTotalAmount: number;
  vatAmount: number;
  totalAmount: number;
  truckType: string | undefined;
  source: string | undefined;
  destination: string | undefined;
  dateWork: string | undefined;
  remarks: string | undefined;
}

export class InvoiceInfoDto implements IInvoiceInfoDto {
  clientName!: string | undefined;
  email!: string | undefined;
  address!: string | undefined;
  phone!: string | undefined;
  faxNo!: string | undefined;
  attn!: string | undefined;
  cr!: string | undefined;
  contractNo!: string | undefined;
  projectName!: string | undefined;
  period!: string | undefined;
  dueDate!: moment.Moment;
  creationTime!: moment.Moment;
  isPaid!: boolean;
  accountType!: InvoiceAccountType;
  note!: string | undefined;
  subTotalAmount!: number;
  totalAmount!: number;
  vatAmount!: number;
  taxVat!: number;
  invoiceNumber!: number;
  items!: InvoiceItemDto[] | undefined;
  id!: number;

  constructor(data?: IInvoiceInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientName = _data['clientName'];
      this.email = _data['email'];
      this.address = _data['address'];
      this.phone = _data['phone'];
      this.faxNo = _data['faxNo'];
      this.attn = _data['attn'];
      this.cr = _data['cr'];
      this.contractNo = _data['contractNo'];
      this.projectName = _data['projectName'];
      this.period = _data['period'];
      this.dueDate = _data['dueDate'] ? moment(_data['dueDate'].toString()) : <any>undefined;
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.isPaid = _data['isPaid'];
      this.accountType = _data['accountType'];
      this.note = _data['note'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.totalAmount = _data['totalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.taxVat = _data['taxVat'];
      this.invoiceNumber = _data['invoiceNumber'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoiceItemDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): InvoiceInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientName'] = this.clientName;
    data['email'] = this.email;
    data['address'] = this.address;
    data['phone'] = this.phone;
    data['faxNo'] = this.faxNo;
    data['attn'] = this.attn;
    data['cr'] = this.cr;
    data['contractNo'] = this.contractNo;
    data['projectName'] = this.projectName;
    data['period'] = this.period;
    data['dueDate'] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['isPaid'] = this.isPaid;
    data['accountType'] = this.accountType;
    data['note'] = this.note;
    data['subTotalAmount'] = this.subTotalAmount;
    data['totalAmount'] = this.totalAmount;
    data['vatAmount'] = this.vatAmount;
    data['taxVat'] = this.taxVat;
    data['invoiceNumber'] = this.invoiceNumber;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface IInvoiceInfoDto {
  clientName: string | undefined;
  email: string | undefined;
  address: string | undefined;
  phone: string | undefined;
  faxNo: string | undefined;
  attn: string | undefined;
  cr: string | undefined;
  contractNo: string | undefined;
  projectName: string | undefined;
  period: string | undefined;
  dueDate: moment.Moment;
  creationTime: moment.Moment;
  isPaid: boolean;
  accountType: InvoiceAccountType;
  note: string | undefined;
  subTotalAmount: number;
  totalAmount: number;
  vatAmount: number;
  taxVat: number;
  invoiceNumber: number;
  items: InvoiceItemDto[] | undefined;
  id: number;
}

export class InvoiceFilterInput implements IInvoiceFilterInput {
  tenantId!: number | undefined;
  periodId!: number | undefined;
  isPaid!: boolean | undefined;
  accountType!: InvoiceAccountType;
  fromDate!: moment.Moment | undefined;
  toDate!: moment.Moment | undefined;
  dueFromDate!: moment.Moment | undefined;
  dueToDate!: moment.Moment | undefined;
  sorting!: string | undefined;
  skipCount!: number;
  maxResultCount!: number;

  constructor(data?: IInvoiceFilterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.periodId = _data['periodId'];
      this.isPaid = _data['isPaid'];
      this.accountType = _data['accountType'];
      this.fromDate = _data['fromDate'] ? moment(_data['fromDate'].toString()) : <any>undefined;
      this.toDate = _data['toDate'] ? moment(_data['toDate'].toString()) : <any>undefined;
      this.dueFromDate = _data['dueFromDate'] ? moment(_data['dueFromDate'].toString()) : <any>undefined;
      this.dueToDate = _data['dueToDate'] ? moment(_data['dueToDate'].toString()) : <any>undefined;
      this.sorting = _data['sorting'];
      this.skipCount = _data['skipCount'];
      this.maxResultCount = _data['maxResultCount'];
    }
  }

  static fromJS(data: any): InvoiceFilterInput {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceFilterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['periodId'] = this.periodId;
    data['isPaid'] = this.isPaid;
    data['accountType'] = this.accountType;
    data['fromDate'] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
    data['toDate'] = this.toDate ? this.toDate.toISOString() : <any>undefined;
    data['dueFromDate'] = this.dueFromDate ? this.dueFromDate.toISOString() : <any>undefined;
    data['dueToDate'] = this.dueToDate ? this.dueToDate.toISOString() : <any>undefined;
    data['sorting'] = this.sorting;
    data['skipCount'] = this.skipCount;
    data['maxResultCount'] = this.maxResultCount;
    return data;
  }
}

export interface IInvoiceFilterInput {
  tenantId: number | undefined;
  periodId: number | undefined;
  isPaid: boolean | undefined;
  accountType: InvoiceAccountType;
  fromDate: moment.Moment | undefined;
  toDate: moment.Moment | undefined;
  dueFromDate: moment.Moment | undefined;
  dueToDate: moment.Moment | undefined;
  sorting: string | undefined;
  skipCount: number;
  maxResultCount: number;
}

export enum InvoicePaymentType {
  PayInAdvance = 1,
  PayuponDelivery = 2,
  Days = 3,
}

export class InvoicePaymentMethodListDto implements IInvoicePaymentMethodListDto {
  displayName!: string | undefined;
  paymentType!: InvoicePaymentType;
  invoiceDueDateDays!: number | undefined;
  creationTime!: moment.Moment;
  id!: number;

  constructor(data?: IInvoicePaymentMethodListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.paymentType = _data['paymentType'];
      this.invoiceDueDateDays = _data['invoiceDueDateDays'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): InvoicePaymentMethodListDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoicePaymentMethodListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['paymentType'] = this.paymentType;
    data['invoiceDueDateDays'] = this.invoiceDueDateDays;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IInvoicePaymentMethodListDto {
  displayName: string | undefined;
  paymentType: InvoicePaymentType;
  invoiceDueDateDays: number | undefined;
  creationTime: moment.Moment;
  id: number;
}

export class ListResultDtoOfInvoicePaymentMethodListDto implements IListResultDtoOfInvoicePaymentMethodListDto {
  items!: InvoicePaymentMethodListDto[] | undefined;

  constructor(data?: IListResultDtoOfInvoicePaymentMethodListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoicePaymentMethodListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfInvoicePaymentMethodListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfInvoicePaymentMethodListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfInvoicePaymentMethodListDto {
  items: InvoicePaymentMethodListDto[] | undefined;
}

export class CreateOrEditInvoicePaymentMethod implements ICreateOrEditInvoicePaymentMethod {
  displayName!: string;
  paymentType!: InvoicePaymentType;
  invoiceDueDateDays!: number | undefined;
  id!: number;

  constructor(data?: ICreateOrEditInvoicePaymentMethod) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.paymentType = _data['paymentType'];
      this.invoiceDueDateDays = _data['invoiceDueDateDays'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditInvoicePaymentMethod {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditInvoicePaymentMethod();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['paymentType'] = this.paymentType;
    data['invoiceDueDateDays'] = this.invoiceDueDateDays;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditInvoicePaymentMethod {
  displayName: string;
  paymentType: InvoicePaymentType;
  invoiceDueDateDays: number | undefined;
  id: number;
}

export enum InvoicePeriodType {
  PayInAdvance = 1,
  PayuponDelivery = 2,
  Daily = 3,
  Weekly = 4,
  Monthly = 5,
}

export enum FrequencyRelativeInterval {
  First = 1,
  Second = 2,
  Third = 3,
  Fourth = 4,
}

export class InvoicePeriodDto implements IInvoicePeriodDto {
  displayName!: string;
  periodType!: InvoicePeriodType;
  freqInterval!: number;
  freqRecurrence!: string | undefined;
  enabled!: boolean;
  shipperOnlyUsed!: boolean;
  freqRelativeInterval!: FrequencyRelativeInterval;
  cronexpression!: string | undefined;
  isDeleted!: boolean;
  deleterUserId!: number | undefined;
  deletionTime!: moment.Moment | undefined;
  lastModificationTime!: moment.Moment | undefined;
  lastModifierUserId!: number | undefined;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number | undefined;

  constructor(data?: IInvoicePeriodDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.periodType = _data['periodType'];
      this.freqInterval = _data['freqInterval'];
      this.freqRecurrence = _data['freqRecurrence'];
      this.enabled = _data['enabled'];
      this.shipperOnlyUsed = _data['shipperOnlyUsed'];
      this.freqRelativeInterval = _data['freqRelativeInterval'];
      this.cronexpression = _data['cronexpression'];
      this.isDeleted = _data['isDeleted'];
      this.deleterUserId = _data['deleterUserId'];
      this.deletionTime = _data['deletionTime'] ? moment(_data['deletionTime'].toString()) : <any>undefined;
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): InvoicePeriodDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoicePeriodDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['periodType'] = this.periodType;
    data['freqInterval'] = this.freqInterval;
    data['freqRecurrence'] = this.freqRecurrence;
    data['enabled'] = this.enabled;
    data['shipperOnlyUsed'] = this.shipperOnlyUsed;
    data['freqRelativeInterval'] = this.freqRelativeInterval;
    data['cronexpression'] = this.cronexpression;
    data['isDeleted'] = this.isDeleted;
    data['deleterUserId'] = this.deleterUserId;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface IInvoicePeriodDto {
  displayName: string;
  periodType: InvoicePeriodType;
  freqInterval: number;
  freqRecurrence: string | undefined;
  enabled: boolean;
  shipperOnlyUsed: boolean;
  freqRelativeInterval: FrequencyRelativeInterval;
  cronexpression: string | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number | undefined;
}

export class ListResultDtoOfInvoicePeriodDto implements IListResultDtoOfInvoicePeriodDto {
  items!: InvoicePeriodDto[] | undefined;

  constructor(data?: IListResultDtoOfInvoicePeriodDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoicePeriodDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfInvoicePeriodDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfInvoicePeriodDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfInvoicePeriodDto {
  items: InvoicePeriodDto[] | undefined;
}

export class KeyValuePair implements IKeyValuePair {
  key!: string | undefined;
  value!: any | undefined;

  constructor(data?: IKeyValuePair) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data['key'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): KeyValuePair {
    data = typeof data === 'object' ? data : {};
    let result = new KeyValuePair();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['key'] = this.key;
    data['value'] = this.value;
    return data;
  }
}

export interface IKeyValuePair {
  key: string | undefined;
  value: any | undefined;
}

export class PeriodCommonDto implements IPeriodCommonDto {
  weeks!: KeyValuePair[] | undefined;
  months!: KeyValuePair[] | undefined;

  constructor(data?: IPeriodCommonDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['weeks'])) {
        this.weeks = [] as any;
        for (let item of _data['weeks']) this.weeks!.push(KeyValuePair.fromJS(item));
      }
      if (Array.isArray(_data['months'])) {
        this.months = [] as any;
        for (let item of _data['months']) this.months!.push(KeyValuePair.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PeriodCommonDto {
    data = typeof data === 'object' ? data : {};
    let result = new PeriodCommonDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.weeks)) {
      data['weeks'] = [];
      for (let item of this.weeks) data['weeks'].push(item.toJSON());
    }
    if (Array.isArray(this.months)) {
      data['months'] = [];
      for (let item of this.months) data['months'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPeriodCommonDto {
  weeks: KeyValuePair[] | undefined;
  months: KeyValuePair[] | undefined;
}

export class FilterInput implements IFilterInput {
  filter!: string | undefined;
  sorting!: string | undefined;

  constructor(data?: IFilterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.filter = _data['filter'];
      this.sorting = _data['sorting'];
    }
  }

  static fromJS(data: any): FilterInput {
    data = typeof data === 'object' ? data : {};
    let result = new FilterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['filter'] = this.filter;
    data['sorting'] = this.sorting;
    return data;
  }
}

export interface IFilterInput {
  filter: string | undefined;
  sorting: string | undefined;
}

export class InvoicesProformaListDto implements IInvoicesProformaListDto {
  creationTime!: moment.Moment;
  clientName!: string | undefined;
  totalAmount!: number;
  vatAmount!: number;
  id!: number;

  constructor(data?: IInvoicesProformaListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.clientName = _data['clientName'];
      this.totalAmount = _data['totalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): InvoicesProformaListDto {
    data = typeof data === 'object' ? data : {};
    let result = new InvoicesProformaListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['clientName'] = this.clientName;
    data['totalAmount'] = this.totalAmount;
    data['vatAmount'] = this.vatAmount;
    data['id'] = this.id;
    return data;
  }
}

export interface IInvoicesProformaListDto {
  creationTime: moment.Moment;
  clientName: string | undefined;
  totalAmount: number;
  vatAmount: number;
  id: number;
}

export class PagedResultDtoOfInvoicesProformaListDto implements IPagedResultDtoOfInvoicesProformaListDto {
  totalCount!: number;
  items!: InvoicesProformaListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfInvoicesProformaListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoicesProformaListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfInvoicesProformaListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfInvoicesProformaListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfInvoicesProformaListDto {
  totalCount: number;
  items: InvoicesProformaListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
  tenantId!: number | undefined;
  name!: string | undefined;
  displayName!: string | undefined;
  icon!: string | undefined;
  isDisabled!: boolean;
  isRTL!: boolean;
  isDeleted!: boolean;
  deleterUserId!: number | undefined;
  deletionTime!: moment.Moment | undefined;
  lastModificationTime!: moment.Moment | undefined;
  lastModifierUserId!: number | undefined;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number;

  constructor(data?: IApplicationLanguageListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.icon = _data['icon'];
      this.isDisabled = _data['isDisabled'];
      this.isRTL = _data['isRTL'];
      this.isDeleted = _data['isDeleted'];
      this.deleterUserId = _data['deleterUserId'];
      this.deletionTime = _data['deletionTime'] ? moment(_data['deletionTime'].toString()) : <any>undefined;
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ApplicationLanguageListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationLanguageListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['icon'] = this.icon;
    data['isDisabled'] = this.isDisabled;
    data['isRTL'] = this.isRTL;
    data['isDeleted'] = this.isDeleted;
    data['deleterUserId'] = this.deleterUserId;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface IApplicationLanguageListDto {
  tenantId: number | undefined;
  name: string | undefined;
  displayName: string | undefined;
  icon: string | undefined;
  isDisabled: boolean;
  isRTL: boolean;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
  defaultLanguageName!: string | undefined;
  items!: ApplicationLanguageListDto[] | undefined;

  constructor(data?: IGetLanguagesOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.defaultLanguageName = _data['defaultLanguageName'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ApplicationLanguageListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetLanguagesOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetLanguagesOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['defaultLanguageName'] = this.defaultLanguageName;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetLanguagesOutput {
  defaultLanguageName: string | undefined;
  items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
  id!: number | undefined;
  name!: string;
  icon!: string | undefined;
  isEnabled!: boolean;

  constructor(data?: IApplicationLanguageEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.icon = _data['icon'];
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): ApplicationLanguageEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationLanguageEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['icon'] = this.icon;
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface IApplicationLanguageEditDto {
  id: number | undefined;
  name: string;
  icon: string | undefined;
  isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
  value!: string | undefined;
  displayText!: string | undefined;
  isSelected!: boolean;

  constructor(data?: IComboboxItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.displayText = _data['displayText'];
      this.isSelected = _data['isSelected'];
    }
  }

  static fromJS(data: any): ComboboxItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ComboboxItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['displayText'] = this.displayText;
    data['isSelected'] = this.isSelected;
    return data;
  }
}

export interface IComboboxItemDto {
  value: string | undefined;
  displayText: string | undefined;
  isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
  language!: ApplicationLanguageEditDto;
  languageNames!: ComboboxItemDto[] | undefined;
  flags!: ComboboxItemDto[] | undefined;

  constructor(data?: IGetLanguageForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'] ? ApplicationLanguageEditDto.fromJS(_data['language']) : <any>undefined;
      if (Array.isArray(_data['languageNames'])) {
        this.languageNames = [] as any;
        for (let item of _data['languageNames']) this.languageNames!.push(ComboboxItemDto.fromJS(item));
      }
      if (Array.isArray(_data['flags'])) {
        this.flags = [] as any;
        for (let item of _data['flags']) this.flags!.push(ComboboxItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetLanguageForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetLanguageForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language ? this.language.toJSON() : <any>undefined;
    if (Array.isArray(this.languageNames)) {
      data['languageNames'] = [];
      for (let item of this.languageNames) data['languageNames'].push(item.toJSON());
    }
    if (Array.isArray(this.flags)) {
      data['flags'] = [];
      for (let item of this.flags) data['flags'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetLanguageForEditOutput {
  language: ApplicationLanguageEditDto;
  languageNames: ComboboxItemDto[] | undefined;
  flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
  language!: ApplicationLanguageEditDto;

  constructor(data?: ICreateOrUpdateLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.language = new ApplicationLanguageEditDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'] ? ApplicationLanguageEditDto.fromJS(_data['language']) : new ApplicationLanguageEditDto();
    }
  }

  static fromJS(data: any): CreateOrUpdateLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrUpdateLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language ? this.language.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateOrUpdateLanguageInput {
  language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
  name!: string;

  constructor(data?: ISetDefaultLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): SetDefaultLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new SetDefaultLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ISetDefaultLanguageInput {
  name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
  key!: string | undefined;
  baseValue!: string | undefined;
  targetValue!: string | undefined;

  constructor(data?: ILanguageTextListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data['key'];
      this.baseValue = _data['baseValue'];
      this.targetValue = _data['targetValue'];
    }
  }

  static fromJS(data: any): LanguageTextListDto {
    data = typeof data === 'object' ? data : {};
    let result = new LanguageTextListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['key'] = this.key;
    data['baseValue'] = this.baseValue;
    data['targetValue'] = this.targetValue;
    return data;
  }
}

export interface ILanguageTextListDto {
  key: string | undefined;
  baseValue: string | undefined;
  targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
  totalCount!: number;
  items!: LanguageTextListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LanguageTextListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfLanguageTextListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfLanguageTextListDto {
  totalCount: number;
  items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
  languageName!: string;
  sourceName!: string;
  key!: string;
  value!: string;

  constructor(data?: IUpdateLanguageTextInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data['languageName'];
      this.sourceName = _data['sourceName'];
      this.key = _data['key'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): UpdateLanguageTextInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateLanguageTextInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['languageName'] = this.languageName;
    data['sourceName'] = this.sourceName;
    data['key'] = this.key;
    data['value'] = this.value;
    return data;
  }
}

export interface IUpdateLanguageTextInput {
  languageName: string;
  sourceName: string;
  key: string;
  value: string;
}

export class NationalityDto implements INationalityDto {
  name!: string | undefined;
  id!: number;

  constructor(data?: INationalityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): NationalityDto {
    data = typeof data === 'object' ? data : {};
    let result = new NationalityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }
}

export interface INationalityDto {
  name: string | undefined;
  id: number;
}

export class GetNationalityForViewDto implements IGetNationalityForViewDto {
  nationality!: NationalityDto;

  constructor(data?: IGetNationalityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nationality = _data['nationality'] ? NationalityDto.fromJS(_data['nationality']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetNationalityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetNationalityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nationality'] = this.nationality ? this.nationality.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetNationalityForViewDto {
  nationality: NationalityDto;
}

export class PagedResultDtoOfGetNationalityForViewDto implements IPagedResultDtoOfGetNationalityForViewDto {
  totalCount!: number;
  items!: GetNationalityForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetNationalityForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetNationalityForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetNationalityForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetNationalityForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetNationalityForViewDto {
  totalCount: number;
  items: GetNationalityForViewDto[] | undefined;
}

export class CreateOrEditNationalityDto implements ICreateOrEditNationalityDto {
  name!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditNationalityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditNationalityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditNationalityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditNationalityDto {
  name: string;
  id: number | undefined;
}

export class GetNationalityForEditOutput implements IGetNationalityForEditOutput {
  nationality!: CreateOrEditNationalityDto;

  constructor(data?: IGetNationalityForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nationality = _data['nationality'] ? CreateOrEditNationalityDto.fromJS(_data['nationality']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetNationalityForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetNationalityForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nationality'] = this.nationality ? this.nationality.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetNationalityForEditOutput {
  nationality: CreateOrEditNationalityDto;
}

export class NationalityTranslationDto implements INationalityTranslationDto {
  translatedName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: INationalityTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedName = _data['translatedName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): NationalityTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new NationalityTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedName'] = this.translatedName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface INationalityTranslationDto {
  translatedName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetNationalityTranslationForViewDto implements IGetNationalityTranslationForViewDto {
  nationalityTranslation!: NationalityTranslationDto;
  nationalityName!: string | undefined;

  constructor(data?: IGetNationalityTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nationalityTranslation = _data['nationalityTranslation']
        ? NationalityTranslationDto.fromJS(_data['nationalityTranslation'])
        : <any>undefined;
      this.nationalityName = _data['nationalityName'];
    }
  }

  static fromJS(data: any): GetNationalityTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetNationalityTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nationalityTranslation'] = this.nationalityTranslation ? this.nationalityTranslation.toJSON() : <any>undefined;
    data['nationalityName'] = this.nationalityName;
    return data;
  }
}

export interface IGetNationalityTranslationForViewDto {
  nationalityTranslation: NationalityTranslationDto;
  nationalityName: string | undefined;
}

export class PagedResultDtoOfGetNationalityTranslationForViewDto implements IPagedResultDtoOfGetNationalityTranslationForViewDto {
  totalCount!: number;
  items!: GetNationalityTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetNationalityTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetNationalityTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetNationalityTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetNationalityTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetNationalityTranslationForViewDto {
  totalCount: number;
  items: GetNationalityTranslationForViewDto[] | undefined;
}

export class CreateOrEditNationalityTranslationDto implements ICreateOrEditNationalityTranslationDto {
  translatedName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditNationalityTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedName = _data['translatedName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditNationalityTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditNationalityTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedName'] = this.translatedName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditNationalityTranslationDto {
  translatedName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetNationalityTranslationForEditOutput implements IGetNationalityTranslationForEditOutput {
  nationalityTranslation!: CreateOrEditNationalityTranslationDto;
  nationalityName!: string | undefined;

  constructor(data?: IGetNationalityTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nationalityTranslation = _data['nationalityTranslation']
        ? CreateOrEditNationalityTranslationDto.fromJS(_data['nationalityTranslation'])
        : <any>undefined;
      this.nationalityName = _data['nationalityName'];
    }
  }

  static fromJS(data: any): GetNationalityTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetNationalityTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nationalityTranslation'] = this.nationalityTranslation ? this.nationalityTranslation.toJSON() : <any>undefined;
    data['nationalityName'] = this.nationalityName;
    return data;
  }
}

export interface IGetNationalityTranslationForEditOutput {
  nationalityTranslation: CreateOrEditNationalityTranslationDto;
  nationalityName: string | undefined;
}

export class NationalityTranslationNationalityLookupTableDto implements INationalityTranslationNationalityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: INationalityTranslationNationalityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): NationalityTranslationNationalityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new NationalityTranslationNationalityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface INationalityTranslationNationalityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export enum UserNotificationState {
  Unread = 0,
  Read = 1,
}

export class NotificationData implements INotificationData {
  readonly type!: string | undefined;
  properties!: { [key: string]: any } | undefined;

  constructor(data?: INotificationData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).type = _data['type'];
      if (_data['properties']) {
        this.properties = {} as any;
        for (let key in _data['properties']) {
          if (_data['properties'].hasOwnProperty(key)) this.properties![key] = _data['properties'][key];
        }
      }
    }
  }

  static fromJS(data: any): NotificationData {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    if (this.properties) {
      data['properties'] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key)) data['properties'][key] = this.properties[key];
      }
    }
    return data;
  }
}

export interface INotificationData {
  type: string | undefined;
  properties: { [key: string]: any } | undefined;
}

export enum NotificationSeverity {
  Info = 0,
  Success = 1,
  Warn = 2,
  Error = 3,
  Fatal = 4,
}

export class TenantNotification implements ITenantNotification {
  tenantId!: number | undefined;
  notificationName!: string | undefined;
  data!: NotificationData;
  entityType!: string | undefined;
  entityTypeName!: string | undefined;
  entityId!: any | undefined;
  severity!: NotificationSeverity;
  creationTime!: moment.Moment;
  id!: string;

  constructor(data?: ITenantNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.notificationName = _data['notificationName'];
      this.data = _data['data'] ? NotificationData.fromJS(_data['data']) : <any>undefined;
      this.entityType = _data['entityType'];
      this.entityTypeName = _data['entityTypeName'];
      this.entityId = _data['entityId'];
      this.severity = _data['severity'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantNotification {
    data = typeof data === 'object' ? data : {};
    let result = new TenantNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['notificationName'] = this.notificationName;
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['entityType'] = this.entityType;
    data['entityTypeName'] = this.entityTypeName;
    data['entityId'] = this.entityId;
    data['severity'] = this.severity;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface ITenantNotification {
  tenantId: number | undefined;
  notificationName: string | undefined;
  data: NotificationData;
  entityType: string | undefined;
  entityTypeName: string | undefined;
  entityId: any | undefined;
  severity: NotificationSeverity;
  creationTime: moment.Moment;
  id: string;
}

export class UserNotification implements IUserNotification {
  tenantId!: number | undefined;
  userId!: number;
  state!: UserNotificationState;
  notification!: TenantNotification;
  id!: string;

  constructor(data?: IUserNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
      this.state = _data['state'];
      this.notification = _data['notification'] ? TenantNotification.fromJS(_data['notification']) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserNotification {
    data = typeof data === 'object' ? data : {};
    let result = new UserNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    data['state'] = this.state;
    data['notification'] = this.notification ? this.notification.toJSON() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IUserNotification {
  tenantId: number | undefined;
  userId: number;
  state: UserNotificationState;
  notification: TenantNotification;
  id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
  unreadCount!: number;
  totalCount!: number;
  items!: UserNotification[] | undefined;

  constructor(data?: IGetNotificationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.unreadCount = _data['unreadCount'];
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserNotification.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetNotificationsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetNotificationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['unreadCount'] = this.unreadCount;
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetNotificationsOutput {
  unreadCount: number;
  totalCount: number;
  items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
  id!: string;

  constructor(data?: IEntityDtoOfGuid) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDtoOfGuid {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDtoOfGuid();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDtoOfGuid {
  id: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
  displayName!: string | undefined;
  description!: string | undefined;
  name!: string;
  isSubscribed!: boolean;

  constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.name = _data['name'];
      this.isSubscribed = _data['isSubscribed'];
    }
  }

  static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationSubscriptionWithDisplayNameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['name'] = this.name;
    data['isSubscribed'] = this.isSubscribed;
    return data;
  }
}

export interface INotificationSubscriptionWithDisplayNameDto {
  displayName: string | undefined;
  description: string | undefined;
  name: string;
  isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
  receiveNotifications!: boolean;
  notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

  constructor(data?: IGetNotificationSettingsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.receiveNotifications = _data['receiveNotifications'];
      if (Array.isArray(_data['notifications'])) {
        this.notifications = [] as any;
        for (let item of _data['notifications']) this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetNotificationSettingsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetNotificationSettingsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['receiveNotifications'] = this.receiveNotifications;
    if (Array.isArray(this.notifications)) {
      data['notifications'] = [];
      for (let item of this.notifications) data['notifications'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetNotificationSettingsOutput {
  receiveNotifications: boolean;
  notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
  name!: string;
  isSubscribed!: boolean;

  constructor(data?: INotificationSubscriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.isSubscribed = _data['isSubscribed'];
    }
  }

  static fromJS(data: any): NotificationSubscriptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationSubscriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['isSubscribed'] = this.isSubscribed;
    return data;
  }
}

export interface INotificationSubscriptionDto {
  name: string;
  isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
  receiveNotifications!: boolean;
  notifications!: NotificationSubscriptionDto[] | undefined;

  constructor(data?: IUpdateNotificationSettingsInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.receiveNotifications = _data['receiveNotifications'];
      if (Array.isArray(_data['notifications'])) {
        this.notifications = [] as any;
        for (let item of _data['notifications']) this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdateNotificationSettingsInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateNotificationSettingsInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['receiveNotifications'] = this.receiveNotifications;
    if (Array.isArray(this.notifications)) {
      data['notifications'] = [];
      for (let item of this.notifications) data['notifications'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateNotificationSettingsInput {
  receiveNotifications: boolean;
  notifications: NotificationSubscriptionDto[] | undefined;
}

export class OfferDto implements IOfferDto {
  displayName!: string | undefined;
  description!: string | undefined;
  price!: number;
  trucksTypeId!: number | undefined;
  trailerTypeId!: number | undefined;
  goodCategoryId!: number | undefined;
  routeId!: number | undefined;
  id!: number;

  constructor(data?: IOfferDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.trailerTypeId = _data['trailerTypeId'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.routeId = _data['routeId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): OfferDto {
    data = typeof data === 'object' ? data : {};
    let result = new OfferDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['price'] = this.price;
    data['trucksTypeId'] = this.trucksTypeId;
    data['trailerTypeId'] = this.trailerTypeId;
    data['goodCategoryId'] = this.goodCategoryId;
    data['routeId'] = this.routeId;
    data['id'] = this.id;
    return data;
  }
}

export interface IOfferDto {
  displayName: string | undefined;
  description: string | undefined;
  price: number;
  trucksTypeId: number | undefined;
  trailerTypeId: number | undefined;
  goodCategoryId: number | undefined;
  routeId: number | undefined;
  id: number;
}

export class GetOfferForViewDto implements IGetOfferForViewDto {
  offer!: OfferDto;
  trucksTypeDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  goodCategoryDisplayName!: string | undefined;
  routeDisplayName!: string | undefined;

  constructor(data?: IGetOfferForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.offer = _data['offer'] ? OfferDto.fromJS(_data['offer']) : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.goodCategoryDisplayName = _data['goodCategoryDisplayName'];
      this.routeDisplayName = _data['routeDisplayName'];
    }
  }

  static fromJS(data: any): GetOfferForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetOfferForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['offer'] = this.offer ? this.offer.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['goodCategoryDisplayName'] = this.goodCategoryDisplayName;
    data['routeDisplayName'] = this.routeDisplayName;
    return data;
  }
}

export interface IGetOfferForViewDto {
  offer: OfferDto;
  trucksTypeDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  goodCategoryDisplayName: string | undefined;
  routeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetOfferForViewDto implements IPagedResultDtoOfGetOfferForViewDto {
  totalCount!: number;
  items!: GetOfferForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetOfferForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetOfferForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetOfferForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetOfferForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetOfferForViewDto {
  totalCount: number;
  items: GetOfferForViewDto[] | undefined;
}

export class CreateOrEditOfferDto implements ICreateOrEditOfferDto {
  displayName!: string | undefined;
  description!: string | undefined;
  price!: number;
  trucksTypeId!: number | undefined;
  trailerTypeId!: number | undefined;
  goodCategoryId!: number | undefined;
  routeId!: number | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditOfferDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.price = _data['price'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.trailerTypeId = _data['trailerTypeId'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.routeId = _data['routeId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditOfferDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditOfferDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['price'] = this.price;
    data['trucksTypeId'] = this.trucksTypeId;
    data['trailerTypeId'] = this.trailerTypeId;
    data['goodCategoryId'] = this.goodCategoryId;
    data['routeId'] = this.routeId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditOfferDto {
  displayName: string | undefined;
  description: string | undefined;
  price: number;
  trucksTypeId: number | undefined;
  trailerTypeId: number | undefined;
  goodCategoryId: number | undefined;
  routeId: number | undefined;
  id: number | undefined;
}

export class GetOfferForEditOutput implements IGetOfferForEditOutput {
  offer!: CreateOrEditOfferDto;
  trucksTypeDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  goodCategoryDisplayName!: string | undefined;
  routeDisplayName!: string | undefined;

  constructor(data?: IGetOfferForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.offer = _data['offer'] ? CreateOrEditOfferDto.fromJS(_data['offer']) : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.goodCategoryDisplayName = _data['goodCategoryDisplayName'];
      this.routeDisplayName = _data['routeDisplayName'];
    }
  }

  static fromJS(data: any): GetOfferForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetOfferForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['offer'] = this.offer ? this.offer.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['goodCategoryDisplayName'] = this.goodCategoryDisplayName;
    data['routeDisplayName'] = this.routeDisplayName;
    return data;
  }
}

export interface IGetOfferForEditOutput {
  offer: CreateOrEditOfferDto;
  trucksTypeDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  goodCategoryDisplayName: string | undefined;
  routeDisplayName: string | undefined;
}

export class TrucksTypeSelectItemDto implements ITrucksTypeSelectItemDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: ITrucksTypeSelectItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): TrucksTypeSelectItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrucksTypeSelectItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ITrucksTypeSelectItemDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class OfferTrailerTypeLookupTableDto implements IOfferTrailerTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IOfferTrailerTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): OfferTrailerTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new OfferTrailerTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IOfferTrailerTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class OfferRouteLookupTableDto implements IOfferRouteLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IOfferRouteLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): OfferRouteLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new OfferRouteLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IOfferRouteLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
  parentId!: number | undefined;
  code!: string | undefined;
  displayName!: string | undefined;
  memberCount!: number;
  roleCount!: number;
  lastModificationTime!: moment.Moment | undefined;
  lastModifierUserId!: number | undefined;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number;

  constructor(data?: IOrganizationUnitDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentId = _data['parentId'];
      this.code = _data['code'];
      this.displayName = _data['displayName'];
      this.memberCount = _data['memberCount'];
      this.roleCount = _data['roleCount'];
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): OrganizationUnitDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrganizationUnitDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentId'] = this.parentId;
    data['code'] = this.code;
    data['displayName'] = this.displayName;
    data['memberCount'] = this.memberCount;
    data['roleCount'] = this.roleCount;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface IOrganizationUnitDto {
  parentId: number | undefined;
  code: string | undefined;
  displayName: string | undefined;
  memberCount: number;
  roleCount: number;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
  items!: OrganizationUnitDto[] | undefined;

  constructor(data?: IListResultDtoOfOrganizationUnitDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(OrganizationUnitDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfOrganizationUnitDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfOrganizationUnitDto {
  items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
  name!: string | undefined;
  surname!: string | undefined;
  userName!: string | undefined;
  emailAddress!: string | undefined;
  profilePictureId!: string | undefined;
  addedTime!: moment.Moment;
  id!: number;

  constructor(data?: IOrganizationUnitUserListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.profilePictureId = _data['profilePictureId'];
      this.addedTime = _data['addedTime'] ? moment(_data['addedTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): OrganizationUnitUserListDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrganizationUnitUserListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['profilePictureId'] = this.profilePictureId;
    data['addedTime'] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IOrganizationUnitUserListDto {
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  profilePictureId: string | undefined;
  addedTime: moment.Moment;
  id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
  totalCount!: number;
  items!: OrganizationUnitUserListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(OrganizationUnitUserListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfOrganizationUnitUserListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
  totalCount: number;
  items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
  displayName!: string | undefined;
  name!: string | undefined;
  addedTime!: moment.Moment;
  id!: number;

  constructor(data?: IOrganizationUnitRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.name = _data['name'];
      this.addedTime = _data['addedTime'] ? moment(_data['addedTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): OrganizationUnitRoleListDto {
    data = typeof data === 'object' ? data : {};
    let result = new OrganizationUnitRoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['name'] = this.name;
    data['addedTime'] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IOrganizationUnitRoleListDto {
  displayName: string | undefined;
  name: string | undefined;
  addedTime: moment.Moment;
  id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
  totalCount!: number;
  items!: OrganizationUnitRoleListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
  totalCount: number;
  items: OrganizationUnitRoleListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
  parentId!: number | undefined;
  displayName!: string;

  constructor(data?: ICreateOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentId = _data['parentId'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): CreateOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentId'] = this.parentId;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ICreateOrganizationUnitInput {
  parentId: number | undefined;
  displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
  id!: number;
  displayName!: string;

  constructor(data?: IUpdateOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): UpdateOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IUpdateOrganizationUnitInput {
  id: number;
  displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
  id!: number;
  newParentId!: number | undefined;

  constructor(data?: IMoveOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.newParentId = _data['newParentId'];
    }
  }

  static fromJS(data: any): MoveOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new MoveOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['newParentId'] = this.newParentId;
    return data;
  }
}

export interface IMoveOrganizationUnitInput {
  id: number;
  newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
  userIds!: number[] | undefined;
  organizationUnitId!: number;

  constructor(data?: IUsersToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['userIds'])) {
        this.userIds = [] as any;
        for (let item of _data['userIds']) this.userIds!.push(item);
      }
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): UsersToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new UsersToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.userIds)) {
      data['userIds'] = [];
      for (let item of this.userIds) data['userIds'].push(item);
    }
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IUsersToOrganizationUnitInput {
  userIds: number[] | undefined;
  organizationUnitId: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
  roleIds!: number[] | undefined;
  organizationUnitId!: number;

  constructor(data?: IRolesToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['roleIds'])) {
        this.roleIds = [] as any;
        for (let item of _data['roleIds']) this.roleIds!.push(item);
      }
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): RolesToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new RolesToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.roleIds)) {
      data['roleIds'] = [];
      for (let item of this.roleIds) data['roleIds'].push(item);
    }
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IRolesToOrganizationUnitInput {
  roleIds: number[] | undefined;
  organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
  organizationUnitId!: number;
  maxResultCount!: number;
  skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IFindOrganizationUnitUsersInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.organizationUnitId = _data['organizationUnitId'];
      this.maxResultCount = _data['maxResultCount'];
      this.skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): FindOrganizationUnitUsersInput {
    data = typeof data === 'object' ? data : {};
    let result = new FindOrganizationUnitUsersInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['organizationUnitId'] = this.organizationUnitId;
    data['maxResultCount'] = this.maxResultCount;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IFindOrganizationUnitUsersInput {
  organizationUnitId: number;
  maxResultCount: number;
  skipCount: number;
  filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
  organizationUnitId!: number;
  maxResultCount!: number;
  skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IFindOrganizationUnitRolesInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.organizationUnitId = _data['organizationUnitId'];
      this.maxResultCount = _data['maxResultCount'];
      this.skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): FindOrganizationUnitRolesInput {
    data = typeof data === 'object' ? data : {};
    let result = new FindOrganizationUnitRolesInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['organizationUnitId'] = this.organizationUnitId;
    data['maxResultCount'] = this.maxResultCount;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IFindOrganizationUnitRolesInput {
  organizationUnitId: number;
  maxResultCount: number;
  skipCount: number;
  filter: string | undefined;
}

export class PackingTypeDto implements IPackingTypeDto {
  displayName!: string | undefined;
  description!: string | undefined;
  id!: number;

  constructor(data?: IPackingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PackingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PackingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface IPackingTypeDto {
  displayName: string | undefined;
  description: string | undefined;
  id: number;
}

export class GetPackingTypeForViewDto implements IGetPackingTypeForViewDto {
  packingType!: PackingTypeDto;

  constructor(data?: IGetPackingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.packingType = _data['packingType'] ? PackingTypeDto.fromJS(_data['packingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPackingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetPackingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['packingType'] = this.packingType ? this.packingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPackingTypeForViewDto {
  packingType: PackingTypeDto;
}

export class PagedResultDtoOfGetPackingTypeForViewDto implements IPagedResultDtoOfGetPackingTypeForViewDto {
  totalCount!: number;
  items!: GetPackingTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetPackingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetPackingTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetPackingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetPackingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetPackingTypeForViewDto {
  totalCount: number;
  items: GetPackingTypeForViewDto[] | undefined;
}

export class CreateOrEditPackingTypeDto implements ICreateOrEditPackingTypeDto {
  displayName!: string;
  description!: string | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditPackingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditPackingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPackingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditPackingTypeDto {
  displayName: string;
  description: string | undefined;
  id: number | undefined;
}

export class GetPackingTypeForEditOutput implements IGetPackingTypeForEditOutput {
  packingType!: CreateOrEditPackingTypeDto;

  constructor(data?: IGetPackingTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.packingType = _data['packingType'] ? CreateOrEditPackingTypeDto.fromJS(_data['packingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPackingTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPackingTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['packingType'] = this.packingType ? this.packingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPackingTypeForEditOutput {
  packingType: CreateOrEditPackingTypeDto;
}

export class PayloadMaxWeightDto implements IPayloadMaxWeightDto {
  displayName!: string | undefined;
  maxWeight!: number;
  id!: number;

  constructor(data?: IPayloadMaxWeightDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.maxWeight = _data['maxWeight'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PayloadMaxWeightDto {
    data = typeof data === 'object' ? data : {};
    let result = new PayloadMaxWeightDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['maxWeight'] = this.maxWeight;
    data['id'] = this.id;
    return data;
  }
}

export interface IPayloadMaxWeightDto {
  displayName: string | undefined;
  maxWeight: number;
  id: number;
}

export class GetPayloadMaxWeightForViewDto implements IGetPayloadMaxWeightForViewDto {
  payloadMaxWeight!: PayloadMaxWeightDto;

  constructor(data?: IGetPayloadMaxWeightForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.payloadMaxWeight = _data['payloadMaxWeight'] ? PayloadMaxWeightDto.fromJS(_data['payloadMaxWeight']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPayloadMaxWeightForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetPayloadMaxWeightForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payloadMaxWeight'] = this.payloadMaxWeight ? this.payloadMaxWeight.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPayloadMaxWeightForViewDto {
  payloadMaxWeight: PayloadMaxWeightDto;
}

export class PagedResultDtoOfGetPayloadMaxWeightForViewDto implements IPagedResultDtoOfGetPayloadMaxWeightForViewDto {
  totalCount!: number;
  items!: GetPayloadMaxWeightForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetPayloadMaxWeightForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetPayloadMaxWeightForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetPayloadMaxWeightForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetPayloadMaxWeightForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetPayloadMaxWeightForViewDto {
  totalCount: number;
  items: GetPayloadMaxWeightForViewDto[] | undefined;
}

export class CreateOrEditPayloadMaxWeightDto implements ICreateOrEditPayloadMaxWeightDto {
  displayName!: string;
  maxWeight!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditPayloadMaxWeightDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.maxWeight = _data['maxWeight'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditPayloadMaxWeightDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPayloadMaxWeightDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['maxWeight'] = this.maxWeight;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditPayloadMaxWeightDto {
  displayName: string;
  maxWeight: number;
  id: number | undefined;
}

export class GetPayloadMaxWeightForEditOutput implements IGetPayloadMaxWeightForEditOutput {
  payloadMaxWeight!: CreateOrEditPayloadMaxWeightDto;

  constructor(data?: IGetPayloadMaxWeightForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.payloadMaxWeight = _data['payloadMaxWeight'] ? CreateOrEditPayloadMaxWeightDto.fromJS(_data['payloadMaxWeight']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPayloadMaxWeightForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPayloadMaxWeightForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['payloadMaxWeight'] = this.payloadMaxWeight ? this.payloadMaxWeight.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPayloadMaxWeightForEditOutput {
  payloadMaxWeight: CreateOrEditPayloadMaxWeightDto;
}

export class EditionSelectDto implements IEditionSelectDto {
  id!: number;
  name!: string | undefined;
  displayName!: string | undefined;
  expiringEditionId!: number | undefined;
  dailyPrice!: number | undefined;
  weeklyPrice!: number | undefined;
  monthlyPrice!: number | undefined;
  annualPrice!: number | undefined;
  trialDayCount!: number | undefined;
  waitingDayAfterExpire!: number | undefined;
  isFree!: boolean;
  additionalData!: AdditionalData | undefined;

  constructor(data?: IEditionSelectDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.expiringEditionId = _data['expiringEditionId'];
      this.dailyPrice = _data['dailyPrice'];
      this.weeklyPrice = _data['weeklyPrice'];
      this.monthlyPrice = _data['monthlyPrice'];
      this.annualPrice = _data['annualPrice'];
      this.trialDayCount = _data['trialDayCount'];
      this.waitingDayAfterExpire = _data['waitingDayAfterExpire'];
      this.isFree = _data['isFree'];
      this.additionalData = _data['additionalData'] ? AdditionalData.fromJS(_data['additionalData']) : <any>undefined;
    }
  }

  static fromJS(data: any): EditionSelectDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionSelectDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['expiringEditionId'] = this.expiringEditionId;
    data['dailyPrice'] = this.dailyPrice;
    data['weeklyPrice'] = this.weeklyPrice;
    data['monthlyPrice'] = this.monthlyPrice;
    data['annualPrice'] = this.annualPrice;
    data['trialDayCount'] = this.trialDayCount;
    data['waitingDayAfterExpire'] = this.waitingDayAfterExpire;
    data['isFree'] = this.isFree;
    data['additionalData'] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
    return data;
  }
}

export interface IEditionSelectDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  expiringEditionId: number | undefined;
  dailyPrice: number | undefined;
  weeklyPrice: number | undefined;
  monthlyPrice: number | undefined;
  annualPrice: number | undefined;
  trialDayCount: number | undefined;
  waitingDayAfterExpire: number | undefined;
  isFree: boolean;
  additionalData: AdditionalData | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
  edition!: EditionSelectDto;
  additionalPrice!: number;

  constructor(data?: IPaymentInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'] ? EditionSelectDto.fromJS(_data['edition']) : <any>undefined;
      this.additionalPrice = _data['additionalPrice'];
    }
  }

  static fromJS(data: any): PaymentInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    data['additionalPrice'] = this.additionalPrice;
    return data;
  }
}

export interface IPaymentInfoDto {
  edition: EditionSelectDto;
  additionalPrice: number;
}

export enum EditionPaymentType {
  NewRegistration = 0,
  BuyNow = 1,
  Upgrade = 2,
  Extend = 3,
}

export enum PaymentPeriodType {
  Daily = 1,
  Weekly = 7,
  Monthly = 30,
  Annual = 365,
}

export enum SubscriptionPaymentGatewayType {
  Paypal = 1,
  Stripe = 2,
}

export class CreatePaymentDto implements ICreatePaymentDto {
  editionId!: number;
  editionPaymentType!: EditionPaymentType;
  paymentPeriodType!: PaymentPeriodType;
  subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
  recurringPaymentEnabled!: boolean;
  successUrl!: string | undefined;
  errorUrl!: string | undefined;

  constructor(data?: ICreatePaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.editionId = _data['editionId'];
      this.editionPaymentType = _data['editionPaymentType'];
      this.paymentPeriodType = _data['paymentPeriodType'];
      this.subscriptionPaymentGatewayType = _data['subscriptionPaymentGatewayType'];
      this.recurringPaymentEnabled = _data['recurringPaymentEnabled'];
      this.successUrl = _data['successUrl'];
      this.errorUrl = _data['errorUrl'];
    }
  }

  static fromJS(data: any): CreatePaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePaymentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['editionId'] = this.editionId;
    data['editionPaymentType'] = this.editionPaymentType;
    data['paymentPeriodType'] = this.paymentPeriodType;
    data['subscriptionPaymentGatewayType'] = this.subscriptionPaymentGatewayType;
    data['recurringPaymentEnabled'] = this.recurringPaymentEnabled;
    data['successUrl'] = this.successUrl;
    data['errorUrl'] = this.errorUrl;
    return data;
  }
}

export interface ICreatePaymentDto {
  editionId: number;
  editionPaymentType: EditionPaymentType;
  paymentPeriodType: PaymentPeriodType;
  subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
  recurringPaymentEnabled: boolean;
  successUrl: string | undefined;
  errorUrl: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
  paymentId!: string | undefined;
  gateway!: SubscriptionPaymentGatewayType;

  constructor(data?: ICancelPaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentId = _data['paymentId'];
      this.gateway = _data['gateway'];
    }
  }

  static fromJS(data: any): CancelPaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CancelPaymentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentId'] = this.paymentId;
    data['gateway'] = this.gateway;
    return data;
  }
}

export interface ICancelPaymentDto {
  paymentId: string | undefined;
  gateway: SubscriptionPaymentGatewayType;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
  gateway!: string | undefined;
  amount!: number;
  editionId!: number;
  dayCount!: number;
  paymentPeriodType!: string | undefined;
  externalPaymentId!: string | undefined;
  payerId!: string | undefined;
  status!: string | undefined;
  editionDisplayName!: string | undefined;
  tenantId!: number;
  invoiceNo!: string | undefined;
  lastModificationTime!: moment.Moment | undefined;
  lastModifierUserId!: number | undefined;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number;

  constructor(data?: ISubscriptionPaymentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gateway = _data['gateway'];
      this.amount = _data['amount'];
      this.editionId = _data['editionId'];
      this.dayCount = _data['dayCount'];
      this.paymentPeriodType = _data['paymentPeriodType'];
      this.externalPaymentId = _data['externalPaymentId'];
      this.payerId = _data['payerId'];
      this.status = _data['status'];
      this.editionDisplayName = _data['editionDisplayName'];
      this.tenantId = _data['tenantId'];
      this.invoiceNo = _data['invoiceNo'];
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubscriptionPaymentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionPaymentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['gateway'] = this.gateway;
    data['amount'] = this.amount;
    data['editionId'] = this.editionId;
    data['dayCount'] = this.dayCount;
    data['paymentPeriodType'] = this.paymentPeriodType;
    data['externalPaymentId'] = this.externalPaymentId;
    data['payerId'] = this.payerId;
    data['status'] = this.status;
    data['editionDisplayName'] = this.editionDisplayName;
    data['tenantId'] = this.tenantId;
    data['invoiceNo'] = this.invoiceNo;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface ISubscriptionPaymentListDto {
  gateway: string | undefined;
  amount: number;
  editionId: number;
  dayCount: number;
  paymentPeriodType: string | undefined;
  externalPaymentId: string | undefined;
  payerId: string | undefined;
  status: string | undefined;
  editionDisplayName: string | undefined;
  tenantId: number;
  invoiceNo: string | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
  totalCount!: number;
  items!: SubscriptionPaymentListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubscriptionPaymentListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfSubscriptionPaymentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
  totalCount: number;
  items: SubscriptionPaymentListDto[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
  gatewayType!: SubscriptionPaymentGatewayType;
  supportsRecurringPayments!: boolean;

  constructor(data?: IPaymentGatewayModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gatewayType = _data['gatewayType'];
      this.supportsRecurringPayments = _data['supportsRecurringPayments'];
    }
  }

  static fromJS(data: any): PaymentGatewayModel {
    data = typeof data === 'object' ? data : {};
    let result = new PaymentGatewayModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['gatewayType'] = this.gatewayType;
    data['supportsRecurringPayments'] = this.supportsRecurringPayments;
    return data;
  }
}

export interface IPaymentGatewayModel {
  gatewayType: SubscriptionPaymentGatewayType;
  supportsRecurringPayments: boolean;
}

export enum SubscriptionPaymentStatus {
  NotPaid = 1,
  Paid = 2,
  Failed = 3,
  Cancelled = 4,
  Completed = 5,
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
  description!: string | undefined;
  gateway!: SubscriptionPaymentGatewayType;
  amount!: number;
  editionId!: number;
  tenantId!: number;
  dayCount!: number;
  paymentPeriodType!: PaymentPeriodType;
  paymentId!: string | undefined;
  payerId!: string | undefined;
  editionDisplayName!: string | undefined;
  invoiceNo!: number;
  status!: SubscriptionPaymentStatus;
  isRecurring!: boolean;
  externalPaymentId!: string | undefined;
  successUrl!: string | undefined;
  errorUrl!: string | undefined;
  editionPaymentType!: EditionPaymentType;
  id!: number;

  constructor(data?: ISubscriptionPaymentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.gateway = _data['gateway'];
      this.amount = _data['amount'];
      this.editionId = _data['editionId'];
      this.tenantId = _data['tenantId'];
      this.dayCount = _data['dayCount'];
      this.paymentPeriodType = _data['paymentPeriodType'];
      this.paymentId = _data['paymentId'];
      this.payerId = _data['payerId'];
      this.editionDisplayName = _data['editionDisplayName'];
      this.invoiceNo = _data['invoiceNo'];
      this.status = _data['status'];
      this.isRecurring = _data['isRecurring'];
      this.externalPaymentId = _data['externalPaymentId'];
      this.successUrl = _data['successUrl'];
      this.errorUrl = _data['errorUrl'];
      this.editionPaymentType = _data['editionPaymentType'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubscriptionPaymentDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubscriptionPaymentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['gateway'] = this.gateway;
    data['amount'] = this.amount;
    data['editionId'] = this.editionId;
    data['tenantId'] = this.tenantId;
    data['dayCount'] = this.dayCount;
    data['paymentPeriodType'] = this.paymentPeriodType;
    data['paymentId'] = this.paymentId;
    data['payerId'] = this.payerId;
    data['editionDisplayName'] = this.editionDisplayName;
    data['invoiceNo'] = this.invoiceNo;
    data['status'] = this.status;
    data['isRecurring'] = this.isRecurring;
    data['externalPaymentId'] = this.externalPaymentId;
    data['successUrl'] = this.successUrl;
    data['errorUrl'] = this.errorUrl;
    data['editionPaymentType'] = this.editionPaymentType;
    data['id'] = this.id;
    return data;
  }
}

export interface ISubscriptionPaymentDto {
  description: string | undefined;
  gateway: SubscriptionPaymentGatewayType;
  amount: number;
  editionId: number;
  tenantId: number;
  dayCount: number;
  paymentPeriodType: PaymentPeriodType;
  paymentId: string | undefined;
  payerId: string | undefined;
  editionDisplayName: string | undefined;
  invoiceNo: number;
  status: SubscriptionPaymentStatus;
  isRecurring: boolean;
  externalPaymentId: string | undefined;
  successUrl: string | undefined;
  errorUrl: string | undefined;
  editionPaymentType: EditionPaymentType;
  id: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
  clientId!: string | undefined;
  demoUsername!: string | undefined;
  demoPassword!: string | undefined;

  constructor(data?: IPayPalConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data['clientId'];
      this.demoUsername = _data['demoUsername'];
      this.demoPassword = _data['demoPassword'];
    }
  }

  static fromJS(data: any): PayPalConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new PayPalConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientId'] = this.clientId;
    data['demoUsername'] = this.demoUsername;
    data['demoPassword'] = this.demoPassword;
    return data;
  }
}

export interface IPayPalConfigurationDto {
  clientId: string | undefined;
  demoUsername: string | undefined;
  demoPassword: string | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
  level!: number;
  parentName!: string | undefined;
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;
  isGrantedByDefault!: boolean;

  constructor(data?: IFlatPermissionWithLevelDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.level = _data['level'];
      this.parentName = _data['parentName'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.isGrantedByDefault = _data['isGrantedByDefault'];
    }
  }

  static fromJS(data: any): FlatPermissionWithLevelDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatPermissionWithLevelDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['level'] = this.level;
    data['parentName'] = this.parentName;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['isGrantedByDefault'] = this.isGrantedByDefault;
    return data;
  }
}

export interface IFlatPermissionWithLevelDto {
  level: number;
  parentName: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
  items!: FlatPermissionWithLevelDto[] | undefined;

  constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfFlatPermissionWithLevelDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
  items: FlatPermissionWithLevelDto[] | undefined;
}

export class PickingTypeDto implements IPickingTypeDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IPickingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PickingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PickingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IPickingTypeDto {
  displayName: string | undefined;
  id: number;
}

export class GetPickingTypeForViewDto implements IGetPickingTypeForViewDto {
  pickingType!: PickingTypeDto;

  constructor(data?: IGetPickingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pickingType = _data['pickingType'] ? PickingTypeDto.fromJS(_data['pickingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPickingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetPickingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pickingType'] = this.pickingType ? this.pickingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPickingTypeForViewDto {
  pickingType: PickingTypeDto;
}

export class PagedResultDtoOfGetPickingTypeForViewDto implements IPagedResultDtoOfGetPickingTypeForViewDto {
  totalCount!: number;
  items!: GetPickingTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetPickingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetPickingTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetPickingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetPickingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetPickingTypeForViewDto {
  totalCount: number;
  items: GetPickingTypeForViewDto[] | undefined;
}

export class CreateOrEditPickingTypeDto implements ICreateOrEditPickingTypeDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditPickingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditPickingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPickingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditPickingTypeDto {
  displayName: string;
  id: number | undefined;
}

export class GetPickingTypeForEditOutput implements IGetPickingTypeForEditOutput {
  pickingType!: CreateOrEditPickingTypeDto;

  constructor(data?: IGetPickingTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pickingType = _data['pickingType'] ? CreateOrEditPickingTypeDto.fromJS(_data['pickingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPickingTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPickingTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pickingType'] = this.pickingType ? this.pickingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPickingTypeForEditOutput {
  pickingType: CreateOrEditPickingTypeDto;
}

export class PlateTypeDto implements IPlateTypeDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IPlateTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PlateTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PlateTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IPlateTypeDto {
  displayName: string | undefined;
  id: number;
}

export class PagedResultDtoOfPlateTypeDto implements IPagedResultDtoOfPlateTypeDto {
  totalCount!: number;
  items!: PlateTypeDto[] | undefined;

  constructor(data?: IPagedResultDtoOfPlateTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PlateTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfPlateTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfPlateTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfPlateTypeDto {
  totalCount: number;
  items: PlateTypeDto[] | undefined;
}

export class GetPlateTypeForViewDto implements IGetPlateTypeForViewDto {
  plateType!: PlateTypeDto;

  constructor(data?: IGetPlateTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.plateType = _data['plateType'] ? PlateTypeDto.fromJS(_data['plateType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPlateTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetPlateTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['plateType'] = this.plateType ? this.plateType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPlateTypeForViewDto {
  plateType: PlateTypeDto;
}

export class PlateTypeTranslationDto implements IPlateTypeTranslationDto {
  displayName!: string | undefined;
  language!: string | undefined;
  languageDisplayName!: string | undefined;
  icon!: string | undefined;

  constructor(data?: IPlateTypeTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.language = _data['language'];
      this.languageDisplayName = _data['languageDisplayName'];
      this.icon = _data['icon'];
    }
  }

  static fromJS(data: any): PlateTypeTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new PlateTypeTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['language'] = this.language;
    data['languageDisplayName'] = this.languageDisplayName;
    data['icon'] = this.icon;
    return data;
  }
}

export interface IPlateTypeTranslationDto {
  displayName: string | undefined;
  language: string | undefined;
  languageDisplayName: string | undefined;
  icon: string | undefined;
}

export class CreateOrEditPlateTypeDto implements ICreateOrEditPlateTypeDto {
  translations!: PlateTypeTranslationDto[] | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditPlateTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(PlateTypeTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditPlateTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPlateTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditPlateTypeDto {
  translations: PlateTypeTranslationDto[] | undefined;
  id: number | undefined;
}

export class GetPlateTypeForEditOutput implements IGetPlateTypeForEditOutput {
  plateType!: CreateOrEditPlateTypeDto;

  constructor(data?: IGetPlateTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.plateType = _data['plateType'] ? CreateOrEditPlateTypeDto.fromJS(_data['plateType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPlateTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPlateTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['plateType'] = this.plateType ? this.plateType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPlateTypeForEditOutput {
  plateType: CreateOrEditPlateTypeDto;
}

export enum Ordinates {
  None = 0,
  X = 1,
  Spatial1 = 2,
  Y = 3,
  Spatial2 = 4,
  XY = 7,
  Spatial3 = 8,
  Z = 16,
  XYZ = 32,
  Spatial4 = 64,
  Spatial5 = 128,
  Spatial6 = 256,
  Spatial7 = 512,
  Spatial8 = 1024,
  Spatial9 = 2048,
  Spatial10 = 4096,
  Spatial11 = 8192,
  Spatial12 = 16384,
  Spatial13 = 32768,
  Spatial14 = 65535,
  Spatial15 = 65536,
  Spatial16 = 65539,
  AllSpatialOrdinates = 65543,
  Measure1 = 131072,
  M = 262144,
  XYM = 524288,
  XYZM = 1048576,
  Measure2 = 2097152,
  Measure3 = 4194304,
  Measure4 = 8388608,
  Measure5 = 16777216,
  Measure6 = 33554432,
  Measure7 = 67108864,
  Measure8 = 134217728,
  Measure9 = 268435456,
  Measure10 = 536870912,
  Measure11 = 1073741824,
  Measure12 = -2147483648,
  Measure13 = -65536,
  Measure14 = -1,
}

export class CoordinateSequence implements ICoordinateSequence {
  readonly dimension!: number;
  readonly measures!: number;
  readonly spatial!: number;
  ordinates!: Ordinates;
  readonly hasZ!: boolean;
  readonly hasM!: boolean;
  readonly zOrdinateIndex!: number;
  readonly mOrdinateIndex!: number;
  readonly count!: number;

  constructor(data?: ICoordinateSequence) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).dimension = _data['dimension'];
      (<any>this).measures = _data['measures'];
      (<any>this).spatial = _data['spatial'];
      this.ordinates = _data['ordinates'];
      (<any>this).hasZ = _data['hasZ'];
      (<any>this).hasM = _data['hasM'];
      (<any>this).zOrdinateIndex = _data['zOrdinateIndex'];
      (<any>this).mOrdinateIndex = _data['mOrdinateIndex'];
      (<any>this).count = _data['count'];
    }
  }

  static fromJS(data: any): CoordinateSequence {
    data = typeof data === 'object' ? data : {};
    let result = new CoordinateSequence();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dimension'] = this.dimension;
    data['measures'] = this.measures;
    data['spatial'] = this.spatial;
    data['ordinates'] = this.ordinates;
    data['hasZ'] = this.hasZ;
    data['hasM'] = this.hasM;
    data['zOrdinateIndex'] = this.zOrdinateIndex;
    data['mOrdinateIndex'] = this.mOrdinateIndex;
    data['count'] = this.count;
    return data;
  }
}

export interface ICoordinateSequence {
  dimension: number;
  measures: number;
  spatial: number;
  ordinates: Ordinates;
  hasZ: boolean;
  hasM: boolean;
  zOrdinateIndex: number;
  mOrdinateIndex: number;
  count: number;
}

export class Coordinate implements ICoordinate {
  x!: number;
  y!: number;
  z!: number;
  m!: number;
  coordinateValue!: Coordinate;

  constructor(data?: ICoordinate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.x = _data['x'];
      this.y = _data['y'];
      this.z = _data['z'];
      this.m = _data['m'];
      this.coordinateValue = _data['coordinateValue'] ? Coordinate.fromJS(_data['coordinateValue']) : <any>undefined;
    }
  }

  static fromJS(data: any): Coordinate {
    data = typeof data === 'object' ? data : {};
    let result = new Coordinate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['x'] = this.x;
    data['y'] = this.y;
    data['z'] = this.z;
    data['m'] = this.m;
    data['coordinateValue'] = this.coordinateValue ? this.coordinateValue.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICoordinate {
  x: number;
  y: number;
  z: number;
  m: number;
  coordinateValue: Coordinate;
}

export enum Dimension {
  Point = 0,
  Curve = 1,
  Surface = 2,
  Dontcare = -3,
  True = -2,
  False = -1,
}

export enum OgcGeometryType {
  Point = 1,
  LineString = 2,
  Polygon = 3,
  MultiPoint = 4,
  MultiLineString = 5,
  MultiPolygon = 6,
  GeometryCollection = 7,
  CircularString = 8,
  CompoundCurve = 9,
  CurvePolygon = 10,
  MultiCurve = 11,
  MultiSurface = 12,
  Curve = 13,
  Surface = 14,
  PolyhedralSurface = 15,
  TIN = 16,
}

export enum PrecisionModels {
  Floating = 0,
  FloatingSingle = 1,
  Fixed = 2,
}

export class PrecisionModel implements IPrecisionModel {
  readonly isFloating!: boolean;
  readonly maximumSignificantDigits!: number;
  scale!: number;
  precisionModelType!: PrecisionModels;

  constructor(data?: IPrecisionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).isFloating = _data['isFloating'];
      (<any>this).maximumSignificantDigits = _data['maximumSignificantDigits'];
      this.scale = _data['scale'];
      this.precisionModelType = _data['precisionModelType'];
    }
  }

  static fromJS(data: any): PrecisionModel {
    data = typeof data === 'object' ? data : {};
    let result = new PrecisionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isFloating'] = this.isFloating;
    data['maximumSignificantDigits'] = this.maximumSignificantDigits;
    data['scale'] = this.scale;
    data['precisionModelType'] = this.precisionModelType;
    return data;
  }
}

export interface IPrecisionModel {
  isFloating: boolean;
  maximumSignificantDigits: number;
  scale: number;
  precisionModelType: PrecisionModels;
}

export class CoordinateSequenceFactory implements ICoordinateSequenceFactory {
  ordinates!: Ordinates;

  constructor(data?: ICoordinateSequenceFactory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ordinates = _data['ordinates'];
    }
  }

  static fromJS(data: any): CoordinateSequenceFactory {
    data = typeof data === 'object' ? data : {};
    let result = new CoordinateSequenceFactory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ordinates'] = this.ordinates;
    return data;
  }
}

export interface ICoordinateSequenceFactory {
  ordinates: Ordinates;
}

export class GeometryFactory implements IGeometryFactory {
  precisionModel!: PrecisionModel;
  coordinateSequenceFactory!: CoordinateSequenceFactory;
  srid!: number;

  constructor(data?: IGeometryFactory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.precisionModel = _data['precisionModel'] ? PrecisionModel.fromJS(_data['precisionModel']) : <any>undefined;
      this.coordinateSequenceFactory = _data['coordinateSequenceFactory']
        ? CoordinateSequenceFactory.fromJS(_data['coordinateSequenceFactory'])
        : <any>undefined;
      this.srid = _data['srid'];
    }
  }

  static fromJS(data: any): GeometryFactory {
    data = typeof data === 'object' ? data : {};
    let result = new GeometryFactory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['precisionModel'] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
    data['coordinateSequenceFactory'] = this.coordinateSequenceFactory ? this.coordinateSequenceFactory.toJSON() : <any>undefined;
    data['srid'] = this.srid;
    return data;
  }
}

export interface IGeometryFactory {
  precisionModel: PrecisionModel;
  coordinateSequenceFactory: CoordinateSequenceFactory;
  srid: number;
}

export class Envelope implements IEnvelope {
  readonly isNull!: boolean;
  readonly width!: number;
  readonly height!: number;
  readonly minX!: number;
  readonly maxX!: number;
  readonly minY!: number;
  readonly maxY!: number;
  readonly area!: number;
  readonly minExtent!: number;
  readonly maxExtent!: number;
  centre!: Coordinate;

  constructor(data?: IEnvelope) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).isNull = _data['isNull'];
      (<any>this).width = _data['width'];
      (<any>this).height = _data['height'];
      (<any>this).minX = _data['minX'];
      (<any>this).maxX = _data['maxX'];
      (<any>this).minY = _data['minY'];
      (<any>this).maxY = _data['maxY'];
      (<any>this).area = _data['area'];
      (<any>this).minExtent = _data['minExtent'];
      (<any>this).maxExtent = _data['maxExtent'];
      this.centre = _data['centre'] ? Coordinate.fromJS(_data['centre']) : <any>undefined;
    }
  }

  static fromJS(data: any): Envelope {
    data = typeof data === 'object' ? data : {};
    let result = new Envelope();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isNull'] = this.isNull;
    data['width'] = this.width;
    data['height'] = this.height;
    data['minX'] = this.minX;
    data['maxX'] = this.maxX;
    data['minY'] = this.minY;
    data['maxY'] = this.maxY;
    data['area'] = this.area;
    data['minExtent'] = this.minExtent;
    data['maxExtent'] = this.maxExtent;
    data['centre'] = this.centre ? this.centre.toJSON() : <any>undefined;
    return data;
  }
}

export interface IEnvelope {
  isNull: boolean;
  width: number;
  height: number;
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
  area: number;
  minExtent: number;
  maxExtent: number;
  centre: Coordinate;
}

export class Geometry implements IGeometry {
  factory!: GeometryFactory;
  userData!: any | undefined;
  srid!: number;
  readonly geometryType!: string | undefined;
  ogcGeometryType!: OgcGeometryType;
  precisionModel!: PrecisionModel;
  coordinate!: Coordinate;
  readonly coordinates!: Coordinate[] | undefined;
  readonly numPoints!: number;
  readonly numGeometries!: number;
  readonly isSimple!: boolean;
  readonly isValid!: boolean;
  readonly isEmpty!: boolean;
  readonly area!: number;
  readonly length!: number;
  centroid!: Point;
  interiorPoint!: Point;
  pointOnSurface!: Point;
  dimension!: Dimension;
  boundary!: Geometry;
  boundaryDimension!: Dimension;
  envelope!: Geometry;
  envelopeInternal!: Envelope;
  readonly isRectangle!: boolean;

  constructor(data?: IGeometry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.factory = _data['factory'] ? GeometryFactory.fromJS(_data['factory']) : <any>undefined;
      this.userData = _data['userData'];
      this.srid = _data['srid'];
      (<any>this).geometryType = _data['geometryType'];
      this.ogcGeometryType = _data['ogcGeometryType'];
      this.precisionModel = _data['precisionModel'] ? PrecisionModel.fromJS(_data['precisionModel']) : <any>undefined;
      this.coordinate = _data['coordinate'] ? Coordinate.fromJS(_data['coordinate']) : <any>undefined;
      if (Array.isArray(_data['coordinates'])) {
        (<any>this).coordinates = [] as any;
        for (let item of _data['coordinates']) (<any>this).coordinates!.push(Coordinate.fromJS(item));
      }
      (<any>this).numPoints = _data['numPoints'];
      (<any>this).numGeometries = _data['numGeometries'];
      (<any>this).isSimple = _data['isSimple'];
      (<any>this).isValid = _data['isValid'];
      (<any>this).isEmpty = _data['isEmpty'];
      (<any>this).area = _data['area'];
      (<any>this).length = _data['length'];
      this.centroid = _data['centroid'] ? Point.fromJS(_data['centroid']) : <any>undefined;
      this.interiorPoint = _data['interiorPoint'] ? Point.fromJS(_data['interiorPoint']) : <any>undefined;
      this.pointOnSurface = _data['pointOnSurface'] ? Point.fromJS(_data['pointOnSurface']) : <any>undefined;
      this.dimension = _data['dimension'];
      this.boundary = _data['boundary'] ? Geometry.fromJS(_data['boundary']) : <any>undefined;
      this.boundaryDimension = _data['boundaryDimension'];
      this.envelope = _data['envelope'] ? Geometry.fromJS(_data['envelope']) : <any>undefined;
      this.envelopeInternal = _data['envelopeInternal'] ? Envelope.fromJS(_data['envelopeInternal']) : <any>undefined;
      (<any>this).isRectangle = _data['isRectangle'];
    }
  }

  static fromJS(data: any): Geometry {
    data = typeof data === 'object' ? data : {};
    let result = new Geometry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['factory'] = this.factory ? this.factory.toJSON() : <any>undefined;
    data['userData'] = this.userData;
    data['srid'] = this.srid;
    data['geometryType'] = this.geometryType;
    data['ogcGeometryType'] = this.ogcGeometryType;
    data['precisionModel'] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
    data['coordinate'] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
    if (Array.isArray(this.coordinates)) {
      data['coordinates'] = [];
      for (let item of this.coordinates) data['coordinates'].push(item.toJSON());
    }
    data['numPoints'] = this.numPoints;
    data['numGeometries'] = this.numGeometries;
    data['isSimple'] = this.isSimple;
    data['isValid'] = this.isValid;
    data['isEmpty'] = this.isEmpty;
    data['area'] = this.area;
    data['length'] = this.length;
    data['centroid'] = this.centroid ? this.centroid.toJSON() : <any>undefined;
    data['interiorPoint'] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
    data['pointOnSurface'] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
    data['dimension'] = this.dimension;
    data['boundary'] = this.boundary ? this.boundary.toJSON() : <any>undefined;
    data['boundaryDimension'] = this.boundaryDimension;
    data['envelope'] = this.envelope ? this.envelope.toJSON() : <any>undefined;
    data['envelopeInternal'] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
    data['isRectangle'] = this.isRectangle;
    return data;
  }
}

export interface IGeometry {
  factory: GeometryFactory;
  userData: any | undefined;
  srid: number;
  geometryType: string | undefined;
  ogcGeometryType: OgcGeometryType;
  precisionModel: PrecisionModel;
  coordinate: Coordinate;
  coordinates: Coordinate[] | undefined;
  numPoints: number;
  numGeometries: number;
  isSimple: boolean;
  isValid: boolean;
  isEmpty: boolean;
  area: number;
  length: number;
  centroid: Point;
  interiorPoint: Point;
  pointOnSurface: Point;
  dimension: Dimension;
  boundary: Geometry;
  boundaryDimension: Dimension;
  envelope: Geometry;
  envelopeInternal: Envelope;
  isRectangle: boolean;
}

export class Point implements IPoint {
  coordinateSequence!: CoordinateSequence;
  coordinates!: Coordinate[] | undefined;
  readonly numPoints!: number;
  readonly isEmpty!: boolean;
  dimension!: Dimension;
  boundaryDimension!: Dimension;
  x!: number;
  y!: number;
  coordinate!: Coordinate;
  readonly geometryType!: string | undefined;
  ogcGeometryType!: OgcGeometryType;
  boundary!: Geometry;
  z!: number;
  m!: number;
  factory!: GeometryFactory;
  userData!: any | undefined;
  srid!: number;
  precisionModel!: PrecisionModel;
  readonly numGeometries!: number;
  readonly isSimple!: boolean;
  readonly isValid!: boolean;
  readonly area!: number;
  readonly length!: number;
  centroid!: Point;
  interiorPoint!: Point;
  pointOnSurface!: Point;
  envelope!: Geometry;
  envelopeInternal!: Envelope;
  readonly isRectangle!: boolean;

  constructor(data?: IPoint) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.coordinateSequence = _data['coordinateSequence'] ? CoordinateSequence.fromJS(_data['coordinateSequence']) : <any>undefined;
      if (Array.isArray(_data['coordinates'])) {
        this.coordinates = [] as any;
        for (let item of _data['coordinates']) this.coordinates!.push(Coordinate.fromJS(item));
      }
      (<any>this).numPoints = _data['numPoints'];
      (<any>this).isEmpty = _data['isEmpty'];
      this.dimension = _data['dimension'];
      this.boundaryDimension = _data['boundaryDimension'];
      this.x = _data['x'];
      this.y = _data['y'];
      this.coordinate = _data['coordinate'] ? Coordinate.fromJS(_data['coordinate']) : <any>undefined;
      (<any>this).geometryType = _data['geometryType'];
      this.ogcGeometryType = _data['ogcGeometryType'];
      this.boundary = _data['boundary'] ? Geometry.fromJS(_data['boundary']) : <any>undefined;
      this.z = _data['z'];
      this.m = _data['m'];
      this.factory = _data['factory'] ? GeometryFactory.fromJS(_data['factory']) : <any>undefined;
      this.userData = _data['userData'];
      this.srid = _data['srid'];
      this.precisionModel = _data['precisionModel'] ? PrecisionModel.fromJS(_data['precisionModel']) : <any>undefined;
      (<any>this).numGeometries = _data['numGeometries'];
      (<any>this).isSimple = _data['isSimple'];
      (<any>this).isValid = _data['isValid'];
      (<any>this).area = _data['area'];
      (<any>this).length = _data['length'];
      this.centroid = _data['centroid'] ? Point.fromJS(_data['centroid']) : <any>undefined;
      this.interiorPoint = _data['interiorPoint'] ? Point.fromJS(_data['interiorPoint']) : <any>undefined;
      this.pointOnSurface = _data['pointOnSurface'] ? Point.fromJS(_data['pointOnSurface']) : <any>undefined;
      this.envelope = _data['envelope'] ? Geometry.fromJS(_data['envelope']) : <any>undefined;
      this.envelopeInternal = _data['envelopeInternal'] ? Envelope.fromJS(_data['envelopeInternal']) : <any>undefined;
      (<any>this).isRectangle = _data['isRectangle'];
    }
  }

  static fromJS(data: any): Point {
    data = typeof data === 'object' ? data : {};
    let result = new Point();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['coordinateSequence'] = this.coordinateSequence ? this.coordinateSequence.toJSON() : <any>undefined;
    if (Array.isArray(this.coordinates)) {
      data['coordinates'] = [];
      for (let item of this.coordinates) data['coordinates'].push(item.toJSON());
    }
    data['numPoints'] = this.numPoints;
    data['isEmpty'] = this.isEmpty;
    data['dimension'] = this.dimension;
    data['boundaryDimension'] = this.boundaryDimension;
    data['x'] = this.x;
    data['y'] = this.y;
    data['coordinate'] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
    data['geometryType'] = this.geometryType;
    data['ogcGeometryType'] = this.ogcGeometryType;
    data['boundary'] = this.boundary ? this.boundary.toJSON() : <any>undefined;
    data['z'] = this.z;
    data['m'] = this.m;
    data['factory'] = this.factory ? this.factory.toJSON() : <any>undefined;
    data['userData'] = this.userData;
    data['srid'] = this.srid;
    data['precisionModel'] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
    data['numGeometries'] = this.numGeometries;
    data['isSimple'] = this.isSimple;
    data['isValid'] = this.isValid;
    data['area'] = this.area;
    data['length'] = this.length;
    data['centroid'] = this.centroid ? this.centroid.toJSON() : <any>undefined;
    data['interiorPoint'] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
    data['pointOnSurface'] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
    data['envelope'] = this.envelope ? this.envelope.toJSON() : <any>undefined;
    data['envelopeInternal'] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
    data['isRectangle'] = this.isRectangle;
    return data;
  }
}

export interface IPoint {
  coordinateSequence: CoordinateSequence;
  coordinates: Coordinate[] | undefined;
  numPoints: number;
  isEmpty: boolean;
  dimension: Dimension;
  boundaryDimension: Dimension;
  x: number;
  y: number;
  coordinate: Coordinate;
  geometryType: string | undefined;
  ogcGeometryType: OgcGeometryType;
  boundary: Geometry;
  z: number;
  m: number;
  factory: GeometryFactory;
  userData: any | undefined;
  srid: number;
  precisionModel: PrecisionModel;
  numGeometries: number;
  isSimple: boolean;
  isValid: boolean;
  area: number;
  length: number;
  centroid: Point;
  interiorPoint: Point;
  pointOnSurface: Point;
  envelope: Geometry;
  envelopeInternal: Envelope;
  isRectangle: boolean;
}

export class PortDto implements IPortDto {
  name!: string | undefined;
  address!: string | undefined;
  location!: Point;
  cityId!: number;
  id!: number;

  constructor(data?: IPortDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.address = _data['address'];
      this.location = _data['location'] ? Point.fromJS(_data['location']) : <any>undefined;
      this.cityId = _data['cityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PortDto {
    data = typeof data === 'object' ? data : {};
    let result = new PortDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['address'] = this.address;
    data['location'] = this.location ? this.location.toJSON() : <any>undefined;
    data['cityId'] = this.cityId;
    data['id'] = this.id;
    return data;
  }
}

export interface IPortDto {
  name: string | undefined;
  address: string | undefined;
  location: Point;
  cityId: number;
  id: number;
}

export class GetPortForViewDto implements IGetPortForViewDto {
  port!: PortDto;
  cityDisplayName!: string | undefined;

  constructor(data?: IGetPortForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.port = _data['port'] ? PortDto.fromJS(_data['port']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
    }
  }

  static fromJS(data: any): GetPortForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetPortForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['port'] = this.port ? this.port.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    return data;
  }
}

export interface IGetPortForViewDto {
  port: PortDto;
  cityDisplayName: string | undefined;
}

export class PagedResultDtoOfGetPortForViewDto implements IPagedResultDtoOfGetPortForViewDto {
  totalCount!: number;
  items!: GetPortForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetPortForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetPortForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetPortForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetPortForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetPortForViewDto {
  totalCount: number;
  items: GetPortForViewDto[] | undefined;
}

export class CreateOrEditPortDto implements ICreateOrEditPortDto {
  name!: string;
  address!: string | undefined;
  longitude!: number;
  latitude!: number;
  cityId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditPortDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.address = _data['address'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.cityId = _data['cityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditPortDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPortDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['address'] = this.address;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['cityId'] = this.cityId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditPortDto {
  name: string;
  address: string | undefined;
  longitude: number;
  latitude: number;
  cityId: number;
  id: number | undefined;
}

export class GetPortForEditOutput implements IGetPortForEditOutput {
  port!: CreateOrEditPortDto;
  cityDisplayName!: string | undefined;

  constructor(data?: IGetPortForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.port = _data['port'] ? CreateOrEditPortDto.fromJS(_data['port']) : <any>undefined;
      this.cityDisplayName = _data['cityDisplayName'];
    }
  }

  static fromJS(data: any): GetPortForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPortForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['port'] = this.port ? this.port.toJSON() : <any>undefined;
    data['cityDisplayName'] = this.cityDisplayName;
    return data;
  }
}

export interface IGetPortForEditOutput {
  port: CreateOrEditPortDto;
  cityDisplayName: string | undefined;
}

export class PortCityLookupTableDto implements IPortCityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IPortCityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): PortCityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new PortCityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IPortCityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export enum PriceOfferChannel {
  MarketPlace = 1,
  DirectRequest = 2,
  TachyonManageService = 3,
  Offers = 10,
}

export enum PriceOfferStatus {
  New = 0,
  Accepted = 1,
  Rejected = 2,
  AcceptedAndWaitingForCarrier = 3,
  AcceptedAndWaitingForShipper = 4,
  ForceRejected = 5,
  Pending = 6,
}

export enum PriceOfferType {
  Trip = 1,
  Vas = 2,
  Dedicated = 3,
}

export class PriceOfferListDto implements IPriceOfferListDto {
  shippingRequestId!: number;
  name!: string | undefined;
  status!: PriceOfferStatus;
  priceType!: PriceOfferType;
  channel!: PriceOfferChannel;
  totalAmount!: number;
  creationTime!: moment.Moment;
  statusTitle!: string | undefined;
  readonly priceTypeTitle!: string | undefined;
  readonly channelTitle!: string | undefined;
  id!: number;

  constructor(data?: IPriceOfferListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestId = _data['shippingRequestId'];
      this.name = _data['name'];
      this.status = _data['status'];
      this.priceType = _data['priceType'];
      this.channel = _data['channel'];
      this.totalAmount = _data['totalAmount'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.statusTitle = _data['statusTitle'];
      (<any>this).priceTypeTitle = _data['priceTypeTitle'];
      (<any>this).channelTitle = _data['channelTitle'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PriceOfferListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestId'] = this.shippingRequestId;
    data['name'] = this.name;
    data['status'] = this.status;
    data['priceType'] = this.priceType;
    data['channel'] = this.channel;
    data['totalAmount'] = this.totalAmount;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['statusTitle'] = this.statusTitle;
    data['priceTypeTitle'] = this.priceTypeTitle;
    data['channelTitle'] = this.channelTitle;
    data['id'] = this.id;
    return data;
  }
}

export interface IPriceOfferListDto {
  shippingRequestId: number;
  name: string | undefined;
  status: PriceOfferStatus;
  priceType: PriceOfferType;
  channel: PriceOfferChannel;
  totalAmount: number;
  creationTime: moment.Moment;
  statusTitle: string | undefined;
  priceTypeTitle: string | undefined;
  channelTitle: string | undefined;
  id: number;
}

export class PagedResultDtoOfPriceOfferListDto implements IPagedResultDtoOfPriceOfferListDto {
  totalCount!: number;
  items!: PriceOfferListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfPriceOfferListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PriceOfferListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfPriceOfferListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfPriceOfferListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfPriceOfferListDto {
  totalCount: number;
  items: PriceOfferListDto[] | undefined;
}

export class TrucksTypeDto implements ITrucksTypeDto {
  transportTypeId!: number | undefined;
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ITrucksTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportTypeId = _data['transportTypeId'];
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TrucksTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrucksTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportTypeId'] = this.transportTypeId;
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITrucksTypeDto {
  transportTypeId: number | undefined;
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetShippingRequestSearchListDto implements IGetShippingRequestSearchListDto {
  cities!: CityDto[] | undefined;
  trucksTypes!: TrucksTypeDto[] | undefined;

  constructor(data?: IGetShippingRequestSearchListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['cities'])) {
        this.cities = [] as any;
        for (let item of _data['cities']) this.cities!.push(CityDto.fromJS(item));
      }
      if (Array.isArray(_data['trucksTypes'])) {
        this.trucksTypes = [] as any;
        for (let item of _data['trucksTypes']) this.trucksTypes!.push(TrucksTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetShippingRequestSearchListDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestSearchListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.cities)) {
      data['cities'] = [];
      for (let item of this.cities) data['cities'].push(item.toJSON());
    }
    if (Array.isArray(this.trucksTypes)) {
      data['trucksTypes'] = [];
      for (let item of this.trucksTypes) data['trucksTypes'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetShippingRequestSearchListDto {
  cities: CityDto[] | undefined;
  trucksTypes: TrucksTypeDto[] | undefined;
}

export enum PriceOfferCommissionType {
  CommissionPercentage = 1,
  CommissionValue = 2,
  CommissionMinimumValue = 3,
}

export class PriceOfferItem implements IPriceOfferItem {
  sourceId!: number | undefined;
  priceType!: PriceOfferType;
  itemName!: string | undefined;
  itemPrice!: number | undefined;
  itemVatAmount!: number | undefined;
  itemTotalAmount!: number | undefined;
  itemSubTotalAmountWithCommission!: number | undefined;
  itemVatAmountWithCommission!: number | undefined;
  itemTotalAmountWithCommission!: number | undefined;
  totalAmount!: number | undefined;
  subTotalAmount!: number | undefined;
  vatAmount!: number | undefined;
  totalAmountWithCommission!: number | undefined;
  subTotalAmountWithCommission!: number | undefined;
  vatAmountWithCommission!: number | undefined;
  itemCommissionAmount!: number | undefined;
  commissionAmount!: number | undefined;
  commissionType!: PriceOfferCommissionType;
  commissionPercentageOrAddValue!: number | undefined;
  quantity!: number;

  constructor(data?: IPriceOfferItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sourceId = _data['sourceId'];
      this.priceType = _data['priceType'];
      this.itemName = _data['itemName'];
      this.itemPrice = _data['itemPrice'];
      this.itemVatAmount = _data['itemVatAmount'];
      this.itemTotalAmount = _data['itemTotalAmount'];
      this.itemSubTotalAmountWithCommission = _data['itemSubTotalAmountWithCommission'];
      this.itemVatAmountWithCommission = _data['itemVatAmountWithCommission'];
      this.itemTotalAmountWithCommission = _data['itemTotalAmountWithCommission'];
      this.totalAmount = _data['totalAmount'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.totalAmountWithCommission = _data['totalAmountWithCommission'];
      this.subTotalAmountWithCommission = _data['subTotalAmountWithCommission'];
      this.vatAmountWithCommission = _data['vatAmountWithCommission'];
      this.itemCommissionAmount = _data['itemCommissionAmount'];
      this.commissionAmount = _data['commissionAmount'];
      this.commissionType = _data['commissionType'];
      this.commissionPercentageOrAddValue = _data['commissionPercentageOrAddValue'];
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): PriceOfferItem {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sourceId'] = this.sourceId;
    data['priceType'] = this.priceType;
    data['itemName'] = this.itemName;
    data['itemPrice'] = this.itemPrice;
    data['itemVatAmount'] = this.itemVatAmount;
    data['itemTotalAmount'] = this.itemTotalAmount;
    data['itemSubTotalAmountWithCommission'] = this.itemSubTotalAmountWithCommission;
    data['itemVatAmountWithCommission'] = this.itemVatAmountWithCommission;
    data['itemTotalAmountWithCommission'] = this.itemTotalAmountWithCommission;
    data['totalAmount'] = this.totalAmount;
    data['subTotalAmount'] = this.subTotalAmount;
    data['vatAmount'] = this.vatAmount;
    data['totalAmountWithCommission'] = this.totalAmountWithCommission;
    data['subTotalAmountWithCommission'] = this.subTotalAmountWithCommission;
    data['vatAmountWithCommission'] = this.vatAmountWithCommission;
    data['itemCommissionAmount'] = this.itemCommissionAmount;
    data['commissionAmount'] = this.commissionAmount;
    data['commissionType'] = this.commissionType;
    data['commissionPercentageOrAddValue'] = this.commissionPercentageOrAddValue;
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IPriceOfferItem {
  sourceId: number | undefined;
  priceType: PriceOfferType;
  itemName: string | undefined;
  itemPrice: number | undefined;
  itemVatAmount: number | undefined;
  itemTotalAmount: number | undefined;
  itemSubTotalAmountWithCommission: number | undefined;
  itemVatAmountWithCommission: number | undefined;
  itemTotalAmountWithCommission: number | undefined;
  totalAmount: number | undefined;
  subTotalAmount: number | undefined;
  vatAmount: number | undefined;
  totalAmountWithCommission: number | undefined;
  subTotalAmountWithCommission: number | undefined;
  vatAmountWithCommission: number | undefined;
  itemCommissionAmount: number | undefined;
  commissionAmount: number | undefined;
  commissionType: PriceOfferCommissionType;
  commissionPercentageOrAddValue: number | undefined;
  quantity: number;
}

export class PriceOfferTenantCommssionSettings implements IPriceOfferTenantCommssionSettings {
  itemCommissionType!: PriceOfferCommissionType;
  itemCommissionPercentage!: number;
  itemCommissionValue!: number;
  itemMinValueCommission!: number;
  vasCommissionType!: PriceOfferCommissionType;
  vasCommissionPercentage!: number;
  vasCommissionValue!: number;
  vasMinValueCommission!: number;

  constructor(data?: IPriceOfferTenantCommssionSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.itemCommissionType = _data['itemCommissionType'];
      this.itemCommissionPercentage = _data['itemCommissionPercentage'];
      this.itemCommissionValue = _data['itemCommissionValue'];
      this.itemMinValueCommission = _data['itemMinValueCommission'];
      this.vasCommissionType = _data['vasCommissionType'];
      this.vasCommissionPercentage = _data['vasCommissionPercentage'];
      this.vasCommissionValue = _data['vasCommissionValue'];
      this.vasMinValueCommission = _data['vasMinValueCommission'];
    }
  }

  static fromJS(data: any): PriceOfferTenantCommssionSettings {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferTenantCommssionSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['itemCommissionType'] = this.itemCommissionType;
    data['itemCommissionPercentage'] = this.itemCommissionPercentage;
    data['itemCommissionValue'] = this.itemCommissionValue;
    data['itemMinValueCommission'] = this.itemMinValueCommission;
    data['vasCommissionType'] = this.vasCommissionType;
    data['vasCommissionPercentage'] = this.vasCommissionPercentage;
    data['vasCommissionValue'] = this.vasCommissionValue;
    data['vasMinValueCommission'] = this.vasMinValueCommission;
    return data;
  }
}

export interface IPriceOfferTenantCommssionSettings {
  itemCommissionType: PriceOfferCommissionType;
  itemCommissionPercentage: number;
  itemCommissionValue: number;
  itemMinValueCommission: number;
  vasCommissionType: PriceOfferCommissionType;
  vasCommissionPercentage: number;
  vasCommissionValue: number;
  vasMinValueCommission: number;
}

export class PriceOfferDto implements IPriceOfferDto {
  status!: PriceOfferStatus;
  priceType!: PriceOfferType;
  parentId!: number | undefined;
  itemPrice!: number;
  itemVatAmount!: number;
  itemTotalAmount!: number;
  itemSubTotalAmountWithCommission!: number;
  itemVatAmountWithCommission!: number;
  itemTotalAmountWithCommission!: number;
  totalAmount!: number;
  subTotalAmount!: number;
  vatAmount!: number;
  totalAmountWithCommission!: number;
  subTotalAmountWithCommission!: number;
  vatAmountWithCommission!: number;
  taxVat!: number;
  commissionType!: PriceOfferCommissionType;
  itemCommissionAmount!: number;
  commissionPercentageOrAddValue!: number;
  commissionAmount!: number;
  vasCommissionType!: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue!: number;
  quantity!: number;
  items!: PriceOfferItem[] | undefined;
  rejectedReason!: string | undefined;
  commssionSettings!: PriceOfferTenantCommssionSettings;
  id!: number;

  constructor(data?: IPriceOfferDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data['status'];
      this.priceType = _data['priceType'];
      this.parentId = _data['parentId'];
      this.itemPrice = _data['itemPrice'];
      this.itemVatAmount = _data['itemVatAmount'];
      this.itemTotalAmount = _data['itemTotalAmount'];
      this.itemSubTotalAmountWithCommission = _data['itemSubTotalAmountWithCommission'];
      this.itemVatAmountWithCommission = _data['itemVatAmountWithCommission'];
      this.itemTotalAmountWithCommission = _data['itemTotalAmountWithCommission'];
      this.totalAmount = _data['totalAmount'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.totalAmountWithCommission = _data['totalAmountWithCommission'];
      this.subTotalAmountWithCommission = _data['subTotalAmountWithCommission'];
      this.vatAmountWithCommission = _data['vatAmountWithCommission'];
      this.taxVat = _data['taxVat'];
      this.commissionType = _data['commissionType'];
      this.itemCommissionAmount = _data['itemCommissionAmount'];
      this.commissionPercentageOrAddValue = _data['commissionPercentageOrAddValue'];
      this.commissionAmount = _data['commissionAmount'];
      this.vasCommissionType = _data['vasCommissionType'];
      this.vasCommissionPercentageOrAddValue = _data['vasCommissionPercentageOrAddValue'];
      this.quantity = _data['quantity'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PriceOfferItem.fromJS(item));
      }
      this.rejectedReason = _data['rejectedReason'];
      this.commssionSettings = _data['commssionSettings'] ? PriceOfferTenantCommssionSettings.fromJS(_data['commssionSettings']) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PriceOfferDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['status'] = this.status;
    data['priceType'] = this.priceType;
    data['parentId'] = this.parentId;
    data['itemPrice'] = this.itemPrice;
    data['itemVatAmount'] = this.itemVatAmount;
    data['itemTotalAmount'] = this.itemTotalAmount;
    data['itemSubTotalAmountWithCommission'] = this.itemSubTotalAmountWithCommission;
    data['itemVatAmountWithCommission'] = this.itemVatAmountWithCommission;
    data['itemTotalAmountWithCommission'] = this.itemTotalAmountWithCommission;
    data['totalAmount'] = this.totalAmount;
    data['subTotalAmount'] = this.subTotalAmount;
    data['vatAmount'] = this.vatAmount;
    data['totalAmountWithCommission'] = this.totalAmountWithCommission;
    data['subTotalAmountWithCommission'] = this.subTotalAmountWithCommission;
    data['vatAmountWithCommission'] = this.vatAmountWithCommission;
    data['taxVat'] = this.taxVat;
    data['commissionType'] = this.commissionType;
    data['itemCommissionAmount'] = this.itemCommissionAmount;
    data['commissionPercentageOrAddValue'] = this.commissionPercentageOrAddValue;
    data['commissionAmount'] = this.commissionAmount;
    data['vasCommissionType'] = this.vasCommissionType;
    data['vasCommissionPercentageOrAddValue'] = this.vasCommissionPercentageOrAddValue;
    data['quantity'] = this.quantity;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['rejectedReason'] = this.rejectedReason;
    data['commssionSettings'] = this.commssionSettings ? this.commssionSettings.toJSON() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IPriceOfferDto {
  status: PriceOfferStatus;
  priceType: PriceOfferType;
  parentId: number | undefined;
  itemPrice: number;
  itemVatAmount: number;
  itemTotalAmount: number;
  itemSubTotalAmountWithCommission: number;
  itemVatAmountWithCommission: number;
  itemTotalAmountWithCommission: number;
  totalAmount: number;
  subTotalAmount: number;
  vatAmount: number;
  totalAmountWithCommission: number;
  subTotalAmountWithCommission: number;
  vatAmountWithCommission: number;
  taxVat: number;
  commissionType: PriceOfferCommissionType;
  itemCommissionAmount: number;
  commissionPercentageOrAddValue: number;
  commissionAmount: number;
  vasCommissionType: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue: number;
  quantity: number;
  items: PriceOfferItem[] | undefined;
  rejectedReason: string | undefined;
  commssionSettings: PriceOfferTenantCommssionSettings;
  id: number;
}

export enum ShippingRequestStatus {
  PrePrice = 0,
  PostPrice = 1,
  NeedsAction = 2,
  Expired = 3,
  Cancled = 4,
  Completed = 5,
  AcceptedAndWaitingCarrier = 6,
}

export class PriceOfferViewDto implements IPriceOfferViewDto {
  tenantId!: number;
  editionId!: number | undefined;
  name!: string | undefined;
  status!: PriceOfferStatus;
  priceType!: PriceOfferType;
  shippingRequestStatus!: ShippingRequestStatus;
  isTachyonDeal!: boolean;
  itemPrice!: number;
  itemVatAmount!: number;
  itemTotalAmount!: number;
  itemSubTotalAmountWithCommission!: number;
  itemVatAmountWithCommission!: number;
  itemTotalAmountWithCommission!: number;
  totalAmount!: number;
  subTotalAmount!: number;
  vatAmount!: number;
  totalAmountWithCommission!: number;
  subTotalAmountWithCommission!: number;
  vatAmountWithCommission!: number;
  taxVat!: number;
  commissionType!: PriceOfferCommissionType;
  readonly commissionTypeTitle!: string | undefined;
  itemCommissionAmount!: number;
  commissionPercentageOrAddValue!: number;
  commissionAmount!: number;
  vasCommissionType!: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue!: number;
  quantity!: number;
  items!: PriceOfferItem[] | undefined;
  rejectedReason!: string | undefined;
  id!: number;

  constructor(data?: IPriceOfferViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.editionId = _data['editionId'];
      this.name = _data['name'];
      this.status = _data['status'];
      this.priceType = _data['priceType'];
      this.shippingRequestStatus = _data['shippingRequestStatus'];
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.itemPrice = _data['itemPrice'];
      this.itemVatAmount = _data['itemVatAmount'];
      this.itemTotalAmount = _data['itemTotalAmount'];
      this.itemSubTotalAmountWithCommission = _data['itemSubTotalAmountWithCommission'];
      this.itemVatAmountWithCommission = _data['itemVatAmountWithCommission'];
      this.itemTotalAmountWithCommission = _data['itemTotalAmountWithCommission'];
      this.totalAmount = _data['totalAmount'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.totalAmountWithCommission = _data['totalAmountWithCommission'];
      this.subTotalAmountWithCommission = _data['subTotalAmountWithCommission'];
      this.vatAmountWithCommission = _data['vatAmountWithCommission'];
      this.taxVat = _data['taxVat'];
      this.commissionType = _data['commissionType'];
      (<any>this).commissionTypeTitle = _data['commissionTypeTitle'];
      this.itemCommissionAmount = _data['itemCommissionAmount'];
      this.commissionPercentageOrAddValue = _data['commissionPercentageOrAddValue'];
      this.commissionAmount = _data['commissionAmount'];
      this.vasCommissionType = _data['vasCommissionType'];
      this.vasCommissionPercentageOrAddValue = _data['vasCommissionPercentageOrAddValue'];
      this.quantity = _data['quantity'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PriceOfferItem.fromJS(item));
      }
      this.rejectedReason = _data['rejectedReason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PriceOfferViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['editionId'] = this.editionId;
    data['name'] = this.name;
    data['status'] = this.status;
    data['priceType'] = this.priceType;
    data['shippingRequestStatus'] = this.shippingRequestStatus;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['itemPrice'] = this.itemPrice;
    data['itemVatAmount'] = this.itemVatAmount;
    data['itemTotalAmount'] = this.itemTotalAmount;
    data['itemSubTotalAmountWithCommission'] = this.itemSubTotalAmountWithCommission;
    data['itemVatAmountWithCommission'] = this.itemVatAmountWithCommission;
    data['itemTotalAmountWithCommission'] = this.itemTotalAmountWithCommission;
    data['totalAmount'] = this.totalAmount;
    data['subTotalAmount'] = this.subTotalAmount;
    data['vatAmount'] = this.vatAmount;
    data['totalAmountWithCommission'] = this.totalAmountWithCommission;
    data['subTotalAmountWithCommission'] = this.subTotalAmountWithCommission;
    data['vatAmountWithCommission'] = this.vatAmountWithCommission;
    data['taxVat'] = this.taxVat;
    data['commissionType'] = this.commissionType;
    data['commissionTypeTitle'] = this.commissionTypeTitle;
    data['itemCommissionAmount'] = this.itemCommissionAmount;
    data['commissionPercentageOrAddValue'] = this.commissionPercentageOrAddValue;
    data['commissionAmount'] = this.commissionAmount;
    data['vasCommissionType'] = this.vasCommissionType;
    data['vasCommissionPercentageOrAddValue'] = this.vasCommissionPercentageOrAddValue;
    data['quantity'] = this.quantity;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['rejectedReason'] = this.rejectedReason;
    data['id'] = this.id;
    return data;
  }
}

export interface IPriceOfferViewDto {
  tenantId: number;
  editionId: number | undefined;
  name: string | undefined;
  status: PriceOfferStatus;
  priceType: PriceOfferType;
  shippingRequestStatus: ShippingRequestStatus;
  isTachyonDeal: boolean;
  itemPrice: number;
  itemVatAmount: number;
  itemTotalAmount: number;
  itemSubTotalAmountWithCommission: number;
  itemVatAmountWithCommission: number;
  itemTotalAmountWithCommission: number;
  totalAmount: number;
  subTotalAmount: number;
  vatAmount: number;
  totalAmountWithCommission: number;
  subTotalAmountWithCommission: number;
  vatAmountWithCommission: number;
  taxVat: number;
  commissionType: PriceOfferCommissionType;
  commissionTypeTitle: string | undefined;
  itemCommissionAmount: number;
  commissionPercentageOrAddValue: number;
  commissionAmount: number;
  vasCommissionType: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue: number;
  quantity: number;
  items: PriceOfferItem[] | undefined;
  rejectedReason: string | undefined;
  id: number;
}

export class PriceOfferDetailDto implements IPriceOfferDetailDto {
  itemId!: number;
  price!: number;

  constructor(data?: IPriceOfferDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.itemId = _data['itemId'];
      this.price = _data['price'];
    }
  }

  static fromJS(data: any): PriceOfferDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['itemId'] = this.itemId;
    data['price'] = this.price;
    return data;
  }
}

export interface IPriceOfferDetailDto {
  itemId: number;
  price: number;
}

export class CreateOrEditPriceOfferInput implements ICreateOrEditPriceOfferInput {
  itemDetails!: PriceOfferDetailDto[] | undefined;
  shippingRequestId!: number;
  itemPrice!: number;
  channel!: PriceOfferChannel;
  parentId!: number | undefined;
  commissionPercentageOrAddValue!: number | undefined;
  commissionType!: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue!: number | undefined;
  vasCommissionType!: PriceOfferCommissionType;

  constructor(data?: ICreateOrEditPriceOfferInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['itemDetails'])) {
        this.itemDetails = [] as any;
        for (let item of _data['itemDetails']) this.itemDetails!.push(PriceOfferDetailDto.fromJS(item));
      }
      this.shippingRequestId = _data['shippingRequestId'];
      this.itemPrice = _data['itemPrice'];
      this.channel = _data['channel'];
      this.parentId = _data['parentId'];
      this.commissionPercentageOrAddValue = _data['commissionPercentageOrAddValue'];
      this.commissionType = _data['commissionType'];
      this.vasCommissionPercentageOrAddValue = _data['vasCommissionPercentageOrAddValue'];
      this.vasCommissionType = _data['vasCommissionType'];
    }
  }

  static fromJS(data: any): CreateOrEditPriceOfferInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditPriceOfferInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.itemDetails)) {
      data['itemDetails'] = [];
      for (let item of this.itemDetails) data['itemDetails'].push(item.toJSON());
    }
    data['shippingRequestId'] = this.shippingRequestId;
    data['itemPrice'] = this.itemPrice;
    data['channel'] = this.channel;
    data['parentId'] = this.parentId;
    data['commissionPercentageOrAddValue'] = this.commissionPercentageOrAddValue;
    data['commissionType'] = this.commissionType;
    data['vasCommissionPercentageOrAddValue'] = this.vasCommissionPercentageOrAddValue;
    data['vasCommissionType'] = this.vasCommissionType;
    return data;
  }
}

export interface ICreateOrEditPriceOfferInput {
  itemDetails: PriceOfferDetailDto[] | undefined;
  shippingRequestId: number;
  itemPrice: number;
  channel: PriceOfferChannel;
  parentId: number | undefined;
  commissionPercentageOrAddValue: number | undefined;
  commissionType: PriceOfferCommissionType;
  vasCommissionPercentageOrAddValue: number | undefined;
  vasCommissionType: PriceOfferCommissionType;
}

export enum ShippingRequestType {
  Marketplace = 1,
  DirectRequest = 2,
  TachyonManageService = 3,
}

export enum ShippingRequestRouteType {
  SingleDrop = 1,
  TwoWay = 2,
  MultipleDrops = 3,
}

export enum ShippingRequestBidStatus {
  StandBy = 0,
  OnGoing = 1,
  Closed = 2,
  Cancled = 3,
}

export enum ShippingRequestDirectRequestStatus {
  New = 0,
  Response = 1,
  Accepted = 2,
  Rejected = 3,
  Declined = 5,
  Pending = 6,
}

export class GetShippingRequestForPriceOfferListDto implements IGetShippingRequestForPriceOfferListDto {
  directRequestId!: number | undefined;
  offerId!: number | undefined;
  name!: string | undefined;
  carrier!: string | undefined;
  creationTime!: moment.Moment | undefined;
  isTachyonDeal!: boolean;
  originCity!: string | undefined;
  destinationCity!: string | undefined;
  trukType!: string | undefined;
  isPriced!: boolean;
  remainingDays!: string | undefined;
  rangeDate!: string | undefined;
  numberOfDrops!: number;
  numberOfTrips!: number;
  goodsCategory!: string | undefined;
  totalWeight!: number;
  totalOffers!: number;
  bidStatus!: ShippingRequestBidStatus;
  status!: ShippingRequestStatus;
  directRequestStatus!: ShippingRequestDirectRequestStatus;
  offerStatus!: PriceOfferStatus;
  statusTitle!: string | undefined;
  bidStatusTitle!: string | undefined;
  directRequestStatusTitle!: string | undefined;
  routeTypeId!: ShippingRequestRouteType;
  readonly routeType!: string | undefined;
  price!: number | undefined;
  id!: number;

  constructor(data?: IGetShippingRequestForPriceOfferListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.directRequestId = _data['directRequestId'];
      this.offerId = _data['offerId'];
      this.name = _data['name'];
      this.carrier = _data['carrier'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.originCity = _data['originCity'];
      this.destinationCity = _data['destinationCity'];
      this.trukType = _data['trukType'];
      this.isPriced = _data['isPriced'];
      this.remainingDays = _data['remainingDays'];
      this.rangeDate = _data['rangeDate'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.numberOfTrips = _data['numberOfTrips'];
      this.goodsCategory = _data['goodsCategory'];
      this.totalWeight = _data['totalWeight'];
      this.totalOffers = _data['totalOffers'];
      this.bidStatus = _data['bidStatus'];
      this.status = _data['status'];
      this.directRequestStatus = _data['directRequestStatus'];
      this.offerStatus = _data['offerStatus'];
      this.statusTitle = _data['statusTitle'];
      this.bidStatusTitle = _data['bidStatusTitle'];
      this.directRequestStatusTitle = _data['directRequestStatusTitle'];
      this.routeTypeId = _data['routeTypeId'];
      (<any>this).routeType = _data['routeType'];
      this.price = _data['price'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GetShippingRequestForPriceOfferListDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestForPriceOfferListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['directRequestId'] = this.directRequestId;
    data['offerId'] = this.offerId;
    data['name'] = this.name;
    data['carrier'] = this.carrier;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['originCity'] = this.originCity;
    data['destinationCity'] = this.destinationCity;
    data['trukType'] = this.trukType;
    data['isPriced'] = this.isPriced;
    data['remainingDays'] = this.remainingDays;
    data['rangeDate'] = this.rangeDate;
    data['numberOfDrops'] = this.numberOfDrops;
    data['numberOfTrips'] = this.numberOfTrips;
    data['goodsCategory'] = this.goodsCategory;
    data['totalWeight'] = this.totalWeight;
    data['totalOffers'] = this.totalOffers;
    data['bidStatus'] = this.bidStatus;
    data['status'] = this.status;
    data['directRequestStatus'] = this.directRequestStatus;
    data['offerStatus'] = this.offerStatus;
    data['statusTitle'] = this.statusTitle;
    data['bidStatusTitle'] = this.bidStatusTitle;
    data['directRequestStatusTitle'] = this.directRequestStatusTitle;
    data['routeTypeId'] = this.routeTypeId;
    data['routeType'] = this.routeType;
    data['price'] = this.price;
    data['id'] = this.id;
    return data;
  }
}

export interface IGetShippingRequestForPriceOfferListDto {
  directRequestId: number | undefined;
  offerId: number | undefined;
  name: string | undefined;
  carrier: string | undefined;
  creationTime: moment.Moment | undefined;
  isTachyonDeal: boolean;
  originCity: string | undefined;
  destinationCity: string | undefined;
  trukType: string | undefined;
  isPriced: boolean;
  remainingDays: string | undefined;
  rangeDate: string | undefined;
  numberOfDrops: number;
  numberOfTrips: number;
  goodsCategory: string | undefined;
  totalWeight: number;
  totalOffers: number;
  bidStatus: ShippingRequestBidStatus;
  status: ShippingRequestStatus;
  directRequestStatus: ShippingRequestDirectRequestStatus;
  offerStatus: PriceOfferStatus;
  statusTitle: string | undefined;
  bidStatusTitle: string | undefined;
  directRequestStatusTitle: string | undefined;
  routeTypeId: ShippingRequestRouteType;
  routeType: string | undefined;
  price: number | undefined;
  id: number;
}

export class ListResultDtoOfGetShippingRequestForPriceOfferListDto implements IListResultDtoOfGetShippingRequestForPriceOfferListDto {
  items!: GetShippingRequestForPriceOfferListDto[] | undefined;

  constructor(data?: IListResultDtoOfGetShippingRequestForPriceOfferListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetShippingRequestForPriceOfferListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfGetShippingRequestForPriceOfferListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfGetShippingRequestForPriceOfferListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfGetShippingRequestForPriceOfferListDto {
  items: GetShippingRequestForPriceOfferListDto[] | undefined;
}

export class RejectPriceOfferInput implements IRejectPriceOfferInput {
  reason!: string;
  id!: number;

  constructor(data?: IRejectPriceOfferInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reason = _data['reason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RejectPriceOfferInput {
    data = typeof data === 'object' ? data : {};
    let result = new RejectPriceOfferInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reason'] = this.reason;
    data['id'] = this.id;
    return data;
  }
}

export interface IRejectPriceOfferInput {
  reason: string;
  id: number;
}

export class PriceOfferItemDto implements IPriceOfferItemDto {
  parentItemId!: number;
  itemId!: number;
  itemName!: string | undefined;
  priceType!: PriceOfferType;
  price!: number | undefined;
  quantity!: number;

  constructor(data?: IPriceOfferItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentItemId = _data['parentItemId'];
      this.itemId = _data['itemId'];
      this.itemName = _data['itemName'];
      this.priceType = _data['priceType'];
      this.price = _data['price'];
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): PriceOfferItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceOfferItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentItemId'] = this.parentItemId;
    data['itemId'] = this.itemId;
    data['itemName'] = this.itemName;
    data['priceType'] = this.priceType;
    data['price'] = this.price;
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IPriceOfferItemDto {
  parentItemId: number;
  itemId: number;
  itemName: string | undefined;
  priceType: PriceOfferType;
  price: number | undefined;
  quantity: number;
}

export class GetShippingRequestForPricingOutput implements IGetShippingRequestForPricingOutput {
  items!: PriceOfferItemDto[] | undefined;
  offerId!: number;
  shipper!: string | undefined;
  creationTime!: moment.Moment;
  isTachyonDeal!: boolean;
  originCity!: string | undefined;
  destinationCity!: string | undefined;
  trukType!: string | undefined;
  isPriced!: boolean;
  rangeDate!: string | undefined;
  numberOfDrops!: number;
  numberOfTrips!: number;
  goodsCategory!: string | undefined;
  totalWeight!: number;
  totalBids!: number;
  bidStatus!: ShippingRequestBidStatus;
  status!: ShippingRequestStatus;
  id!: number;

  constructor(data?: IGetShippingRequestForPricingOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PriceOfferItemDto.fromJS(item));
      }
      this.offerId = _data['offerId'];
      this.shipper = _data['shipper'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.originCity = _data['originCity'];
      this.destinationCity = _data['destinationCity'];
      this.trukType = _data['trukType'];
      this.isPriced = _data['isPriced'];
      this.rangeDate = _data['rangeDate'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.numberOfTrips = _data['numberOfTrips'];
      this.goodsCategory = _data['goodsCategory'];
      this.totalWeight = _data['totalWeight'];
      this.totalBids = _data['totalBids'];
      this.bidStatus = _data['bidStatus'];
      this.status = _data['status'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GetShippingRequestForPricingOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestForPricingOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['offerId'] = this.offerId;
    data['shipper'] = this.shipper;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['originCity'] = this.originCity;
    data['destinationCity'] = this.destinationCity;
    data['trukType'] = this.trukType;
    data['isPriced'] = this.isPriced;
    data['rangeDate'] = this.rangeDate;
    data['numberOfDrops'] = this.numberOfDrops;
    data['numberOfTrips'] = this.numberOfTrips;
    data['goodsCategory'] = this.goodsCategory;
    data['totalWeight'] = this.totalWeight;
    data['totalBids'] = this.totalBids;
    data['bidStatus'] = this.bidStatus;
    data['status'] = this.status;
    data['id'] = this.id;
    return data;
  }
}

export interface IGetShippingRequestForPricingOutput {
  items: PriceOfferItemDto[] | undefined;
  offerId: number;
  shipper: string | undefined;
  creationTime: moment.Moment;
  isTachyonDeal: boolean;
  originCity: string | undefined;
  destinationCity: string | undefined;
  trukType: string | undefined;
  isPriced: boolean;
  rangeDate: string | undefined;
  numberOfDrops: number;
  numberOfTrips: number;
  goodsCategory: string | undefined;
  totalWeight: number;
  totalBids: number;
  bidStatus: ShippingRequestBidStatus;
  status: ShippingRequestStatus;
  id: number;
}

export class CancelShippingRequestInput implements ICancelShippingRequestInput {
  cancelReason!: string;
  id!: number;

  constructor(data?: ICancelShippingRequestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cancelReason = _data['cancelReason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CancelShippingRequestInput {
    data = typeof data === 'object' ? data : {};
    let result = new CancelShippingRequestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cancelReason'] = this.cancelReason;
    data['id'] = this.id;
    return data;
  }
}

export interface ICancelShippingRequestInput {
  cancelReason: string;
  id: number;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
  name!: string;
  surname!: string;
  userName!: string;
  emailAddress!: string;
  phoneNumber!: string | undefined;
  isPhoneNumberConfirmed!: boolean;
  timezone!: string | undefined;
  qrCodeSetupImageUrl!: string | undefined;
  isGoogleAuthenticatorEnabled!: boolean;

  constructor(data?: ICurrentUserProfileEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.phoneNumber = _data['phoneNumber'];
      this.isPhoneNumberConfirmed = _data['isPhoneNumberConfirmed'];
      this.timezone = _data['timezone'];
      this.qrCodeSetupImageUrl = _data['qrCodeSetupImageUrl'];
      this.isGoogleAuthenticatorEnabled = _data['isGoogleAuthenticatorEnabled'];
    }
  }

  static fromJS(data: any): CurrentUserProfileEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new CurrentUserProfileEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['phoneNumber'] = this.phoneNumber;
    data['isPhoneNumberConfirmed'] = this.isPhoneNumberConfirmed;
    data['timezone'] = this.timezone;
    data['qrCodeSetupImageUrl'] = this.qrCodeSetupImageUrl;
    data['isGoogleAuthenticatorEnabled'] = this.isGoogleAuthenticatorEnabled;
    return data;
  }
}

export interface ICurrentUserProfileEditDto {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  phoneNumber: string | undefined;
  isPhoneNumberConfirmed: boolean;
  timezone: string | undefined;
  qrCodeSetupImageUrl: string | undefined;
  isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
  qrCodeSetupImageUrl!: string | undefined;

  constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.qrCodeSetupImageUrl = _data['qrCodeSetupImageUrl'];
    }
  }

  static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateGoogleAuthenticatorKeyOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['qrCodeSetupImageUrl'] = this.qrCodeSetupImageUrl;
    return data;
  }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
  qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
  phoneNumber!: string | undefined;

  constructor(data?: ISendVerificationSmsInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): SendVerificationSmsInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new SendVerificationSmsInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface ISendVerificationSmsInputDto {
  phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
  code!: string | undefined;
  phoneNumber!: string | undefined;

  constructor(data?: IVerifySmsCodeInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): VerifySmsCodeInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new VerifySmsCodeInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IVerifySmsCodeInputDto {
  code: string | undefined;
  phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
  currentPassword!: string;
  newPassword!: string;

  constructor(data?: IChangePasswordInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data['currentPassword'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordInput {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['currentPassword'] = this.currentPassword;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IChangePasswordInput {
  currentPassword: string;
  newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
  fileToken!: string | undefined;
  x!: number;
  y!: number;
  width!: number;
  height!: number;
  useGravatarProfilePicture!: boolean;

  constructor(data?: IUpdateProfilePictureInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileToken = _data['fileToken'];
      this.x = _data['x'];
      this.y = _data['y'];
      this.width = _data['width'];
      this.height = _data['height'];
      this.useGravatarProfilePicture = _data['useGravatarProfilePicture'];
    }
  }

  static fromJS(data: any): UpdateProfilePictureInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProfilePictureInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileToken'] = this.fileToken;
    data['x'] = this.x;
    data['y'] = this.y;
    data['width'] = this.width;
    data['height'] = this.height;
    data['useGravatarProfilePicture'] = this.useGravatarProfilePicture;
    return data;
  }
}

export interface IUpdateProfilePictureInput {
  fileToken: string | undefined;
  x: number;
  y: number;
  width: number;
  height: number;
  useGravatarProfilePicture: boolean;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
  setting!: PasswordComplexitySetting;

  constructor(data?: IGetPasswordComplexitySettingOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.setting = _data['setting'] ? PasswordComplexitySetting.fromJS(_data['setting']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetPasswordComplexitySettingOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPasswordComplexitySettingOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['setting'] = this.setting ? this.setting.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetPasswordComplexitySettingOutput {
  setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
  profilePicture!: string | undefined;

  constructor(data?: IGetProfilePictureOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.profilePicture = _data['profilePicture'];
    }
  }

  static fromJS(data: any): GetProfilePictureOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetProfilePictureOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['profilePicture'] = this.profilePicture;
    return data;
  }
}

export interface IGetProfilePictureOutput {
  profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName!: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data['languageName'];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['languageName'] = this.languageName;
    return data;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class ReceiverDto implements IReceiverDto {
  fullName!: string | undefined;
  email!: string | undefined;
  phoneNumber!: string | undefined;
  facilityId!: number;
  id!: number;

  constructor(data?: IReceiverDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.facilityId = _data['facilityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ReceiverDto {
    data = typeof data === 'object' ? data : {};
    let result = new ReceiverDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['facilityId'] = this.facilityId;
    data['id'] = this.id;
    return data;
  }
}

export interface IReceiverDto {
  fullName: string | undefined;
  email: string | undefined;
  phoneNumber: string | undefined;
  facilityId: number;
  id: number;
}

export class GetReceiverForViewDto implements IGetReceiverForViewDto {
  receiver!: ReceiverDto;
  facilityName!: string | undefined;
  creationTime!: moment.Moment;

  constructor(data?: IGetReceiverForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.receiver = _data['receiver'] ? ReceiverDto.fromJS(_data['receiver']) : <any>undefined;
      this.facilityName = _data['facilityName'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetReceiverForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetReceiverForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['receiver'] = this.receiver ? this.receiver.toJSON() : <any>undefined;
    data['facilityName'] = this.facilityName;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetReceiverForViewDto {
  receiver: ReceiverDto;
  facilityName: string | undefined;
  creationTime: moment.Moment;
}

export class PagedResultDtoOfGetReceiverForViewDto implements IPagedResultDtoOfGetReceiverForViewDto {
  totalCount!: number;
  items!: GetReceiverForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetReceiverForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetReceiverForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetReceiverForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetReceiverForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetReceiverForViewDto {
  totalCount: number;
  items: GetReceiverForViewDto[] | undefined;
}

export class CreateOrEditReceiverDto implements ICreateOrEditReceiverDto {
  fullName!: string;
  email!: string | undefined;
  phoneNumber!: string;
  facilityId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditReceiverDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.facilityId = _data['facilityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditReceiverDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditReceiverDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['facilityId'] = this.facilityId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditReceiverDto {
  fullName: string;
  email: string | undefined;
  phoneNumber: string;
  facilityId: number;
  id: number | undefined;
}

export class GetReceiverForEditOutput implements IGetReceiverForEditOutput {
  receiver!: CreateOrEditReceiverDto;
  facilityName!: string | undefined;

  constructor(data?: IGetReceiverForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.receiver = _data['receiver'] ? CreateOrEditReceiverDto.fromJS(_data['receiver']) : <any>undefined;
      this.facilityName = _data['facilityName'];
    }
  }

  static fromJS(data: any): GetReceiverForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetReceiverForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['receiver'] = this.receiver ? this.receiver.toJSON() : <any>undefined;
    data['facilityName'] = this.facilityName;
    return data;
  }
}

export interface IGetReceiverForEditOutput {
  receiver: CreateOrEditReceiverDto;
  facilityName: string | undefined;
}

export class ReceiverFacilityLookupTableDto implements IReceiverFacilityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IReceiverFacilityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): ReceiverFacilityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new ReceiverFacilityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IReceiverFacilityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class RoleListDto implements IRoleListDto {
  name!: string | undefined;
  displayName!: string | undefined;
  isStatic!: boolean;
  isDefault!: boolean;
  creationTime!: moment.Moment;
  id!: number;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.isStatic = _data['isStatic'];
      this.isDefault = _data['isDefault'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['isStatic'] = this.isStatic;
    data['isDefault'] = this.isDefault;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IRoleListDto {
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;
  id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
  items!: RoleListDto[] | undefined;

  constructor(data?: IListResultDtoOfRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfRoleListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfRoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfRoleListDto {
  items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
  id!: number | undefined;
  displayName!: string;
  isDefault!: boolean;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.isDefault = _data['isDefault'];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['isDefault'] = this.isDefault;
    return data;
  }
}

export interface IRoleEditDto {
  id: number | undefined;
  displayName: string;
  isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  parentName!: string | undefined;
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;
  isGrantedByDefault!: boolean;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentName = _data['parentName'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.isGrantedByDefault = _data['isGrantedByDefault'];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentName'] = this.parentName;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['isGrantedByDefault'] = this.isGrantedByDefault;
    return data;
  }
}

export interface IFlatPermissionDto {
  parentName: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role!: RoleEditDto;
  permissions!: FlatPermissionDto[] | undefined;
  grantedPermissionNames!: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data['role'] ? RoleEditDto.fromJS(_data['role']) : <any>undefined;
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions']) this.permissions!.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data['grantedPermissionNames'])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames!.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['role'] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data['grantedPermissionNames'] = [];
      for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
    }
    return data;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
  role!: RoleEditDto;
  grantedPermissionNames!: string[];

  constructor(data?: ICreateOrUpdateRoleInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.role = new RoleEditDto();
      this.grantedPermissionNames = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data['role'] ? RoleEditDto.fromJS(_data['role']) : new RoleEditDto();
      if (Array.isArray(_data['grantedPermissionNames'])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateOrUpdateRoleInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrUpdateRoleInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['role'] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.grantedPermissionNames)) {
      data['grantedPermissionNames'] = [];
      for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
    }
    return data;
  }
}

export interface ICreateOrUpdateRoleInput {
  role: RoleEditDto;
  grantedPermissionNames: string[];
}

export class RouteDto implements IRouteDto {
  displayName!: string | undefined;
  description!: string | undefined;
  routTypeId!: number | undefined;
  originCityId!: number;
  destinationCityId!: number;
  id!: number;

  constructor(data?: IRouteDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.routTypeId = _data['routTypeId'];
      this.originCityId = _data['originCityId'];
      this.destinationCityId = _data['destinationCityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RouteDto {
    data = typeof data === 'object' ? data : {};
    let result = new RouteDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['routTypeId'] = this.routTypeId;
    data['originCityId'] = this.originCityId;
    data['destinationCityId'] = this.destinationCityId;
    data['id'] = this.id;
    return data;
  }
}

export interface IRouteDto {
  displayName: string | undefined;
  description: string | undefined;
  routTypeId: number | undefined;
  originCityId: number;
  destinationCityId: number;
  id: number;
}

export class GetRouteForViewDto implements IGetRouteForViewDto {
  route!: RouteDto;
  routTypeDisplayName!: string | undefined;

  constructor(data?: IGetRouteForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.route = _data['route'] ? RouteDto.fromJS(_data['route']) : <any>undefined;
      this.routTypeDisplayName = _data['routTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetRouteForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetRouteForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['route'] = this.route ? this.route.toJSON() : <any>undefined;
    data['routTypeDisplayName'] = this.routTypeDisplayName;
    return data;
  }
}

export interface IGetRouteForViewDto {
  route: RouteDto;
  routTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetRouteForViewDto implements IPagedResultDtoOfGetRouteForViewDto {
  totalCount!: number;
  items!: GetRouteForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetRouteForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetRouteForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetRouteForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetRouteForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetRouteForViewDto {
  totalCount: number;
  items: GetRouteForViewDto[] | undefined;
}

export class CreateOrEditRouteDto implements ICreateOrEditRouteDto {
  displayName!: string | undefined;
  description!: string | undefined;
  routTypeId!: number | undefined;
  originPortId!: number | undefined;
  destinationPortId!: number | undefined;
  originCityId!: number;
  destinationCityId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditRouteDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.routTypeId = _data['routTypeId'];
      this.originPortId = _data['originPortId'];
      this.destinationPortId = _data['destinationPortId'];
      this.originCityId = _data['originCityId'];
      this.destinationCityId = _data['destinationCityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditRouteDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditRouteDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['routTypeId'] = this.routTypeId;
    data['originPortId'] = this.originPortId;
    data['destinationPortId'] = this.destinationPortId;
    data['originCityId'] = this.originCityId;
    data['destinationCityId'] = this.destinationCityId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditRouteDto {
  displayName: string | undefined;
  description: string | undefined;
  routTypeId: number | undefined;
  originPortId: number | undefined;
  destinationPortId: number | undefined;
  originCityId: number;
  destinationCityId: number;
  id: number | undefined;
}

export class GetRouteForEditOutput implements IGetRouteForEditOutput {
  route!: CreateOrEditRouteDto;
  routTypeDisplayName!: string | undefined;

  constructor(data?: IGetRouteForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.route = _data['route'] ? CreateOrEditRouteDto.fromJS(_data['route']) : <any>undefined;
      this.routTypeDisplayName = _data['routTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetRouteForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRouteForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['route'] = this.route ? this.route.toJSON() : <any>undefined;
    data['routTypeDisplayName'] = this.routTypeDisplayName;
    return data;
  }
}

export interface IGetRouteForEditOutput {
  route: CreateOrEditRouteDto;
  routTypeDisplayName: string | undefined;
}

export class RouteRoutTypeLookupTableDto implements IRouteRoutTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IRouteRoutTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): RouteRoutTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new RouteRoutTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IRouteRoutTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export enum PickingType {
  Pickup = 1,
  Dropoff = 2,
}

export class RoutPointDto implements IRoutPointDto {
  waybillNumber!: number | undefined;
  displayName!: string | undefined;
  pickingType!: PickingType;
  facilityId!: number;
  facility!: string | undefined;
  longitude!: number;
  latitude!: number;
  shippingRequestTripId!: number;
  startTime!: moment.Moment | undefined;
  endTime!: moment.Moment | undefined;
  isActive!: boolean;
  isComplete!: boolean;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  rating!: number | undefined;
  receiverId!: number | undefined;
  receiverFullName!: string | undefined;
  receiverPhoneNumber!: string | undefined;
  receiverEmailAddress!: string | undefined;
  receiverCardIdNumber!: string | undefined;
  goodsDetailListDto!: GoodsDetailDto[] | undefined;
  note!: string | undefined;
  id!: number;

  constructor(data?: IRoutPointDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.waybillNumber = _data['waybillNumber'];
      this.displayName = _data['displayName'];
      this.pickingType = _data['pickingType'];
      this.facilityId = _data['facilityId'];
      this.facility = _data['facility'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.shippingRequestTripId = _data['shippingRequestTripId'];
      this.startTime = _data['startTime'] ? moment(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? moment(_data['endTime'].toString()) : <any>undefined;
      this.isActive = _data['isActive'];
      this.isComplete = _data['isComplete'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.rating = _data['rating'];
      this.receiverId = _data['receiverId'];
      this.receiverFullName = _data['receiverFullName'];
      this.receiverPhoneNumber = _data['receiverPhoneNumber'];
      this.receiverEmailAddress = _data['receiverEmailAddress'];
      this.receiverCardIdNumber = _data['receiverCardIdNumber'];
      if (Array.isArray(_data['goodsDetailListDto'])) {
        this.goodsDetailListDto = [] as any;
        for (let item of _data['goodsDetailListDto']) this.goodsDetailListDto!.push(GoodsDetailDto.fromJS(item));
      }
      this.note = _data['note'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoutPointDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutPointDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['waybillNumber'] = this.waybillNumber;
    data['displayName'] = this.displayName;
    data['pickingType'] = this.pickingType;
    data['facilityId'] = this.facilityId;
    data['facility'] = this.facility;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['shippingRequestTripId'] = this.shippingRequestTripId;
    data['startTime'] = this.startTime ? this.startTime.toISOString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toISOString() : <any>undefined;
    data['isActive'] = this.isActive;
    data['isComplete'] = this.isComplete;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['rating'] = this.rating;
    data['receiverId'] = this.receiverId;
    data['receiverFullName'] = this.receiverFullName;
    data['receiverPhoneNumber'] = this.receiverPhoneNumber;
    data['receiverEmailAddress'] = this.receiverEmailAddress;
    data['receiverCardIdNumber'] = this.receiverCardIdNumber;
    if (Array.isArray(this.goodsDetailListDto)) {
      data['goodsDetailListDto'] = [];
      for (let item of this.goodsDetailListDto) data['goodsDetailListDto'].push(item.toJSON());
    }
    data['note'] = this.note;
    data['id'] = this.id;
    return data;
  }
}

export interface IRoutPointDto {
  waybillNumber: number | undefined;
  displayName: string | undefined;
  pickingType: PickingType;
  facilityId: number;
  facility: string | undefined;
  longitude: number;
  latitude: number;
  shippingRequestTripId: number;
  startTime: moment.Moment | undefined;
  endTime: moment.Moment | undefined;
  isActive: boolean;
  isComplete: boolean;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  rating: number | undefined;
  receiverId: number | undefined;
  receiverFullName: string | undefined;
  receiverPhoneNumber: string | undefined;
  receiverEmailAddress: string | undefined;
  receiverCardIdNumber: string | undefined;
  goodsDetailListDto: GoodsDetailDto[] | undefined;
  note: string | undefined;
  id: number;
}

export class GetRoutPointForViewOutput implements IGetRoutPointForViewOutput {
  routPointDto!: RoutPointDto;
  pickingTypeDisplayName!: string | undefined;
  facilityDto!: GetFacilityForViewOutput;
  goodsDetailsList!: GoodsDetailDto[] | undefined;

  constructor(data?: IGetRoutPointForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routPointDto = _data['routPointDto'] ? RoutPointDto.fromJS(_data['routPointDto']) : <any>undefined;
      this.pickingTypeDisplayName = _data['pickingTypeDisplayName'];
      this.facilityDto = _data['facilityDto'] ? GetFacilityForViewOutput.fromJS(_data['facilityDto']) : <any>undefined;
      if (Array.isArray(_data['goodsDetailsList'])) {
        this.goodsDetailsList = [] as any;
        for (let item of _data['goodsDetailsList']) this.goodsDetailsList!.push(GoodsDetailDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetRoutPointForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoutPointForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routPointDto'] = this.routPointDto ? this.routPointDto.toJSON() : <any>undefined;
    data['pickingTypeDisplayName'] = this.pickingTypeDisplayName;
    data['facilityDto'] = this.facilityDto ? this.facilityDto.toJSON() : <any>undefined;
    if (Array.isArray(this.goodsDetailsList)) {
      data['goodsDetailsList'] = [];
      for (let item of this.goodsDetailsList) data['goodsDetailsList'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetRoutPointForViewOutput {
  routPointDto: RoutPointDto;
  pickingTypeDisplayName: string | undefined;
  facilityDto: GetFacilityForViewOutput;
  goodsDetailsList: GoodsDetailDto[] | undefined;
}

export class PagedResultDtoOfGetRoutPointForViewOutput implements IPagedResultDtoOfGetRoutPointForViewOutput {
  totalCount!: number;
  items!: GetRoutPointForViewOutput[] | undefined;

  constructor(data?: IPagedResultDtoOfGetRoutPointForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetRoutPointForViewOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetRoutPointForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetRoutPointForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetRoutPointForViewOutput {
  totalCount: number;
  items: GetRoutPointForViewOutput[] | undefined;
}

export class CreateOrEditRoutPointDto implements ICreateOrEditRoutPointDto {
  displayName!: string | undefined;
  pickingType!: PickingType;
  facilityId!: number;
  longitude!: number;
  latitude!: number;
  receiverId!: number | undefined;
  receiverFullName!: string | undefined;
  receiverPhoneNumber!: string | undefined;
  receiverEmailAddress!: string | undefined;
  receiverCardIdNumber!: string | undefined;
  note!: string | undefined;
  goodsDetailListDto!: CreateOrEditGoodsDetailDto[] | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditRoutPointDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.pickingType = _data['pickingType'];
      this.facilityId = _data['facilityId'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.receiverId = _data['receiverId'];
      this.receiverFullName = _data['receiverFullName'];
      this.receiverPhoneNumber = _data['receiverPhoneNumber'];
      this.receiverEmailAddress = _data['receiverEmailAddress'];
      this.receiverCardIdNumber = _data['receiverCardIdNumber'];
      this.note = _data['note'];
      if (Array.isArray(_data['goodsDetailListDto'])) {
        this.goodsDetailListDto = [] as any;
        for (let item of _data['goodsDetailListDto']) this.goodsDetailListDto!.push(CreateOrEditGoodsDetailDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditRoutPointDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditRoutPointDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['pickingType'] = this.pickingType;
    data['facilityId'] = this.facilityId;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['receiverId'] = this.receiverId;
    data['receiverFullName'] = this.receiverFullName;
    data['receiverPhoneNumber'] = this.receiverPhoneNumber;
    data['receiverEmailAddress'] = this.receiverEmailAddress;
    data['receiverCardIdNumber'] = this.receiverCardIdNumber;
    data['note'] = this.note;
    if (Array.isArray(this.goodsDetailListDto)) {
      data['goodsDetailListDto'] = [];
      for (let item of this.goodsDetailListDto) data['goodsDetailListDto'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditRoutPointDto {
  displayName: string | undefined;
  pickingType: PickingType;
  facilityId: number;
  longitude: number;
  latitude: number;
  receiverId: number | undefined;
  receiverFullName: string | undefined;
  receiverPhoneNumber: string | undefined;
  receiverEmailAddress: string | undefined;
  receiverCardIdNumber: string | undefined;
  note: string | undefined;
  goodsDetailListDto: CreateOrEditGoodsDetailDto[] | undefined;
  id: number | undefined;
}

export class GetDropsDetailsForMasterWaybillOutput implements IGetDropsDetailsForMasterWaybillOutput {
  code!: string | undefined;
  receiverDisplayName!: string | undefined;

  constructor(data?: IGetDropsDetailsForMasterWaybillOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.receiverDisplayName = _data['receiverDisplayName'];
    }
  }

  static fromJS(data: any): GetDropsDetailsForMasterWaybillOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDropsDetailsForMasterWaybillOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['receiverDisplayName'] = this.receiverDisplayName;
    return data;
  }
}

export interface IGetDropsDetailsForMasterWaybillOutput {
  code: string | undefined;
  receiverDisplayName: string | undefined;
}

export class RoutStepDto implements IRoutStepDto {
  displayName!: string | undefined;
  order!: number;
  shippingRequestId!: number;
  assignedDriverUserId!: number;
  assignedTruckId!: number;
  assignedTrailerId!: number | undefined;
  trucksTypeId!: number | undefined;
  trailerTypeId!: number | undefined;
  sourceRoutPointId!: number;
  destinationRoutPointId!: number;
  totalAmount!: number;
  existingAmount!: number;
  remainingAmount!: number;
  id!: number;

  constructor(data?: IRoutStepDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.order = _data['order'];
      this.shippingRequestId = _data['shippingRequestId'];
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.assignedTruckId = _data['assignedTruckId'];
      this.assignedTrailerId = _data['assignedTrailerId'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.trailerTypeId = _data['trailerTypeId'];
      this.sourceRoutPointId = _data['sourceRoutPointId'];
      this.destinationRoutPointId = _data['destinationRoutPointId'];
      this.totalAmount = _data['totalAmount'];
      this.existingAmount = _data['existingAmount'];
      this.remainingAmount = _data['remainingAmount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoutStepDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutStepDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['order'] = this.order;
    data['shippingRequestId'] = this.shippingRequestId;
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['assignedTruckId'] = this.assignedTruckId;
    data['assignedTrailerId'] = this.assignedTrailerId;
    data['trucksTypeId'] = this.trucksTypeId;
    data['trailerTypeId'] = this.trailerTypeId;
    data['sourceRoutPointId'] = this.sourceRoutPointId;
    data['destinationRoutPointId'] = this.destinationRoutPointId;
    data['totalAmount'] = this.totalAmount;
    data['existingAmount'] = this.existingAmount;
    data['remainingAmount'] = this.remainingAmount;
    data['id'] = this.id;
    return data;
  }
}

export interface IRoutStepDto {
  displayName: string | undefined;
  order: number;
  shippingRequestId: number;
  assignedDriverUserId: number;
  assignedTruckId: number;
  assignedTrailerId: number | undefined;
  trucksTypeId: number | undefined;
  trailerTypeId: number | undefined;
  sourceRoutPointId: number;
  destinationRoutPointId: number;
  totalAmount: number;
  existingAmount: number;
  remainingAmount: number;
  id: number;
}

export class GetRoutStepForViewOutput implements IGetRoutStepForViewOutput {
  routStep!: RoutStepDto;
  trucksTypeDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  sourceRoutPointDto!: GetRoutPointForViewOutput;
  destinationRoutPointDto!: GetRoutPointForViewOutput;

  constructor(data?: IGetRoutStepForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routStep = _data['routStep'] ? RoutStepDto.fromJS(_data['routStep']) : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.sourceRoutPointDto = _data['sourceRoutPointDto'] ? GetRoutPointForViewOutput.fromJS(_data['sourceRoutPointDto']) : <any>undefined;
      this.destinationRoutPointDto = _data['destinationRoutPointDto']
        ? GetRoutPointForViewOutput.fromJS(_data['destinationRoutPointDto'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetRoutStepForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoutStepForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routStep'] = this.routStep ? this.routStep.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['sourceRoutPointDto'] = this.sourceRoutPointDto ? this.sourceRoutPointDto.toJSON() : <any>undefined;
    data['destinationRoutPointDto'] = this.destinationRoutPointDto ? this.destinationRoutPointDto.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetRoutStepForViewOutput {
  routStep: RoutStepDto;
  trucksTypeDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  sourceRoutPointDto: GetRoutPointForViewOutput;
  destinationRoutPointDto: GetRoutPointForViewOutput;
}

export class PagedResultDtoOfGetRoutStepForViewOutput implements IPagedResultDtoOfGetRoutStepForViewOutput {
  totalCount!: number;
  items!: GetRoutStepForViewOutput[] | undefined;

  constructor(data?: IPagedResultDtoOfGetRoutStepForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetRoutStepForViewOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetRoutStepForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetRoutStepForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetRoutStepForViewOutput {
  totalCount: number;
  items: GetRoutStepForViewOutput[] | undefined;
}

export class GetRoutStepForEditOutput implements IGetRoutStepForEditOutput {
  routStep!: RoutStepDto;
  routeDisplayName!: string | undefined;
  order!: number;
  assignedDriverUserId!: number | undefined;
  assignedTruckId!: number | undefined;
  assignedTruckDisplayName!: string | undefined;
  assignedDriverDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  sourceRoutPointDto!: GetRoutPointForViewOutput;
  destinationRoutPointDto!: GetRoutPointForViewOutput;

  constructor(data?: IGetRoutStepForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routStep = _data['routStep'] ? RoutStepDto.fromJS(_data['routStep']) : <any>undefined;
      this.routeDisplayName = _data['routeDisplayName'];
      this.order = _data['order'];
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.assignedTruckId = _data['assignedTruckId'];
      this.assignedTruckDisplayName = _data['assignedTruckDisplayName'];
      this.assignedDriverDisplayName = _data['assignedDriverDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.sourceRoutPointDto = _data['sourceRoutPointDto'] ? GetRoutPointForViewOutput.fromJS(_data['sourceRoutPointDto']) : <any>undefined;
      this.destinationRoutPointDto = _data['destinationRoutPointDto']
        ? GetRoutPointForViewOutput.fromJS(_data['destinationRoutPointDto'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetRoutStepForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoutStepForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routStep'] = this.routStep ? this.routStep.toJSON() : <any>undefined;
    data['routeDisplayName'] = this.routeDisplayName;
    data['order'] = this.order;
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['assignedTruckId'] = this.assignedTruckId;
    data['assignedTruckDisplayName'] = this.assignedTruckDisplayName;
    data['assignedDriverDisplayName'] = this.assignedDriverDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['sourceRoutPointDto'] = this.sourceRoutPointDto ? this.sourceRoutPointDto.toJSON() : <any>undefined;
    data['destinationRoutPointDto'] = this.destinationRoutPointDto ? this.destinationRoutPointDto.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetRoutStepForEditOutput {
  routStep: RoutStepDto;
  routeDisplayName: string | undefined;
  order: number;
  assignedDriverUserId: number | undefined;
  assignedTruckId: number | undefined;
  assignedTruckDisplayName: string | undefined;
  assignedDriverDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  sourceRoutPointDto: GetRoutPointForViewOutput;
  destinationRoutPointDto: GetRoutPointForViewOutput;
}

export class CreateOrEditRoutStepDto implements ICreateOrEditRoutStepDto {
  displayName!: string | undefined;
  order!: number;
  shippingRequestId!: number | undefined;
  assignedDriverUserId!: number | undefined;
  assignedTruckId!: number | undefined;
  assignedTrailerId!: number | undefined;
  totalAmount!: number;
  existingAmount!: number;
  remainingAmount!: number;
  createOrEditSourceRoutPointInputDto!: CreateOrEditRoutPointDto;
  createOrEditDestinationRoutPointInputDto!: CreateOrEditRoutPointDto;
  id!: number | undefined;

  constructor(data?: ICreateOrEditRoutStepDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.createOrEditSourceRoutPointInputDto = new CreateOrEditRoutPointDto();
      this.createOrEditDestinationRoutPointInputDto = new CreateOrEditRoutPointDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.order = _data['order'];
      this.shippingRequestId = _data['shippingRequestId'];
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.assignedTruckId = _data['assignedTruckId'];
      this.assignedTrailerId = _data['assignedTrailerId'];
      this.totalAmount = _data['totalAmount'];
      this.existingAmount = _data['existingAmount'];
      this.remainingAmount = _data['remainingAmount'];
      this.createOrEditSourceRoutPointInputDto = _data['createOrEditSourceRoutPointInputDto']
        ? CreateOrEditRoutPointDto.fromJS(_data['createOrEditSourceRoutPointInputDto'])
        : new CreateOrEditRoutPointDto();
      this.createOrEditDestinationRoutPointInputDto = _data['createOrEditDestinationRoutPointInputDto']
        ? CreateOrEditRoutPointDto.fromJS(_data['createOrEditDestinationRoutPointInputDto'])
        : new CreateOrEditRoutPointDto();
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditRoutStepDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditRoutStepDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['order'] = this.order;
    data['shippingRequestId'] = this.shippingRequestId;
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['assignedTruckId'] = this.assignedTruckId;
    data['assignedTrailerId'] = this.assignedTrailerId;
    data['totalAmount'] = this.totalAmount;
    data['existingAmount'] = this.existingAmount;
    data['remainingAmount'] = this.remainingAmount;
    data['createOrEditSourceRoutPointInputDto'] = this.createOrEditSourceRoutPointInputDto
      ? this.createOrEditSourceRoutPointInputDto.toJSON()
      : <any>undefined;
    data['createOrEditDestinationRoutPointInputDto'] = this.createOrEditDestinationRoutPointInputDto
      ? this.createOrEditDestinationRoutPointInputDto.toJSON()
      : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditRoutStepDto {
  displayName: string | undefined;
  order: number;
  shippingRequestId: number | undefined;
  assignedDriverUserId: number | undefined;
  assignedTruckId: number | undefined;
  assignedTrailerId: number | undefined;
  totalAmount: number;
  existingAmount: number;
  remainingAmount: number;
  createOrEditSourceRoutPointInputDto: CreateOrEditRoutPointDto;
  createOrEditDestinationRoutPointInputDto: CreateOrEditRoutPointDto;
  id: number | undefined;
}

export class RoutStepCityLookupTableDto implements IRoutStepCityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IRoutStepCityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): RoutStepCityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutStepCityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IRoutStepCityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class RoutStepRouteLookupTableDto implements IRoutStepRouteLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IRoutStepRouteLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): RoutStepRouteLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutStepRouteLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IRoutStepRouteLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class FacilityForDropdownDto implements IFacilityForDropdownDto {
  id!: number;
  displayName!: string | undefined;
  long!: number;
  lat!: number;

  constructor(data?: IFacilityForDropdownDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.long = _data['long'];
      this.lat = _data['lat'];
    }
  }

  static fromJS(data: any): FacilityForDropdownDto {
    data = typeof data === 'object' ? data : {};
    let result = new FacilityForDropdownDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['long'] = this.long;
    data['lat'] = this.lat;
    return data;
  }
}

export interface IFacilityForDropdownDto {
  id: number;
  displayName: string | undefined;
  long: number;
  lat: number;
}

export class RoutTypeDto implements IRoutTypeDto {
  displayName!: string | undefined;
  description!: string | undefined;
  id!: number;

  constructor(data?: IRoutTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoutTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface IRoutTypeDto {
  displayName: string | undefined;
  description: string | undefined;
  id: number;
}

export class GetRoutTypeForViewDto implements IGetRoutTypeForViewDto {
  routType!: RoutTypeDto;

  constructor(data?: IGetRoutTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routType = _data['routType'] ? RoutTypeDto.fromJS(_data['routType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetRoutTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoutTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routType'] = this.routType ? this.routType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetRoutTypeForViewDto {
  routType: RoutTypeDto;
}

export class PagedResultDtoOfGetRoutTypeForViewDto implements IPagedResultDtoOfGetRoutTypeForViewDto {
  totalCount!: number;
  items!: GetRoutTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetRoutTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetRoutTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetRoutTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetRoutTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetRoutTypeForViewDto {
  totalCount: number;
  items: GetRoutTypeForViewDto[] | undefined;
}

export class CreateOrEditRoutTypeDto implements ICreateOrEditRoutTypeDto {
  displayName!: string;
  description!: string | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditRoutTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditRoutTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditRoutTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditRoutTypeDto {
  displayName: string;
  description: string | undefined;
  id: number | undefined;
}

export class GetRoutTypeForEditOutput implements IGetRoutTypeForEditOutput {
  routType!: CreateOrEditRoutTypeDto;

  constructor(data?: IGetRoutTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routType = _data['routType'] ? CreateOrEditRoutTypeDto.fromJS(_data['routType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetRoutTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoutTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routType'] = this.routType ? this.routType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetRoutTypeForEditOutput {
  routType: CreateOrEditRoutTypeDto;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  name!: string | undefined;
  surname!: string | undefined;
  userName!: string | undefined;
  emailAddress!: string | undefined;
  profilePictureId!: string | undefined;
  id!: number;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.profilePictureId = _data['profilePictureId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['profilePictureId'] = this.profilePictureId;
    data['id'] = this.id;
    return data;
  }
}

export interface IUserLoginInfoDto {
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  profilePictureId: string | undefined;
  id: number;
}

export enum SubscriptionPaymentType {
  Manual = 0,
  RecurringAutomatic = 1,
  RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
  displayName!: string | undefined;
  trialDayCount!: number | undefined;
  monthlyPrice!: number | undefined;
  annualPrice!: number | undefined;
  isHighestEdition!: boolean;
  isFree!: boolean;
  id!: number;

  constructor(data?: IEditionInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.trialDayCount = _data['trialDayCount'];
      this.monthlyPrice = _data['monthlyPrice'];
      this.annualPrice = _data['annualPrice'];
      this.isHighestEdition = _data['isHighestEdition'];
      this.isFree = _data['isFree'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EditionInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['trialDayCount'] = this.trialDayCount;
    data['monthlyPrice'] = this.monthlyPrice;
    data['annualPrice'] = this.annualPrice;
    data['isHighestEdition'] = this.isHighestEdition;
    data['isFree'] = this.isFree;
    data['id'] = this.id;
    return data;
  }
}

export interface IEditionInfoDto {
  displayName: string | undefined;
  trialDayCount: number | undefined;
  monthlyPrice: number | undefined;
  annualPrice: number | undefined;
  isHighestEdition: boolean;
  isFree: boolean;
  id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  tenancyName!: string | undefined;
  name!: string | undefined;
  logoId!: string | undefined;
  logoFileType!: string | undefined;
  customCssId!: string | undefined;
  subscriptionEndDateUtc!: moment.Moment | undefined;
  isInTrialPeriod!: boolean;
  subscriptionPaymentType!: SubscriptionPaymentType;
  edition!: EditionInfoDto;
  creationTime!: moment.Moment;
  paymentPeriodType!: PaymentPeriodType;
  subscriptionDateString!: string | undefined;
  creationTimeString!: string | undefined;
  missingRequiredDocumentTypes!: DocumentTypeDto[] | undefined;
  id!: number;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.logoId = _data['logoId'];
      this.logoFileType = _data['logoFileType'];
      this.customCssId = _data['customCssId'];
      this.subscriptionEndDateUtc = _data['subscriptionEndDateUtc'] ? moment(_data['subscriptionEndDateUtc'].toString()) : <any>undefined;
      this.isInTrialPeriod = _data['isInTrialPeriod'];
      this.subscriptionPaymentType = _data['subscriptionPaymentType'];
      this.edition = _data['edition'] ? EditionInfoDto.fromJS(_data['edition']) : <any>undefined;
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.paymentPeriodType = _data['paymentPeriodType'];
      this.subscriptionDateString = _data['subscriptionDateString'];
      this.creationTimeString = _data['creationTimeString'];
      if (Array.isArray(_data['missingRequiredDocumentTypes'])) {
        this.missingRequiredDocumentTypes = [] as any;
        for (let item of _data['missingRequiredDocumentTypes']) this.missingRequiredDocumentTypes!.push(DocumentTypeDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['logoId'] = this.logoId;
    data['logoFileType'] = this.logoFileType;
    data['customCssId'] = this.customCssId;
    data['subscriptionEndDateUtc'] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
    data['isInTrialPeriod'] = this.isInTrialPeriod;
    data['subscriptionPaymentType'] = this.subscriptionPaymentType;
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['paymentPeriodType'] = this.paymentPeriodType;
    data['subscriptionDateString'] = this.subscriptionDateString;
    data['creationTimeString'] = this.creationTimeString;
    if (Array.isArray(this.missingRequiredDocumentTypes)) {
      data['missingRequiredDocumentTypes'] = [];
      for (let item of this.missingRequiredDocumentTypes) data['missingRequiredDocumentTypes'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ITenantLoginInfoDto {
  tenancyName: string | undefined;
  name: string | undefined;
  logoId: string | undefined;
  logoFileType: string | undefined;
  customCssId: string | undefined;
  subscriptionEndDateUtc: moment.Moment | undefined;
  isInTrialPeriod: boolean;
  subscriptionPaymentType: SubscriptionPaymentType;
  edition: EditionInfoDto;
  creationTime: moment.Moment;
  paymentPeriodType: PaymentPeriodType;
  subscriptionDateString: string | undefined;
  creationTimeString: string | undefined;
  missingRequiredDocumentTypes: DocumentTypeDto[] | undefined;
  id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version!: string | undefined;
  releaseDate!: moment.Moment;
  currency!: string | undefined;
  currencySign!: string | undefined;
  allowTenantsToChangeEmailSettings!: boolean;
  userDelegationIsEnabled!: boolean;
  features!: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data['version'];
      this.releaseDate = _data['releaseDate'] ? moment(_data['releaseDate'].toString()) : <any>undefined;
      this.currency = _data['currency'];
      this.currencySign = _data['currencySign'];
      this.allowTenantsToChangeEmailSettings = _data['allowTenantsToChangeEmailSettings'];
      this.userDelegationIsEnabled = _data['userDelegationIsEnabled'];
      if (_data['features']) {
        this.features = {} as any;
        for (let key in _data['features']) {
          if (_data['features'].hasOwnProperty(key)) this.features![key] = _data['features'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['version'] = this.version;
    data['releaseDate'] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
    data['currency'] = this.currency;
    data['currencySign'] = this.currencySign;
    data['allowTenantsToChangeEmailSettings'] = this.allowTenantsToChangeEmailSettings;
    data['userDelegationIsEnabled'] = this.userDelegationIsEnabled;
    if (this.features) {
      data['features'] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key)) data['features'][key] = this.features[key];
      }
    }
    return data;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  currency: string | undefined;
  currencySign: string | undefined;
  allowTenantsToChangeEmailSettings: boolean;
  userDelegationIsEnabled: boolean;
  features: { [key: string]: boolean } | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
  layoutType!: string | undefined;

  constructor(data?: IThemeLayoutSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.layoutType = _data['layoutType'];
    }
  }

  static fromJS(data: any): ThemeLayoutSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeLayoutSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['layoutType'] = this.layoutType;
    return data;
  }
}

export interface IThemeLayoutSettingsDto {
  layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
  desktopFixedHeader!: boolean;
  mobileFixedHeader!: boolean;
  headerSkin!: string | undefined;
  minimizeDesktopHeaderType!: string | undefined;

  constructor(data?: IThemeHeaderSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.desktopFixedHeader = _data['desktopFixedHeader'];
      this.mobileFixedHeader = _data['mobileFixedHeader'];
      this.headerSkin = _data['headerSkin'];
      this.minimizeDesktopHeaderType = _data['minimizeDesktopHeaderType'];
    }
  }

  static fromJS(data: any): ThemeHeaderSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeHeaderSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['desktopFixedHeader'] = this.desktopFixedHeader;
    data['mobileFixedHeader'] = this.mobileFixedHeader;
    data['headerSkin'] = this.headerSkin;
    data['minimizeDesktopHeaderType'] = this.minimizeDesktopHeaderType;
    return data;
  }
}

export interface IThemeHeaderSettingsDto {
  desktopFixedHeader: boolean;
  mobileFixedHeader: boolean;
  headerSkin: string | undefined;
  minimizeDesktopHeaderType: string | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
  fixedSubHeader!: boolean;
  subheaderStyle!: string | undefined;
  subheaderSize!: number;
  titleStlye!: string | undefined;
  containerStyle!: string | undefined;

  constructor(data?: IThemeSubHeaderSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixedSubHeader = _data['fixedSubHeader'];
      this.subheaderStyle = _data['subheaderStyle'];
      this.subheaderSize = _data['subheaderSize'];
      this.titleStlye = _data['titleStlye'];
      this.containerStyle = _data['containerStyle'];
    }
  }

  static fromJS(data: any): ThemeSubHeaderSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeSubHeaderSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixedSubHeader'] = this.fixedSubHeader;
    data['subheaderStyle'] = this.subheaderStyle;
    data['subheaderSize'] = this.subheaderSize;
    data['titleStlye'] = this.titleStlye;
    data['containerStyle'] = this.containerStyle;
    return data;
  }
}

export interface IThemeSubHeaderSettingsDto {
  fixedSubHeader: boolean;
  subheaderStyle: string | undefined;
  subheaderSize: number;
  titleStlye: string | undefined;
  containerStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
  position!: string | undefined;
  asideSkin!: string | undefined;
  fixedAside!: boolean;
  allowAsideMinimizing!: boolean;
  defaultMinimizedAside!: boolean;
  submenuToggle!: string | undefined;
  searchActive!: boolean;
  enableSecondary!: boolean;

  constructor(data?: IThemeMenuSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.position = _data['position'];
      this.asideSkin = _data['asideSkin'];
      this.fixedAside = _data['fixedAside'];
      this.allowAsideMinimizing = _data['allowAsideMinimizing'];
      this.defaultMinimizedAside = _data['defaultMinimizedAside'];
      this.submenuToggle = _data['submenuToggle'];
      this.searchActive = _data['searchActive'];
      this.enableSecondary = _data['enableSecondary'];
    }
  }

  static fromJS(data: any): ThemeMenuSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeMenuSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['position'] = this.position;
    data['asideSkin'] = this.asideSkin;
    data['fixedAside'] = this.fixedAside;
    data['allowAsideMinimizing'] = this.allowAsideMinimizing;
    data['defaultMinimizedAside'] = this.defaultMinimizedAside;
    data['submenuToggle'] = this.submenuToggle;
    data['searchActive'] = this.searchActive;
    data['enableSecondary'] = this.enableSecondary;
    return data;
  }
}

export interface IThemeMenuSettingsDto {
  position: string | undefined;
  asideSkin: string | undefined;
  fixedAside: boolean;
  allowAsideMinimizing: boolean;
  defaultMinimizedAside: boolean;
  submenuToggle: string | undefined;
  searchActive: boolean;
  enableSecondary: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
  fixedFooter!: boolean;

  constructor(data?: IThemeFooterSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixedFooter = _data['fixedFooter'];
    }
  }

  static fromJS(data: any): ThemeFooterSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeFooterSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixedFooter'] = this.fixedFooter;
    return data;
  }
}

export interface IThemeFooterSettingsDto {
  fixedFooter: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
  theme!: string | undefined;
  layout!: ThemeLayoutSettingsDto;
  header!: ThemeHeaderSettingsDto;
  subHeader!: ThemeSubHeaderSettingsDto;
  menu!: ThemeMenuSettingsDto;
  footer!: ThemeFooterSettingsDto;

  constructor(data?: IThemeSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data['theme'];
      this.layout = _data['layout'] ? ThemeLayoutSettingsDto.fromJS(_data['layout']) : <any>undefined;
      this.header = _data['header'] ? ThemeHeaderSettingsDto.fromJS(_data['header']) : <any>undefined;
      this.subHeader = _data['subHeader'] ? ThemeSubHeaderSettingsDto.fromJS(_data['subHeader']) : <any>undefined;
      this.menu = _data['menu'] ? ThemeMenuSettingsDto.fromJS(_data['menu']) : <any>undefined;
      this.footer = _data['footer'] ? ThemeFooterSettingsDto.fromJS(_data['footer']) : <any>undefined;
    }
  }

  static fromJS(data: any): ThemeSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ThemeSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['theme'] = this.theme;
    data['layout'] = this.layout ? this.layout.toJSON() : <any>undefined;
    data['header'] = this.header ? this.header.toJSON() : <any>undefined;
    data['subHeader'] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
    data['menu'] = this.menu ? this.menu.toJSON() : <any>undefined;
    data['footer'] = this.footer ? this.footer.toJSON() : <any>undefined;
    return data;
  }
}

export interface IThemeSettingsDto {
  theme: string | undefined;
  layout: ThemeLayoutSettingsDto;
  header: ThemeHeaderSettingsDto;
  subHeader: ThemeSubHeaderSettingsDto;
  menu: ThemeMenuSettingsDto;
  footer: ThemeFooterSettingsDto;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
  baseSettings!: ThemeSettingsDto;
  isLeftMenuUsed!: boolean;
  isTopMenuUsed!: boolean;
  isTabMenuUsed!: boolean;
  allowMenuScroll!: boolean;

  constructor(data?: IUiCustomizationSettingsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseSettings = _data['baseSettings'] ? ThemeSettingsDto.fromJS(_data['baseSettings']) : <any>undefined;
      this.isLeftMenuUsed = _data['isLeftMenuUsed'];
      this.isTopMenuUsed = _data['isTopMenuUsed'];
      this.isTabMenuUsed = _data['isTabMenuUsed'];
      this.allowMenuScroll = _data['allowMenuScroll'];
    }
  }

  static fromJS(data: any): UiCustomizationSettingsDto {
    data = typeof data === 'object' ? data : {};
    let result = new UiCustomizationSettingsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['baseSettings'] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
    data['isLeftMenuUsed'] = this.isLeftMenuUsed;
    data['isTopMenuUsed'] = this.isTopMenuUsed;
    data['isTabMenuUsed'] = this.isTabMenuUsed;
    data['allowMenuScroll'] = this.allowMenuScroll;
    return data;
  }
}

export interface IUiCustomizationSettingsDto {
  baseSettings: ThemeSettingsDto;
  isLeftMenuUsed: boolean;
  isTopMenuUsed: boolean;
  isTabMenuUsed: boolean;
  allowMenuScroll: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
  user!: UserLoginInfoDto;
  impersonatorUser!: UserLoginInfoDto;
  tenant!: TenantLoginInfoDto;
  impersonatorTenant!: TenantLoginInfoDto;
  application!: ApplicationInfoDto;
  theme!: UiCustomizationSettingsDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data['user'] ? UserLoginInfoDto.fromJS(_data['user']) : <any>undefined;
      this.impersonatorUser = _data['impersonatorUser'] ? UserLoginInfoDto.fromJS(_data['impersonatorUser']) : <any>undefined;
      this.tenant = _data['tenant'] ? TenantLoginInfoDto.fromJS(_data['tenant']) : <any>undefined;
      this.impersonatorTenant = _data['impersonatorTenant'] ? TenantLoginInfoDto.fromJS(_data['impersonatorTenant']) : <any>undefined;
      this.application = _data['application'] ? ApplicationInfoDto.fromJS(_data['application']) : <any>undefined;
      this.theme = _data['theme'] ? UiCustomizationSettingsDto.fromJS(_data['theme']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    data['impersonatorUser'] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
    data['tenant'] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    data['impersonatorTenant'] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
    data['application'] = this.application ? this.application.toJSON() : <any>undefined;
    data['theme'] = this.theme ? this.theme.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  user: UserLoginInfoDto;
  impersonatorUser: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;
  impersonatorTenant: TenantLoginInfoDto;
  application: ApplicationInfoDto;
  theme: UiCustomizationSettingsDto;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
  signInToken!: string | undefined;
  encodedUserId!: string | undefined;
  encodedTenantId!: string | undefined;

  constructor(data?: IUpdateUserSignInTokenOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.signInToken = _data['signInToken'];
      this.encodedUserId = _data['encodedUserId'];
      this.encodedTenantId = _data['encodedTenantId'];
    }
  }

  static fromJS(data: any): UpdateUserSignInTokenOutput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserSignInTokenOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['signInToken'] = this.signInToken;
    data['encodedUserId'] = this.encodedUserId;
    data['encodedTenantId'] = this.encodedTenantId;
    return data;
  }
}

export interface IUpdateUserSignInTokenOutput {
  signInToken: string | undefined;
  encodedUserId: string | undefined;
  encodedTenantId: string | undefined;
}

export class ShippingRequestDirectRequestListDto implements IShippingRequestDirectRequestListDto {
  carrier!: string | undefined;
  status!: ShippingRequestDirectRequestStatus;
  readonly statusTitle!: string | undefined;
  rejetcReason!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestDirectRequestListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.carrier = _data['carrier'];
      this.status = _data['status'];
      (<any>this).statusTitle = _data['statusTitle'];
      this.rejetcReason = _data['rejetcReason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestDirectRequestListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestDirectRequestListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['carrier'] = this.carrier;
    data['status'] = this.status;
    data['statusTitle'] = this.statusTitle;
    data['rejetcReason'] = this.rejetcReason;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestDirectRequestListDto {
  carrier: string | undefined;
  status: ShippingRequestDirectRequestStatus;
  statusTitle: string | undefined;
  rejetcReason: string | undefined;
  id: number;
}

export class PagedResultDtoOfShippingRequestDirectRequestListDto implements IPagedResultDtoOfShippingRequestDirectRequestListDto {
  totalCount!: number;
  items!: ShippingRequestDirectRequestListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfShippingRequestDirectRequestListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestDirectRequestListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfShippingRequestDirectRequestListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfShippingRequestDirectRequestListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfShippingRequestDirectRequestListDto {
  totalCount: number;
  items: ShippingRequestDirectRequestListDto[] | undefined;
}

export class ShippingRequestDirectRequestGetCarrirerListDto implements IShippingRequestDirectRequestGetCarrirerListDto {
  name!: string | undefined;
  isRequestSent!: boolean;
  id!: number;

  constructor(data?: IShippingRequestDirectRequestGetCarrirerListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.isRequestSent = _data['isRequestSent'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestDirectRequestGetCarrirerListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestDirectRequestGetCarrirerListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['isRequestSent'] = this.isRequestSent;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestDirectRequestGetCarrirerListDto {
  name: string | undefined;
  isRequestSent: boolean;
  id: number;
}

export class PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto
  implements IPagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto {
  totalCount!: number;
  items!: ShippingRequestDirectRequestGetCarrirerListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestDirectRequestGetCarrirerListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfShippingRequestDirectRequestGetCarrirerListDto {
  totalCount: number;
  items: ShippingRequestDirectRequestGetCarrirerListDto[] | undefined;
}

export class CreateShippingRequestDirectRequestInput implements ICreateShippingRequestDirectRequestInput {
  shippingRequestId!: number;
  carrierTenantId!: number;

  constructor(data?: ICreateShippingRequestDirectRequestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestId = _data['shippingRequestId'];
      this.carrierTenantId = _data['carrierTenantId'];
    }
  }

  static fromJS(data: any): CreateShippingRequestDirectRequestInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateShippingRequestDirectRequestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestId'] = this.shippingRequestId;
    data['carrierTenantId'] = this.carrierTenantId;
    return data;
  }
}

export interface ICreateShippingRequestDirectRequestInput {
  shippingRequestId: number;
  carrierTenantId: number;
}

export class RejectShippingRequestDirectRequestInput implements IRejectShippingRequestDirectRequestInput {
  reason!: string;
  id!: number;

  constructor(data?: IRejectShippingRequestDirectRequestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reason = _data['reason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RejectShippingRequestDirectRequestInput {
    data = typeof data === 'object' ? data : {};
    let result = new RejectShippingRequestDirectRequestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reason'] = this.reason;
    data['id'] = this.id;
    return data;
  }
}

export interface IRejectShippingRequestDirectRequestInput {
  reason: string;
  id: number;
}

export enum ShippingRequestTripDriverLoadStatusDto {
  Current = 0,
  Comming = 1,
  Past = 2,
}

export enum ShippingRequestTripStatus {
  New = 0,
  Intransit = 1,
  Canceled = 2,
  Delivered = 3,
}

export enum ShippingRequestTripDriverStatus {
  None = 0,
  Accepted = 1,
  Rejected = 2,
}

export class ShippingRequestTripDriverListDto implements IShippingRequestTripDriverListDto {
  startDate!: moment.Moment;
  endDate!: moment.Moment;
  routeTypeId!: ShippingRequestRouteType;
  source!: string | undefined;
  distination!: string | undefined;
  driverLoadStatus!: ShippingRequestTripDriverLoadStatusDto;
  status!: ShippingRequestTripStatus;
  statusTitle!: string | undefined;
  driverStatus!: ShippingRequestTripDriverStatus;
  waybillNumber!: number | undefined;
  id!: number;

  constructor(data?: IShippingRequestTripDriverListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startDate = _data['startDate'] ? moment(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? moment(_data['endDate'].toString()) : <any>undefined;
      this.routeTypeId = _data['routeTypeId'];
      this.source = _data['source'];
      this.distination = _data['distination'];
      this.driverLoadStatus = _data['driverLoadStatus'];
      this.status = _data['status'];
      this.statusTitle = _data['statusTitle'];
      this.driverStatus = _data['driverStatus'];
      this.waybillNumber = _data['waybillNumber'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripDriverListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripDriverListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['routeTypeId'] = this.routeTypeId;
    data['source'] = this.source;
    data['distination'] = this.distination;
    data['driverLoadStatus'] = this.driverLoadStatus;
    data['status'] = this.status;
    data['statusTitle'] = this.statusTitle;
    data['driverStatus'] = this.driverStatus;
    data['waybillNumber'] = this.waybillNumber;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripDriverListDto {
  startDate: moment.Moment;
  endDate: moment.Moment;
  routeTypeId: ShippingRequestRouteType;
  source: string | undefined;
  distination: string | undefined;
  driverLoadStatus: ShippingRequestTripDriverLoadStatusDto;
  status: ShippingRequestTripStatus;
  statusTitle: string | undefined;
  driverStatus: ShippingRequestTripDriverStatus;
  waybillNumber: number | undefined;
  id: number;
}

export class PagedResultDtoOfShippingRequestTripDriverListDto implements IPagedResultDtoOfShippingRequestTripDriverListDto {
  totalCount!: number;
  items!: ShippingRequestTripDriverListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfShippingRequestTripDriverListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestTripDriverListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfShippingRequestTripDriverListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfShippingRequestTripDriverListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfShippingRequestTripDriverListDto {
  totalCount: number;
  items: ShippingRequestTripDriverListDto[] | undefined;
}

export class ShippingRequestTripDriverRoutePointDto implements IShippingRequestTripDriverRoutePointDto {
  displayName!: string | undefined;
  pickingType!: PickingType;
  facility!: string | undefined;
  address!: string | undefined;
  lat!: number;
  lng!: number;
  startTime!: moment.Moment | undefined;
  endTime!: moment.Moment | undefined;
  isActive!: boolean;
  isComplete!: boolean;
  rating!: number | undefined;
  id!: number;

  constructor(data?: IShippingRequestTripDriverRoutePointDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.pickingType = _data['pickingType'];
      this.facility = _data['facility'];
      this.address = _data['address'];
      this.lat = _data['lat'];
      this.lng = _data['lng'];
      this.startTime = _data['startTime'] ? moment(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? moment(_data['endTime'].toString()) : <any>undefined;
      this.isActive = _data['isActive'];
      this.isComplete = _data['isComplete'];
      this.rating = _data['rating'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripDriverRoutePointDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripDriverRoutePointDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['pickingType'] = this.pickingType;
    data['facility'] = this.facility;
    data['address'] = this.address;
    data['lat'] = this.lat;
    data['lng'] = this.lng;
    data['startTime'] = this.startTime ? this.startTime.toISOString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toISOString() : <any>undefined;
    data['isActive'] = this.isActive;
    data['isComplete'] = this.isComplete;
    data['rating'] = this.rating;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripDriverRoutePointDto {
  displayName: string | undefined;
  pickingType: PickingType;
  facility: string | undefined;
  address: string | undefined;
  lat: number;
  lng: number;
  startTime: moment.Moment | undefined;
  endTime: moment.Moment | undefined;
  isActive: boolean;
  isComplete: boolean;
  rating: number | undefined;
  id: number;
}

export enum RoutePointStatus {
  StandBy = 0,
  StartedMovingToLoadingLocation = 1,
  ArriveToLoadingLocation = 2,
  StartLoading = 3,
  FinishLoading = 4,
  StartedMovingToOfLoadingLocation = 5,
  ArrivedToDestination = 6,
  StartOffloading = 7,
  FinishOffLoadShipment = 8,
  ReceiverConfirmed = 9,
  DeliveryConfirmation = 10,
  Delivered = 11,
  Issue = 12,
}

export enum ShippingRequestTripDriverActionStatusDto {
  None = 0,
  CanStartTrip = 1,
  ContinueTrip = 2,
}

export class ShippingRequestTripDriverDetailsDto implements IShippingRequestTripDriverDetailsDto {
  routePoints!: ShippingRequestTripDriverRoutePointDto[] | undefined;
  startTripDate!: string | undefined;
  endTripDate!: string | undefined;
  travelTime!: string | undefined;
  packingType!: string | undefined;
  goodsCategory!: string | undefined;
  totalWeight!: number;
  unitOfMeasure!: string | undefined;
  note!: string | undefined;
  source!: string | undefined;
  distination!: string | undefined;
  status!: RoutePointStatus;
  tripStatus!: ShippingRequestTripStatus;
  statusTitle!: string | undefined;
  actionStatus!: ShippingRequestTripDriverActionStatusDto;
  driverStatus!: ShippingRequestTripDriverStatus;
  changeStatusButtonTitle!: string | undefined;
  isConfirmReceiver!: boolean;
  waybillNumber!: number | undefined;
  plateNumber!: string | undefined;
  truckType!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestTripDriverDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['routePoints'])) {
        this.routePoints = [] as any;
        for (let item of _data['routePoints']) this.routePoints!.push(ShippingRequestTripDriverRoutePointDto.fromJS(item));
      }
      this.startTripDate = _data['startTripDate'];
      this.endTripDate = _data['endTripDate'];
      this.travelTime = _data['travelTime'];
      this.packingType = _data['packingType'];
      this.goodsCategory = _data['goodsCategory'];
      this.totalWeight = _data['totalWeight'];
      this.unitOfMeasure = _data['unitOfMeasure'];
      this.note = _data['note'];
      this.source = _data['source'];
      this.distination = _data['distination'];
      this.status = _data['status'];
      this.tripStatus = _data['tripStatus'];
      this.statusTitle = _data['statusTitle'];
      this.actionStatus = _data['actionStatus'];
      this.driverStatus = _data['driverStatus'];
      this.changeStatusButtonTitle = _data['changeStatusButtonTitle'];
      this.isConfirmReceiver = _data['isConfirmReceiver'];
      this.waybillNumber = _data['waybillNumber'];
      this.plateNumber = _data['plateNumber'];
      this.truckType = _data['truckType'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripDriverDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripDriverDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.routePoints)) {
      data['routePoints'] = [];
      for (let item of this.routePoints) data['routePoints'].push(item.toJSON());
    }
    data['startTripDate'] = this.startTripDate;
    data['endTripDate'] = this.endTripDate;
    data['travelTime'] = this.travelTime;
    data['packingType'] = this.packingType;
    data['goodsCategory'] = this.goodsCategory;
    data['totalWeight'] = this.totalWeight;
    data['unitOfMeasure'] = this.unitOfMeasure;
    data['note'] = this.note;
    data['source'] = this.source;
    data['distination'] = this.distination;
    data['status'] = this.status;
    data['tripStatus'] = this.tripStatus;
    data['statusTitle'] = this.statusTitle;
    data['actionStatus'] = this.actionStatus;
    data['driverStatus'] = this.driverStatus;
    data['changeStatusButtonTitle'] = this.changeStatusButtonTitle;
    data['isConfirmReceiver'] = this.isConfirmReceiver;
    data['waybillNumber'] = this.waybillNumber;
    data['plateNumber'] = this.plateNumber;
    data['truckType'] = this.truckType;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripDriverDetailsDto {
  routePoints: ShippingRequestTripDriverRoutePointDto[] | undefined;
  startTripDate: string | undefined;
  endTripDate: string | undefined;
  travelTime: string | undefined;
  packingType: string | undefined;
  goodsCategory: string | undefined;
  totalWeight: number;
  unitOfMeasure: string | undefined;
  note: string | undefined;
  source: string | undefined;
  distination: string | undefined;
  status: RoutePointStatus;
  tripStatus: ShippingRequestTripStatus;
  statusTitle: string | undefined;
  actionStatus: ShippingRequestTripDriverActionStatusDto;
  driverStatus: ShippingRequestTripDriverStatus;
  changeStatusButtonTitle: string | undefined;
  isConfirmReceiver: boolean;
  waybillNumber: number | undefined;
  plateNumber: string | undefined;
  truckType: string | undefined;
  id: number;
}

export class RoutDropOffDto implements IRoutDropOffDto {
  facility!: string | undefined;
  address!: string | undefined;
  longitude!: number;
  latitude!: number;
  packagingType!: string | undefined;
  rating!: number | undefined;
  receiverFullName!: string | undefined;
  receiverPhoneNumber!: string | undefined;
  receiverEmailAddress!: string | undefined;
  receiverCardIdNumber!: string | undefined;
  note!: string | undefined;
  goodsDetailListDto!: GoodsDetailDto[] | undefined;
  id!: number;

  constructor(data?: IRoutDropOffDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.facility = _data['facility'];
      this.address = _data['address'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.packagingType = _data['packagingType'];
      this.rating = _data['rating'];
      this.receiverFullName = _data['receiverFullName'];
      this.receiverPhoneNumber = _data['receiverPhoneNumber'];
      this.receiverEmailAddress = _data['receiverEmailAddress'];
      this.receiverCardIdNumber = _data['receiverCardIdNumber'];
      this.note = _data['note'];
      if (Array.isArray(_data['goodsDetailListDto'])) {
        this.goodsDetailListDto = [] as any;
        for (let item of _data['goodsDetailListDto']) this.goodsDetailListDto!.push(GoodsDetailDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): RoutDropOffDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoutDropOffDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['facility'] = this.facility;
    data['address'] = this.address;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['packagingType'] = this.packagingType;
    data['rating'] = this.rating;
    data['receiverFullName'] = this.receiverFullName;
    data['receiverPhoneNumber'] = this.receiverPhoneNumber;
    data['receiverEmailAddress'] = this.receiverEmailAddress;
    data['receiverCardIdNumber'] = this.receiverCardIdNumber;
    data['note'] = this.note;
    if (Array.isArray(this.goodsDetailListDto)) {
      data['goodsDetailListDto'] = [];
      for (let item of this.goodsDetailListDto) data['goodsDetailListDto'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface IRoutDropOffDto {
  facility: string | undefined;
  address: string | undefined;
  longitude: number;
  latitude: number;
  packagingType: string | undefined;
  rating: number | undefined;
  receiverFullName: string | undefined;
  receiverPhoneNumber: string | undefined;
  receiverEmailAddress: string | undefined;
  receiverCardIdNumber: string | undefined;
  note: string | undefined;
  goodsDetailListDto: GoodsDetailDto[] | undefined;
  id: number;
}

export class ShippingRequestTripDriverStartInputDto implements IShippingRequestTripDriverStartInputDto {
  lat!: number;
  lng!: number;
  id!: number;

  constructor(data?: IShippingRequestTripDriverStartInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lat = _data['lat'];
      this.lng = _data['lng'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripDriverStartInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripDriverStartInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['lat'] = this.lat;
    data['lng'] = this.lng;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripDriverStartInputDto {
  lat: number;
  lng: number;
  id: number;
}

export class ShippingRequestReasonAccidentListDto implements IShippingRequestReasonAccidentListDto {
  name!: string | undefined;
  isDeleted!: boolean;
  deleterUserId!: number | undefined;
  deletionTime!: moment.Moment | undefined;
  lastModificationTime!: moment.Moment | undefined;
  lastModifierUserId!: number | undefined;
  creationTime!: moment.Moment;
  creatorUserId!: number | undefined;
  id!: number;

  constructor(data?: IShippingRequestReasonAccidentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.isDeleted = _data['isDeleted'];
      this.deleterUserId = _data['deleterUserId'];
      this.deletionTime = _data['deletionTime'] ? moment(_data['deletionTime'].toString()) : <any>undefined;
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
      this.lastModifierUserId = _data['lastModifierUserId'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.creatorUserId = _data['creatorUserId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestReasonAccidentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestReasonAccidentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['isDeleted'] = this.isDeleted;
    data['deleterUserId'] = this.deleterUserId;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data['lastModifierUserId'] = this.lastModifierUserId;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['creatorUserId'] = this.creatorUserId;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestReasonAccidentListDto {
  name: string | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  id: number;
}

export class ListResultDtoOfShippingRequestReasonAccidentListDto implements IListResultDtoOfShippingRequestReasonAccidentListDto {
  items!: ShippingRequestReasonAccidentListDto[] | undefined;

  constructor(data?: IListResultDtoOfShippingRequestReasonAccidentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestReasonAccidentListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfShippingRequestReasonAccidentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfShippingRequestReasonAccidentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfShippingRequestReasonAccidentListDto {
  items: ShippingRequestReasonAccidentListDto[] | undefined;
}

export class ShippingRequestReasonAccidentTranslationDto implements IShippingRequestReasonAccidentTranslationDto {
  name!: string;
  language!: string;
  icon!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: IShippingRequestReasonAccidentTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.language = _data['language'];
      this.icon = _data['icon'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): ShippingRequestReasonAccidentTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestReasonAccidentTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['language'] = this.language;
    data['icon'] = this.icon;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IShippingRequestReasonAccidentTranslationDto {
  name: string;
  language: string;
  icon: string | undefined;
  displayName: string | undefined;
}

export class CreateOrEditShippingRequestReasonAccidentDto implements ICreateOrEditShippingRequestReasonAccidentDto {
  translations!: ShippingRequestReasonAccidentTranslationDto[] | undefined;
  id!: number;

  constructor(data?: ICreateOrEditShippingRequestReasonAccidentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(ShippingRequestReasonAccidentTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestReasonAccidentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestReasonAccidentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestReasonAccidentDto {
  translations: ShippingRequestReasonAccidentTranslationDto[] | undefined;
  id: number;
}

export class ShippingRequestListDto implements IShippingRequestListDto {
  tenant!: string | undefined;
  isBid!: boolean;
  isTachyonDeal!: boolean;
  isDirectRequest!: boolean;
  totalBids!: number;
  numberOfTrips!: number;
  numberOfDrops!: number;
  hasAccident!: boolean;
  totalsTripsAddByShippier!: number;
  status!: ShippingRequestStatus;
  readonly statusTitle!: string | undefined;
  origin!: string | undefined;
  destination!: string | undefined;
  routeType!: string | undefined;
  isDrafted!: boolean;
  draftStep!: number;
  id!: number;

  constructor(data?: IShippingRequestListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenant = _data['tenant'];
      this.isBid = _data['isBid'];
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.isDirectRequest = _data['isDirectRequest'];
      this.totalBids = _data['totalBids'];
      this.numberOfTrips = _data['numberOfTrips'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.hasAccident = _data['hasAccident'];
      this.totalsTripsAddByShippier = _data['totalsTripsAddByShippier'];
      this.status = _data['status'];
      (<any>this).statusTitle = _data['statusTitle'];
      this.origin = _data['origin'];
      this.destination = _data['destination'];
      this.routeType = _data['routeType'];
      this.isDrafted = _data['isDrafted'];
      this.draftStep = _data['draftStep'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenant'] = this.tenant;
    data['isBid'] = this.isBid;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['isDirectRequest'] = this.isDirectRequest;
    data['totalBids'] = this.totalBids;
    data['numberOfTrips'] = this.numberOfTrips;
    data['numberOfDrops'] = this.numberOfDrops;
    data['hasAccident'] = this.hasAccident;
    data['totalsTripsAddByShippier'] = this.totalsTripsAddByShippier;
    data['status'] = this.status;
    data['statusTitle'] = this.statusTitle;
    data['origin'] = this.origin;
    data['destination'] = this.destination;
    data['routeType'] = this.routeType;
    data['isDrafted'] = this.isDrafted;
    data['draftStep'] = this.draftStep;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestListDto {
  tenant: string | undefined;
  isBid: boolean;
  isTachyonDeal: boolean;
  isDirectRequest: boolean;
  totalBids: number;
  numberOfTrips: number;
  numberOfDrops: number;
  hasAccident: boolean;
  totalsTripsAddByShippier: number;
  status: ShippingRequestStatus;
  statusTitle: string | undefined;
  origin: string | undefined;
  destination: string | undefined;
  routeType: string | undefined;
  isDrafted: boolean;
  draftStep: number;
  id: number;
}

export class PagedResultDtoOfShippingRequestListDto implements IPagedResultDtoOfShippingRequestListDto {
  totalCount!: number;
  items!: ShippingRequestListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfShippingRequestListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfShippingRequestListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfShippingRequestListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfShippingRequestListDto {
  totalCount: number;
  items: ShippingRequestListDto[] | undefined;
}

export class GetAllShippingRequestsOutputDto implements IGetAllShippingRequestsOutputDto {
  data!: PagedResultDtoOfShippingRequestListDto;
  noOfPostPriceWithoutTrips!: number;

  constructor(data?: IGetAllShippingRequestsOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? PagedResultDtoOfShippingRequestListDto.fromJS(_data['data']) : <any>undefined;
      this.noOfPostPriceWithoutTrips = _data['noOfPostPriceWithoutTrips'];
    }
  }

  static fromJS(data: any): GetAllShippingRequestsOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllShippingRequestsOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['noOfPostPriceWithoutTrips'] = this.noOfPostPriceWithoutTrips;
    return data;
  }
}

export interface IGetAllShippingRequestsOutputDto {
  data: PagedResultDtoOfShippingRequestListDto;
  noOfPostPriceWithoutTrips: number;
}

export class ShippingRequestDto implements IShippingRequestDto {
  isBid!: boolean;
  isTachyonDeal!: boolean;
  isDirectRequest!: boolean;
  requestType!: ShippingRequestType;
  price!: number | undefined;
  isPriceAccepted!: boolean | undefined;
  carrierTenantId!: number | undefined;
  carrierPrice!: number | undefined;
  isRejected!: boolean | undefined;
  startTripDate!: moment.Moment | undefined;
  endTripDate!: moment.Moment | undefined;
  numberOfTrips!: number;
  numberOfDrops!: number;
  goodCategoryId!: number;
  packingTypeId!: number;
  numberOfPacking!: number;
  totalWeight!: number;
  shippingTypeId!: number;
  bidStartDate!: moment.Moment | undefined;
  bidEndDate!: moment.Moment | undefined;
  hasAccident!: boolean;
  totalsTripsAddByShippier!: number;
  status!: ShippingRequestStatus;
  bidStatus!: ShippingRequestBidStatus;
  readonly statusTitle!: string | undefined;
  readonly bidStatusTitle!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isBid = _data['isBid'];
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.isDirectRequest = _data['isDirectRequest'];
      this.requestType = _data['requestType'];
      this.price = _data['price'];
      this.isPriceAccepted = _data['isPriceAccepted'];
      this.carrierTenantId = _data['carrierTenantId'];
      this.carrierPrice = _data['carrierPrice'];
      this.isRejected = _data['isRejected'];
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.numberOfTrips = _data['numberOfTrips'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.packingTypeId = _data['packingTypeId'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.totalWeight = _data['totalWeight'];
      this.shippingTypeId = _data['shippingTypeId'];
      this.bidStartDate = _data['bidStartDate'] ? moment(_data['bidStartDate'].toString()) : <any>undefined;
      this.bidEndDate = _data['bidEndDate'] ? moment(_data['bidEndDate'].toString()) : <any>undefined;
      this.hasAccident = _data['hasAccident'];
      this.totalsTripsAddByShippier = _data['totalsTripsAddByShippier'];
      this.status = _data['status'];
      this.bidStatus = _data['bidStatus'];
      (<any>this).statusTitle = _data['statusTitle'];
      (<any>this).bidStatusTitle = _data['bidStatusTitle'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isBid'] = this.isBid;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['isDirectRequest'] = this.isDirectRequest;
    data['requestType'] = this.requestType;
    data['price'] = this.price;
    data['isPriceAccepted'] = this.isPriceAccepted;
    data['carrierTenantId'] = this.carrierTenantId;
    data['carrierPrice'] = this.carrierPrice;
    data['isRejected'] = this.isRejected;
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['numberOfTrips'] = this.numberOfTrips;
    data['numberOfDrops'] = this.numberOfDrops;
    data['goodCategoryId'] = this.goodCategoryId;
    data['packingTypeId'] = this.packingTypeId;
    data['numberOfPacking'] = this.numberOfPacking;
    data['totalWeight'] = this.totalWeight;
    data['shippingTypeId'] = this.shippingTypeId;
    data['bidStartDate'] = this.bidStartDate ? this.bidStartDate.toISOString() : <any>undefined;
    data['bidEndDate'] = this.bidEndDate ? this.bidEndDate.toISOString() : <any>undefined;
    data['hasAccident'] = this.hasAccident;
    data['totalsTripsAddByShippier'] = this.totalsTripsAddByShippier;
    data['status'] = this.status;
    data['bidStatus'] = this.bidStatus;
    data['statusTitle'] = this.statusTitle;
    data['bidStatusTitle'] = this.bidStatusTitle;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestDto {
  isBid: boolean;
  isTachyonDeal: boolean;
  isDirectRequest: boolean;
  requestType: ShippingRequestType;
  price: number | undefined;
  isPriceAccepted: boolean | undefined;
  carrierTenantId: number | undefined;
  carrierPrice: number | undefined;
  isRejected: boolean | undefined;
  startTripDate: moment.Moment | undefined;
  endTripDate: moment.Moment | undefined;
  numberOfTrips: number;
  numberOfDrops: number;
  goodCategoryId: number;
  packingTypeId: number;
  numberOfPacking: number;
  totalWeight: number;
  shippingTypeId: number;
  bidStartDate: moment.Moment | undefined;
  bidEndDate: moment.Moment | undefined;
  hasAccident: boolean;
  totalsTripsAddByShippier: number;
  status: ShippingRequestStatus;
  bidStatus: ShippingRequestBidStatus;
  statusTitle: string | undefined;
  bidStatusTitle: string | undefined;
  id: number;
}

export class ShippingRequestBidDto implements IShippingRequestBidDto {
  price!: number;
  shippingRequestId!: number;
  isAccepted!: boolean;
  isRejected!: boolean;
  cancledReason!: string | undefined;
  acceptedDate!: moment.Moment | undefined;
  canceledDate!: moment.Moment | undefined;
  creationTime!: moment.Moment;
  carrierName!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestBidDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data['price'];
      this.shippingRequestId = _data['shippingRequestId'];
      this.isAccepted = _data['isAccepted'];
      this.isRejected = _data['isRejected'];
      this.cancledReason = _data['cancledReason'];
      this.acceptedDate = _data['acceptedDate'] ? moment(_data['acceptedDate'].toString()) : <any>undefined;
      this.canceledDate = _data['canceledDate'] ? moment(_data['canceledDate'].toString()) : <any>undefined;
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.carrierName = _data['carrierName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestBidDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestBidDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['price'] = this.price;
    data['shippingRequestId'] = this.shippingRequestId;
    data['isAccepted'] = this.isAccepted;
    data['isRejected'] = this.isRejected;
    data['cancledReason'] = this.cancledReason;
    data['acceptedDate'] = this.acceptedDate ? this.acceptedDate.toISOString() : <any>undefined;
    data['canceledDate'] = this.canceledDate ? this.canceledDate.toISOString() : <any>undefined;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['carrierName'] = this.carrierName;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestBidDto {
  price: number;
  shippingRequestId: number;
  isAccepted: boolean;
  isRejected: boolean;
  cancledReason: string | undefined;
  acceptedDate: moment.Moment | undefined;
  canceledDate: moment.Moment | undefined;
  creationTime: moment.Moment;
  carrierName: string | undefined;
  id: number;
}

export class ShippingRequestVasDto implements IShippingRequestVasDto {
  id!: number | undefined;
  requestMaxAmount!: number;
  requestMaxCount!: number;
  vasId!: number;
  shippingRequestId!: number | undefined;

  constructor(data?: IShippingRequestVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestMaxAmount = _data['requestMaxAmount'];
      this.requestMaxCount = _data['requestMaxCount'];
      this.vasId = _data['vasId'];
      this.shippingRequestId = _data['shippingRequestId'];
    }
  }

  static fromJS(data: any): ShippingRequestVasDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestVasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestMaxAmount'] = this.requestMaxAmount;
    data['requestMaxCount'] = this.requestMaxCount;
    data['vasId'] = this.vasId;
    data['shippingRequestId'] = this.shippingRequestId;
    return data;
  }
}

export interface IShippingRequestVasDto {
  id: number | undefined;
  requestMaxAmount: number;
  requestMaxCount: number;
  vasId: number;
  shippingRequestId: number | undefined;
}

export class GetShippingRequestVasForViewDto implements IGetShippingRequestVasForViewDto {
  shippingRequestVas!: ShippingRequestVasDto;
  vasName!: string | undefined;

  constructor(data?: IGetShippingRequestVasForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestVas = _data['shippingRequestVas'] ? ShippingRequestVasDto.fromJS(_data['shippingRequestVas']) : <any>undefined;
      this.vasName = _data['vasName'];
    }
  }

  static fromJS(data: any): GetShippingRequestVasForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestVasForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestVas'] = this.shippingRequestVas ? this.shippingRequestVas.toJSON() : <any>undefined;
    data['vasName'] = this.vasName;
    return data;
  }
}

export interface IGetShippingRequestVasForViewDto {
  shippingRequestVas: ShippingRequestVasDto;
  vasName: string | undefined;
}

export class TruckDto implements ITruckDto {
  plateNumber!: string | undefined;
  modelName!: string | undefined;
  modelYear!: string | undefined;
  note!: string | undefined;
  capacity!: string | undefined;
  trucksTypeId!: number;
  truckStatusId!: number;
  length!: number | undefined;
  id!: number;

  constructor(data?: ITruckDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.plateNumber = _data['plateNumber'];
      this.modelName = _data['modelName'];
      this.modelYear = _data['modelYear'];
      this.note = _data['note'];
      this.capacity = _data['capacity'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.truckStatusId = _data['truckStatusId'];
      this.length = _data['length'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TruckDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['plateNumber'] = this.plateNumber;
    data['modelName'] = this.modelName;
    data['modelYear'] = this.modelYear;
    data['note'] = this.note;
    data['capacity'] = this.capacity;
    data['trucksTypeId'] = this.trucksTypeId;
    data['truckStatusId'] = this.truckStatusId;
    data['length'] = this.length;
    data['id'] = this.id;
    return data;
  }
}

export interface ITruckDto {
  plateNumber: string | undefined;
  modelName: string | undefined;
  modelYear: string | undefined;
  note: string | undefined;
  capacity: string | undefined;
  trucksTypeId: number;
  truckStatusId: number;
  length: number | undefined;
  id: number;
}

export class GetTruckForViewOutput implements IGetTruckForViewOutput {
  truck!: TruckDto;
  trucksTypeDisplayName!: string | undefined;
  truckStatusDisplayName!: string | undefined;
  isMissingDocumentFiles!: boolean;

  constructor(data?: IGetTruckForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truck = _data['truck'] ? TruckDto.fromJS(_data['truck']) : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
      this.truckStatusDisplayName = _data['truckStatusDisplayName'];
      this.isMissingDocumentFiles = _data['isMissingDocumentFiles'];
    }
  }

  static fromJS(data: any): GetTruckForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truck'] = this.truck ? this.truck.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    data['truckStatusDisplayName'] = this.truckStatusDisplayName;
    data['isMissingDocumentFiles'] = this.isMissingDocumentFiles;
    return data;
  }
}

export interface IGetTruckForViewOutput {
  truck: TruckDto;
  trucksTypeDisplayName: string | undefined;
  truckStatusDisplayName: string | undefined;
  isMissingDocumentFiles: boolean;
}

export class GetShippingRequestForViewOutput implements IGetShippingRequestForViewOutput {
  shippingRequest!: ShippingRequestDto;
  shippingRequestBidDtoList!: ShippingRequestBidDto[] | undefined;
  shippingRequestVasDtoList!: GetShippingRequestVasForViewDto[] | undefined;
  vasCount!: number;
  truckTypeDisplayName!: string | undefined;
  transportTypeDisplayName!: string | undefined;
  capacityDisplayName!: string | undefined;
  driverName!: string | undefined;
  routTypeName!: string | undefined;
  originalCityName!: string | undefined;
  destinationCityName!: string | undefined;
  goodsCategoryName!: string | undefined;
  truckTypeFullName!: string | undefined;
  shippingRequestStatusName!: string | undefined;
  packingTypeDisplayName!: string | undefined;
  shippingTypeDisplayName!: string | undefined;
  hasTrips!: boolean;
  assignedTruckDto!: GetTruckForViewOutput;
  totalsTripsAddByShippier!: number;
  carrierPrice!: number | undefined;
  carrierName!: string | undefined;

  constructor(data?: IGetShippingRequestForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequest = _data['shippingRequest'] ? ShippingRequestDto.fromJS(_data['shippingRequest']) : <any>undefined;
      if (Array.isArray(_data['shippingRequestBidDtoList'])) {
        this.shippingRequestBidDtoList = [] as any;
        for (let item of _data['shippingRequestBidDtoList']) this.shippingRequestBidDtoList!.push(ShippingRequestBidDto.fromJS(item));
      }
      if (Array.isArray(_data['shippingRequestVasDtoList'])) {
        this.shippingRequestVasDtoList = [] as any;
        for (let item of _data['shippingRequestVasDtoList']) this.shippingRequestVasDtoList!.push(GetShippingRequestVasForViewDto.fromJS(item));
      }
      this.vasCount = _data['vasCount'];
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
      this.transportTypeDisplayName = _data['transportTypeDisplayName'];
      this.capacityDisplayName = _data['capacityDisplayName'];
      this.driverName = _data['driverName'];
      this.routTypeName = _data['routTypeName'];
      this.originalCityName = _data['originalCityName'];
      this.destinationCityName = _data['destinationCityName'];
      this.goodsCategoryName = _data['goodsCategoryName'];
      this.truckTypeFullName = _data['truckTypeFullName'];
      this.shippingRequestStatusName = _data['shippingRequestStatusName'];
      this.packingTypeDisplayName = _data['packingTypeDisplayName'];
      this.shippingTypeDisplayName = _data['shippingTypeDisplayName'];
      this.hasTrips = _data['hasTrips'];
      this.assignedTruckDto = _data['assignedTruckDto'] ? GetTruckForViewOutput.fromJS(_data['assignedTruckDto']) : <any>undefined;
      this.totalsTripsAddByShippier = _data['totalsTripsAddByShippier'];
      this.carrierPrice = _data['carrierPrice'];
      this.carrierName = _data['carrierName'];
    }
  }

  static fromJS(data: any): GetShippingRequestForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequest'] = this.shippingRequest ? this.shippingRequest.toJSON() : <any>undefined;
    if (Array.isArray(this.shippingRequestBidDtoList)) {
      data['shippingRequestBidDtoList'] = [];
      for (let item of this.shippingRequestBidDtoList) data['shippingRequestBidDtoList'].push(item.toJSON());
    }
    if (Array.isArray(this.shippingRequestVasDtoList)) {
      data['shippingRequestVasDtoList'] = [];
      for (let item of this.shippingRequestVasDtoList) data['shippingRequestVasDtoList'].push(item.toJSON());
    }
    data['vasCount'] = this.vasCount;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    data['transportTypeDisplayName'] = this.transportTypeDisplayName;
    data['capacityDisplayName'] = this.capacityDisplayName;
    data['driverName'] = this.driverName;
    data['routTypeName'] = this.routTypeName;
    data['originalCityName'] = this.originalCityName;
    data['destinationCityName'] = this.destinationCityName;
    data['goodsCategoryName'] = this.goodsCategoryName;
    data['truckTypeFullName'] = this.truckTypeFullName;
    data['shippingRequestStatusName'] = this.shippingRequestStatusName;
    data['packingTypeDisplayName'] = this.packingTypeDisplayName;
    data['shippingTypeDisplayName'] = this.shippingTypeDisplayName;
    data['hasTrips'] = this.hasTrips;
    data['assignedTruckDto'] = this.assignedTruckDto ? this.assignedTruckDto.toJSON() : <any>undefined;
    data['totalsTripsAddByShippier'] = this.totalsTripsAddByShippier;
    data['carrierPrice'] = this.carrierPrice;
    data['carrierName'] = this.carrierName;
    return data;
  }
}

export interface IGetShippingRequestForViewOutput {
  shippingRequest: ShippingRequestDto;
  shippingRequestBidDtoList: ShippingRequestBidDto[] | undefined;
  shippingRequestVasDtoList: GetShippingRequestVasForViewDto[] | undefined;
  vasCount: number;
  truckTypeDisplayName: string | undefined;
  transportTypeDisplayName: string | undefined;
  capacityDisplayName: string | undefined;
  driverName: string | undefined;
  routTypeName: string | undefined;
  originalCityName: string | undefined;
  destinationCityName: string | undefined;
  goodsCategoryName: string | undefined;
  truckTypeFullName: string | undefined;
  shippingRequestStatusName: string | undefined;
  packingTypeDisplayName: string | undefined;
  shippingTypeDisplayName: string | undefined;
  hasTrips: boolean;
  assignedTruckDto: GetTruckForViewOutput;
  totalsTripsAddByShippier: number;
  carrierPrice: number | undefined;
  carrierName: string | undefined;
}

export class CreateOrEditShippingRequestVasListDto implements ICreateOrEditShippingRequestVasListDto {
  id!: number | undefined;
  requestMaxAmount!: number;
  requestMaxCount!: number;
  vasId!: number;
  shippingRequestId!: number | undefined;
  numberOfTrips!: number;

  constructor(data?: ICreateOrEditShippingRequestVasListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestMaxAmount = _data['requestMaxAmount'];
      this.requestMaxCount = _data['requestMaxCount'];
      this.vasId = _data['vasId'];
      this.shippingRequestId = _data['shippingRequestId'];
      this.numberOfTrips = _data['numberOfTrips'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestVasListDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestVasListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestMaxAmount'] = this.requestMaxAmount;
    data['requestMaxCount'] = this.requestMaxCount;
    data['vasId'] = this.vasId;
    data['shippingRequestId'] = this.shippingRequestId;
    data['numberOfTrips'] = this.numberOfTrips;
    return data;
  }
}

export interface ICreateOrEditShippingRequestVasListDto {
  id: number | undefined;
  requestMaxAmount: number;
  requestMaxCount: number;
  vasId: number;
  shippingRequestId: number | undefined;
  numberOfTrips: number;
}

export class CreateOrEditShippingRequestDto implements ICreateOrEditShippingRequestDto {
  isBid!: boolean;
  bidStartDate!: moment.Moment | undefined;
  bidEndDate!: moment.Moment | undefined;
  isTachyonDeal!: boolean;
  isDirectRequest!: boolean;
  fatherShippingRequestId!: number | undefined;
  carrierTenantId!: number | undefined;
  transportTypeId!: number | undefined;
  trucksTypeId!: number;
  capacityId!: number | undefined;
  goodCategoryId!: number | undefined;
  numberOfDrops!: number | undefined;
  stageOneFinish!: boolean;
  stageTowFinish!: boolean;
  stageThreeFinish!: boolean;
  startTripDate!: moment.Moment;
  endTripDate!: moment.Moment | undefined;
  numberOfTrips!: number;
  packingTypeId!: number;
  numberOfPacking!: number;
  totalWeight!: number;
  shippingTypeId!: number;
  routeTypeId!: ShippingRequestRouteType;
  originCityId!: number;
  destinationCityId!: number;
  shippingRequestVasList!: CreateOrEditShippingRequestVasListDto[] | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isBid = _data['isBid'];
      this.bidStartDate = _data['bidStartDate'] ? moment(_data['bidStartDate'].toString()) : <any>undefined;
      this.bidEndDate = _data['bidEndDate'] ? moment(_data['bidEndDate'].toString()) : <any>undefined;
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.isDirectRequest = _data['isDirectRequest'];
      this.fatherShippingRequestId = _data['fatherShippingRequestId'];
      this.carrierTenantId = _data['carrierTenantId'];
      this.transportTypeId = _data['transportTypeId'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.capacityId = _data['capacityId'];
      this.goodCategoryId = _data['goodCategoryId'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.stageOneFinish = _data['stageOneFinish'];
      this.stageTowFinish = _data['stageTowFinish'];
      this.stageThreeFinish = _data['stageThreeFinish'];
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.numberOfTrips = _data['numberOfTrips'];
      this.packingTypeId = _data['packingTypeId'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.totalWeight = _data['totalWeight'];
      this.shippingTypeId = _data['shippingTypeId'];
      this.routeTypeId = _data['routeTypeId'];
      this.originCityId = _data['originCityId'];
      this.destinationCityId = _data['destinationCityId'];
      if (Array.isArray(_data['shippingRequestVasList'])) {
        this.shippingRequestVasList = [] as any;
        for (let item of _data['shippingRequestVasList']) this.shippingRequestVasList!.push(CreateOrEditShippingRequestVasListDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isBid'] = this.isBid;
    data['bidStartDate'] = this.bidStartDate ? this.bidStartDate.toISOString() : <any>undefined;
    data['bidEndDate'] = this.bidEndDate ? this.bidEndDate.toISOString() : <any>undefined;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['isDirectRequest'] = this.isDirectRequest;
    data['fatherShippingRequestId'] = this.fatherShippingRequestId;
    data['carrierTenantId'] = this.carrierTenantId;
    data['transportTypeId'] = this.transportTypeId;
    data['trucksTypeId'] = this.trucksTypeId;
    data['capacityId'] = this.capacityId;
    data['goodCategoryId'] = this.goodCategoryId;
    data['numberOfDrops'] = this.numberOfDrops;
    data['stageOneFinish'] = this.stageOneFinish;
    data['stageTowFinish'] = this.stageTowFinish;
    data['stageThreeFinish'] = this.stageThreeFinish;
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['numberOfTrips'] = this.numberOfTrips;
    data['packingTypeId'] = this.packingTypeId;
    data['numberOfPacking'] = this.numberOfPacking;
    data['totalWeight'] = this.totalWeight;
    data['shippingTypeId'] = this.shippingTypeId;
    data['routeTypeId'] = this.routeTypeId;
    data['originCityId'] = this.originCityId;
    data['destinationCityId'] = this.destinationCityId;
    if (Array.isArray(this.shippingRequestVasList)) {
      data['shippingRequestVasList'] = [];
      for (let item of this.shippingRequestVasList) data['shippingRequestVasList'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestDto {
  isBid: boolean;
  bidStartDate: moment.Moment | undefined;
  bidEndDate: moment.Moment | undefined;
  isTachyonDeal: boolean;
  isDirectRequest: boolean;
  fatherShippingRequestId: number | undefined;
  carrierTenantId: number | undefined;
  transportTypeId: number | undefined;
  trucksTypeId: number;
  capacityId: number | undefined;
  goodCategoryId: number | undefined;
  numberOfDrops: number | undefined;
  stageOneFinish: boolean;
  stageTowFinish: boolean;
  stageThreeFinish: boolean;
  startTripDate: moment.Moment;
  endTripDate: moment.Moment | undefined;
  numberOfTrips: number;
  packingTypeId: number;
  numberOfPacking: number;
  totalWeight: number;
  shippingTypeId: number;
  routeTypeId: ShippingRequestRouteType;
  originCityId: number;
  destinationCityId: number;
  shippingRequestVasList: CreateOrEditShippingRequestVasListDto[] | undefined;
  id: number | undefined;
}

export class GetShippingRequestForEditOutput implements IGetShippingRequestForEditOutput {
  shippingRequest!: CreateOrEditShippingRequestDto;

  constructor(data?: IGetShippingRequestForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequest = _data['shippingRequest'] ? CreateOrEditShippingRequestDto.fromJS(_data['shippingRequest']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetShippingRequestForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequest'] = this.shippingRequest ? this.shippingRequest.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetShippingRequestForEditOutput {
  shippingRequest: CreateOrEditShippingRequestDto;
}

export class CreateOrEditShippingRequestStep1Dto implements ICreateOrEditShippingRequestStep1Dto {
  isBid!: boolean;
  bidStartDate!: moment.Moment | undefined;
  bidEndDate!: moment.Moment | undefined;
  isTachyonDeal!: boolean;
  shippingTypeId!: number;
  startTripDate!: moment.Moment;
  endTripDate!: moment.Moment | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestStep1Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isBid = _data['isBid'];
      this.bidStartDate = _data['bidStartDate'] ? moment(_data['bidStartDate'].toString()) : <any>undefined;
      this.bidEndDate = _data['bidEndDate'] ? moment(_data['bidEndDate'].toString()) : <any>undefined;
      this.isTachyonDeal = _data['isTachyonDeal'];
      this.shippingTypeId = _data['shippingTypeId'];
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestStep1Dto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestStep1Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isBid'] = this.isBid;
    data['bidStartDate'] = this.bidStartDate ? this.bidStartDate.toISOString() : <any>undefined;
    data['bidEndDate'] = this.bidEndDate ? this.bidEndDate.toISOString() : <any>undefined;
    data['isTachyonDeal'] = this.isTachyonDeal;
    data['shippingTypeId'] = this.shippingTypeId;
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestStep1Dto {
  isBid: boolean;
  bidStartDate: moment.Moment | undefined;
  bidEndDate: moment.Moment | undefined;
  isTachyonDeal: boolean;
  shippingTypeId: number;
  startTripDate: moment.Moment;
  endTripDate: moment.Moment | undefined;
  id: number | undefined;
}

export class EditShippingRequestStep2Dto implements IEditShippingRequestStep2Dto {
  routeTypeId!: ShippingRequestRouteType;
  originCityId!: number;
  destinationCityId!: number;
  numberOfDrops!: number;
  numberOfTrips!: number;
  id!: number;

  constructor(data?: IEditShippingRequestStep2Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routeTypeId = _data['routeTypeId'];
      this.originCityId = _data['originCityId'];
      this.destinationCityId = _data['destinationCityId'];
      this.numberOfDrops = _data['numberOfDrops'];
      this.numberOfTrips = _data['numberOfTrips'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EditShippingRequestStep2Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditShippingRequestStep2Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routeTypeId'] = this.routeTypeId;
    data['originCityId'] = this.originCityId;
    data['destinationCityId'] = this.destinationCityId;
    data['numberOfDrops'] = this.numberOfDrops;
    data['numberOfTrips'] = this.numberOfTrips;
    data['id'] = this.id;
    return data;
  }
}

export interface IEditShippingRequestStep2Dto {
  routeTypeId: ShippingRequestRouteType;
  originCityId: number;
  destinationCityId: number;
  numberOfDrops: number;
  numberOfTrips: number;
  id: number;
}

export class EditShippingRequestStep3Dto implements IEditShippingRequestStep3Dto {
  goodCategoryId!: number;
  totalWeight!: number;
  packingTypeId!: number;
  numberOfPacking!: number;
  transportTypeId!: number | undefined;
  trucksTypeId!: number;
  capacityId!: number | undefined;
  id!: number;

  constructor(data?: IEditShippingRequestStep3Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.goodCategoryId = _data['goodCategoryId'];
      this.totalWeight = _data['totalWeight'];
      this.packingTypeId = _data['packingTypeId'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.transportTypeId = _data['transportTypeId'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.capacityId = _data['capacityId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EditShippingRequestStep3Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditShippingRequestStep3Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['goodCategoryId'] = this.goodCategoryId;
    data['totalWeight'] = this.totalWeight;
    data['packingTypeId'] = this.packingTypeId;
    data['numberOfPacking'] = this.numberOfPacking;
    data['transportTypeId'] = this.transportTypeId;
    data['trucksTypeId'] = this.trucksTypeId;
    data['capacityId'] = this.capacityId;
    data['id'] = this.id;
    return data;
  }
}

export interface IEditShippingRequestStep3Dto {
  goodCategoryId: number;
  totalWeight: number;
  packingTypeId: number;
  numberOfPacking: number;
  transportTypeId: number | undefined;
  trucksTypeId: number;
  capacityId: number | undefined;
  id: number;
}

export class EditShippingRequestStep4Dto implements IEditShippingRequestStep4Dto {
  shippingRequestVasList!: CreateOrEditShippingRequestVasListDto[] | undefined;
  id!: number;

  constructor(data?: IEditShippingRequestStep4Dto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['shippingRequestVasList'])) {
        this.shippingRequestVasList = [] as any;
        for (let item of _data['shippingRequestVasList']) this.shippingRequestVasList!.push(CreateOrEditShippingRequestVasListDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EditShippingRequestStep4Dto {
    data = typeof data === 'object' ? data : {};
    let result = new EditShippingRequestStep4Dto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.shippingRequestVasList)) {
      data['shippingRequestVasList'] = [];
      for (let item of this.shippingRequestVasList) data['shippingRequestVasList'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface IEditShippingRequestStep4Dto {
  shippingRequestVasList: CreateOrEditShippingRequestVasListDto[] | undefined;
  id: number;
}

export class ShippingRequestVasListOutput implements IShippingRequestVasListOutput {
  vasName!: string | undefined;
  hasAmount!: boolean;
  hasCount!: boolean;
  maxAmount!: number;
  maxCount!: number;
  id!: number;

  constructor(data?: IShippingRequestVasListOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vasName = _data['vasName'];
      this.hasAmount = _data['hasAmount'];
      this.hasCount = _data['hasCount'];
      this.maxAmount = _data['maxAmount'];
      this.maxCount = _data['maxCount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestVasListOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestVasListOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vasName'] = this.vasName;
    data['hasAmount'] = this.hasAmount;
    data['hasCount'] = this.hasCount;
    data['maxAmount'] = this.maxAmount;
    data['maxCount'] = this.maxCount;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestVasListOutput {
  vasName: string | undefined;
  hasAmount: boolean;
  hasCount: boolean;
  maxAmount: number;
  maxCount: number;
  id: number;
}

export class ShippingRequestVasPriceDto implements IShippingRequestVasPriceDto {
  shippingRequestVas!: ShippingRequestVasListOutput;
  actualPrice!: number | undefined;
  defaultPrice!: number | undefined;
  shippingRequestVasId!: number;

  constructor(data?: IShippingRequestVasPriceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestVas = _data['shippingRequestVas'] ? ShippingRequestVasListOutput.fromJS(_data['shippingRequestVas']) : <any>undefined;
      this.actualPrice = _data['actualPrice'];
      this.defaultPrice = _data['defaultPrice'];
      this.shippingRequestVasId = _data['shippingRequestVasId'];
    }
  }

  static fromJS(data: any): ShippingRequestVasPriceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestVasPriceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestVas'] = this.shippingRequestVas ? this.shippingRequestVas.toJSON() : <any>undefined;
    data['actualPrice'] = this.actualPrice;
    data['defaultPrice'] = this.defaultPrice;
    data['shippingRequestVasId'] = this.shippingRequestVasId;
    return data;
  }
}

export interface IShippingRequestVasPriceDto {
  shippingRequestVas: ShippingRequestVasListOutput;
  actualPrice: number | undefined;
  defaultPrice: number | undefined;
  shippingRequestVasId: number;
}

export class UpdatePriceInput implements IUpdatePriceInput {
  price!: number;
  id!: number;
  pricedVasesList!: ShippingRequestVasPriceDto[] | undefined;

  constructor(data?: IUpdatePriceInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data['price'];
      this.id = _data['id'];
      if (Array.isArray(_data['pricedVasesList'])) {
        this.pricedVasesList = [] as any;
        for (let item of _data['pricedVasesList']) this.pricedVasesList!.push(ShippingRequestVasPriceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdatePriceInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePriceInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['price'] = this.price;
    data['id'] = this.id;
    if (Array.isArray(this.pricedVasesList)) {
      data['pricedVasesList'] = [];
      for (let item of this.pricedVasesList) data['pricedVasesList'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdatePriceInput {
  price: number;
  id: number;
  pricedVasesList: ShippingRequestVasPriceDto[] | undefined;
}

export class AcceptShippingRequestPriceInput implements IAcceptShippingRequestPriceInput {
  id!: number;
  isPriceAccepted!: boolean;

  constructor(data?: IAcceptShippingRequestPriceInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.isPriceAccepted = _data['isPriceAccepted'];
    }
  }

  static fromJS(data: any): AcceptShippingRequestPriceInput {
    data = typeof data === 'object' ? data : {};
    let result = new AcceptShippingRequestPriceInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['isPriceAccepted'] = this.isPriceAccepted;
    return data;
  }
}

export interface IAcceptShippingRequestPriceInput {
  id: number;
  isPriceAccepted: boolean;
}

export class CarriersForDropDownDto implements ICarriersForDropDownDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ICarriersForDropDownDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): CarriersForDropDownDto {
    data = typeof data === 'object' ? data : {};
    let result = new CarriersForDropDownDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ICarriersForDropDownDto {
  id: number;
  displayName: string | undefined;
}

export class ShippingRequestPricingOutputforView implements IShippingRequestPricingOutputforView {
  shippingRequestPrice!: number;
  pricedVasesList!: ShippingRequestVasPriceDto[] | undefined;

  constructor(data?: IShippingRequestPricingOutputforView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestPrice = _data['shippingRequestPrice'];
      if (Array.isArray(_data['pricedVasesList'])) {
        this.pricedVasesList = [] as any;
        for (let item of _data['pricedVasesList']) this.pricedVasesList!.push(ShippingRequestVasPriceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShippingRequestPricingOutputforView {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestPricingOutputforView();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestPrice'] = this.shippingRequestPrice;
    if (Array.isArray(this.pricedVasesList)) {
      data['pricedVasesList'] = [];
      for (let item of this.pricedVasesList) data['pricedVasesList'].push(item.toJSON());
    }
    return data;
  }
}

export interface IShippingRequestPricingOutputforView {
  shippingRequestPrice: number;
  pricedVasesList: ShippingRequestVasPriceDto[] | undefined;
}

export class GetMasterWaybillOutput implements IGetMasterWaybillOutput {
  masterWaybillNo!: number;
  date!: string | undefined;
  shippingRequestStatus!: string | undefined;
  invoiceNumber!: number;
  shipperReference!: string | undefined;
  totalWeight!: number;
  companyName!: string | undefined;
  contactName!: string | undefined;
  mobile!: string | undefined;
  driverName!: string | undefined;
  driverIqamaNo!: string | undefined;
  truckTypeDisplayName!: string | undefined;
  plateNumber!: string | undefined;
  isMultipDrops!: boolean;
  totalDrops!: number;
  packingTypeDisplayName!: string | undefined;
  numberOfPacking!: number;
  facilityName!: string | undefined;
  countryName!: string | undefined;
  cityName!: string | undefined;
  area!: string | undefined;
  startTripDate!: string | undefined;
  carrierName!: string | undefined;

  constructor(data?: IGetMasterWaybillOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterWaybillNo = _data['masterWaybillNo'];
      this.date = _data['date'];
      this.shippingRequestStatus = _data['shippingRequestStatus'];
      this.invoiceNumber = _data['invoiceNumber'];
      this.shipperReference = _data['shipperReference'];
      this.totalWeight = _data['totalWeight'];
      this.companyName = _data['companyName'];
      this.contactName = _data['contactName'];
      this.mobile = _data['mobile'];
      this.driverName = _data['driverName'];
      this.driverIqamaNo = _data['driverIqamaNo'];
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
      this.plateNumber = _data['plateNumber'];
      this.isMultipDrops = _data['isMultipDrops'];
      this.totalDrops = _data['totalDrops'];
      this.packingTypeDisplayName = _data['packingTypeDisplayName'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.facilityName = _data['facilityName'];
      this.countryName = _data['countryName'];
      this.cityName = _data['cityName'];
      this.area = _data['area'];
      this.startTripDate = _data['startTripDate'];
      this.carrierName = _data['carrierName'];
    }
  }

  static fromJS(data: any): GetMasterWaybillOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetMasterWaybillOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterWaybillNo'] = this.masterWaybillNo;
    data['date'] = this.date;
    data['shippingRequestStatus'] = this.shippingRequestStatus;
    data['invoiceNumber'] = this.invoiceNumber;
    data['shipperReference'] = this.shipperReference;
    data['totalWeight'] = this.totalWeight;
    data['companyName'] = this.companyName;
    data['contactName'] = this.contactName;
    data['mobile'] = this.mobile;
    data['driverName'] = this.driverName;
    data['driverIqamaNo'] = this.driverIqamaNo;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    data['plateNumber'] = this.plateNumber;
    data['isMultipDrops'] = this.isMultipDrops;
    data['totalDrops'] = this.totalDrops;
    data['packingTypeDisplayName'] = this.packingTypeDisplayName;
    data['numberOfPacking'] = this.numberOfPacking;
    data['facilityName'] = this.facilityName;
    data['countryName'] = this.countryName;
    data['cityName'] = this.cityName;
    data['area'] = this.area;
    data['startTripDate'] = this.startTripDate;
    data['carrierName'] = this.carrierName;
    return data;
  }
}

export interface IGetMasterWaybillOutput {
  masterWaybillNo: number;
  date: string | undefined;
  shippingRequestStatus: string | undefined;
  invoiceNumber: number;
  shipperReference: string | undefined;
  totalWeight: number;
  companyName: string | undefined;
  contactName: string | undefined;
  mobile: string | undefined;
  driverName: string | undefined;
  driverIqamaNo: string | undefined;
  truckTypeDisplayName: string | undefined;
  plateNumber: string | undefined;
  isMultipDrops: boolean;
  totalDrops: number;
  packingTypeDisplayName: string | undefined;
  numberOfPacking: number;
  facilityName: string | undefined;
  countryName: string | undefined;
  cityName: string | undefined;
  area: string | undefined;
  startTripDate: string | undefined;
  carrierName: string | undefined;
}

export class GetSingleDropWaybillOutput implements IGetSingleDropWaybillOutput {
  masterWaybillNo!: number;
  date!: string | undefined;
  shippingRequestStatus!: string | undefined;
  invoiceNumber!: number;
  shipperReference!: string | undefined;
  startTripDate!: moment.Moment;
  deliveryDate!: moment.Moment;
  totalWeight!: number;
  goodsCategoryDisplayName!: string | undefined;
  senderCompanyName!: string | undefined;
  senderContactName!: string | undefined;
  senderMobile!: string | undefined;
  clientName!: string | undefined;
  receiverCompanyName!: string | undefined;
  receiverContactName!: string | undefined;
  receiverMobile!: string | undefined;
  carrierName!: string | undefined;
  driverName!: string | undefined;
  driverIqamaNo!: string | undefined;
  truckTypeDisplayName!: string | undefined;
  plateNumber!: string | undefined;
  packingTypeDisplayName!: string | undefined;
  numberOfPacking!: number;
  facilityName!: string | undefined;
  countryName!: string | undefined;
  cityName!: string | undefined;
  area!: string | undefined;
  droppFacilityName!: string | undefined;
  droppCountryName!: string | undefined;
  droppCityName!: string | undefined;
  droppArea!: string | undefined;

  constructor(data?: IGetSingleDropWaybillOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterWaybillNo = _data['masterWaybillNo'];
      this.date = _data['date'];
      this.shippingRequestStatus = _data['shippingRequestStatus'];
      this.invoiceNumber = _data['invoiceNumber'];
      this.shipperReference = _data['shipperReference'];
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.deliveryDate = _data['deliveryDate'] ? moment(_data['deliveryDate'].toString()) : <any>undefined;
      this.totalWeight = _data['totalWeight'];
      this.goodsCategoryDisplayName = _data['goodsCategoryDisplayName'];
      this.senderCompanyName = _data['senderCompanyName'];
      this.senderContactName = _data['senderContactName'];
      this.senderMobile = _data['senderMobile'];
      this.clientName = _data['clientName'];
      this.receiverCompanyName = _data['receiverCompanyName'];
      this.receiverContactName = _data['receiverContactName'];
      this.receiverMobile = _data['receiverMobile'];
      this.carrierName = _data['carrierName'];
      this.driverName = _data['driverName'];
      this.driverIqamaNo = _data['driverIqamaNo'];
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
      this.plateNumber = _data['plateNumber'];
      this.packingTypeDisplayName = _data['packingTypeDisplayName'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.facilityName = _data['facilityName'];
      this.countryName = _data['countryName'];
      this.cityName = _data['cityName'];
      this.area = _data['area'];
      this.droppFacilityName = _data['droppFacilityName'];
      this.droppCountryName = _data['droppCountryName'];
      this.droppCityName = _data['droppCityName'];
      this.droppArea = _data['droppArea'];
    }
  }

  static fromJS(data: any): GetSingleDropWaybillOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetSingleDropWaybillOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterWaybillNo'] = this.masterWaybillNo;
    data['date'] = this.date;
    data['shippingRequestStatus'] = this.shippingRequestStatus;
    data['invoiceNumber'] = this.invoiceNumber;
    data['shipperReference'] = this.shipperReference;
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['deliveryDate'] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
    data['totalWeight'] = this.totalWeight;
    data['goodsCategoryDisplayName'] = this.goodsCategoryDisplayName;
    data['senderCompanyName'] = this.senderCompanyName;
    data['senderContactName'] = this.senderContactName;
    data['senderMobile'] = this.senderMobile;
    data['clientName'] = this.clientName;
    data['receiverCompanyName'] = this.receiverCompanyName;
    data['receiverContactName'] = this.receiverContactName;
    data['receiverMobile'] = this.receiverMobile;
    data['carrierName'] = this.carrierName;
    data['driverName'] = this.driverName;
    data['driverIqamaNo'] = this.driverIqamaNo;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    data['plateNumber'] = this.plateNumber;
    data['packingTypeDisplayName'] = this.packingTypeDisplayName;
    data['numberOfPacking'] = this.numberOfPacking;
    data['facilityName'] = this.facilityName;
    data['countryName'] = this.countryName;
    data['cityName'] = this.cityName;
    data['area'] = this.area;
    data['droppFacilityName'] = this.droppFacilityName;
    data['droppCountryName'] = this.droppCountryName;
    data['droppCityName'] = this.droppCityName;
    data['droppArea'] = this.droppArea;
    return data;
  }
}

export interface IGetSingleDropWaybillOutput {
  masterWaybillNo: number;
  date: string | undefined;
  shippingRequestStatus: string | undefined;
  invoiceNumber: number;
  shipperReference: string | undefined;
  startTripDate: moment.Moment;
  deliveryDate: moment.Moment;
  totalWeight: number;
  goodsCategoryDisplayName: string | undefined;
  senderCompanyName: string | undefined;
  senderContactName: string | undefined;
  senderMobile: string | undefined;
  clientName: string | undefined;
  receiverCompanyName: string | undefined;
  receiverContactName: string | undefined;
  receiverMobile: string | undefined;
  carrierName: string | undefined;
  driverName: string | undefined;
  driverIqamaNo: string | undefined;
  truckTypeDisplayName: string | undefined;
  plateNumber: string | undefined;
  packingTypeDisplayName: string | undefined;
  numberOfPacking: number;
  facilityName: string | undefined;
  countryName: string | undefined;
  cityName: string | undefined;
  area: string | undefined;
  droppFacilityName: string | undefined;
  droppCountryName: string | undefined;
  droppCityName: string | undefined;
  droppArea: string | undefined;
}

export class GetAllShippingRequestVasesOutput implements IGetAllShippingRequestVasesOutput {
  vasName!: string | undefined;
  count!: number;
  amount!: number;

  constructor(data?: IGetAllShippingRequestVasesOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vasName = _data['vasName'];
      this.count = _data['count'];
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): GetAllShippingRequestVasesOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllShippingRequestVasesOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vasName'] = this.vasName;
    data['count'] = this.count;
    data['amount'] = this.amount;
    return data;
  }
}

export interface IGetAllShippingRequestVasesOutput {
  vasName: string | undefined;
  count: number;
  amount: number;
}

export class GetMultipleDropWaybillOutput implements IGetMultipleDropWaybillOutput {
  masterWaybillNo!: number;
  subWaybillNo!: number;
  date!: string | undefined;
  shippingRequestStatus!: string | undefined;
  invoiceNumber!: number;
  shipperReference!: string | undefined;
  startTripDate!: string | undefined;
  deliveryDate!: moment.Moment;
  carrierName!: string | undefined;
  clientName!: string | undefined;
  totalWeight!: number;
  goodsCategoryDisplayName!: string | undefined;
  senderCompanyName!: string | undefined;
  senderContactName!: string | undefined;
  senderMobile!: string | undefined;
  receiverCompanyName!: string | undefined;
  receiverContactName!: string | undefined;
  receiverMobile!: string | undefined;
  driverName!: string | undefined;
  driverIqamaNo!: string | undefined;
  truckTypeDisplayName!: string | undefined;
  plateNumber!: string | undefined;
  packingTypeDisplayName!: string | undefined;
  numberOfPacking!: number;
  droppFacilityName!: string | undefined;
  droppCountryName!: string | undefined;
  droppCityName!: string | undefined;
  droppArea!: string | undefined;

  constructor(data?: IGetMultipleDropWaybillOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.masterWaybillNo = _data['masterWaybillNo'];
      this.subWaybillNo = _data['subWaybillNo'];
      this.date = _data['date'];
      this.shippingRequestStatus = _data['shippingRequestStatus'];
      this.invoiceNumber = _data['invoiceNumber'];
      this.shipperReference = _data['shipperReference'];
      this.startTripDate = _data['startTripDate'];
      this.deliveryDate = _data['deliveryDate'] ? moment(_data['deliveryDate'].toString()) : <any>undefined;
      this.carrierName = _data['carrierName'];
      this.clientName = _data['clientName'];
      this.totalWeight = _data['totalWeight'];
      this.goodsCategoryDisplayName = _data['goodsCategoryDisplayName'];
      this.senderCompanyName = _data['senderCompanyName'];
      this.senderContactName = _data['senderContactName'];
      this.senderMobile = _data['senderMobile'];
      this.receiverCompanyName = _data['receiverCompanyName'];
      this.receiverContactName = _data['receiverContactName'];
      this.receiverMobile = _data['receiverMobile'];
      this.driverName = _data['driverName'];
      this.driverIqamaNo = _data['driverIqamaNo'];
      this.truckTypeDisplayName = _data['truckTypeDisplayName'];
      this.plateNumber = _data['plateNumber'];
      this.packingTypeDisplayName = _data['packingTypeDisplayName'];
      this.numberOfPacking = _data['numberOfPacking'];
      this.droppFacilityName = _data['droppFacilityName'];
      this.droppCountryName = _data['droppCountryName'];
      this.droppCityName = _data['droppCityName'];
      this.droppArea = _data['droppArea'];
    }
  }

  static fromJS(data: any): GetMultipleDropWaybillOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetMultipleDropWaybillOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['masterWaybillNo'] = this.masterWaybillNo;
    data['subWaybillNo'] = this.subWaybillNo;
    data['date'] = this.date;
    data['shippingRequestStatus'] = this.shippingRequestStatus;
    data['invoiceNumber'] = this.invoiceNumber;
    data['shipperReference'] = this.shipperReference;
    data['startTripDate'] = this.startTripDate;
    data['deliveryDate'] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
    data['carrierName'] = this.carrierName;
    data['clientName'] = this.clientName;
    data['totalWeight'] = this.totalWeight;
    data['goodsCategoryDisplayName'] = this.goodsCategoryDisplayName;
    data['senderCompanyName'] = this.senderCompanyName;
    data['senderContactName'] = this.senderContactName;
    data['senderMobile'] = this.senderMobile;
    data['receiverCompanyName'] = this.receiverCompanyName;
    data['receiverContactName'] = this.receiverContactName;
    data['receiverMobile'] = this.receiverMobile;
    data['driverName'] = this.driverName;
    data['driverIqamaNo'] = this.driverIqamaNo;
    data['truckTypeDisplayName'] = this.truckTypeDisplayName;
    data['plateNumber'] = this.plateNumber;
    data['packingTypeDisplayName'] = this.packingTypeDisplayName;
    data['numberOfPacking'] = this.numberOfPacking;
    data['droppFacilityName'] = this.droppFacilityName;
    data['droppCountryName'] = this.droppCountryName;
    data['droppCityName'] = this.droppCityName;
    data['droppArea'] = this.droppArea;
    return data;
  }
}

export interface IGetMultipleDropWaybillOutput {
  masterWaybillNo: number;
  subWaybillNo: number;
  date: string | undefined;
  shippingRequestStatus: string | undefined;
  invoiceNumber: number;
  shipperReference: string | undefined;
  startTripDate: string | undefined;
  deliveryDate: moment.Moment;
  carrierName: string | undefined;
  clientName: string | undefined;
  totalWeight: number;
  goodsCategoryDisplayName: string | undefined;
  senderCompanyName: string | undefined;
  senderContactName: string | undefined;
  senderMobile: string | undefined;
  receiverCompanyName: string | undefined;
  receiverContactName: string | undefined;
  receiverMobile: string | undefined;
  driverName: string | undefined;
  driverIqamaNo: string | undefined;
  truckTypeDisplayName: string | undefined;
  plateNumber: string | undefined;
  packingTypeDisplayName: string | undefined;
  numberOfPacking: number;
  droppFacilityName: string | undefined;
  droppCountryName: string | undefined;
  droppCityName: string | undefined;
  droppArea: string | undefined;
}

export class TachyonDealerBidDtoInupt implements ITachyonDealerBidDtoInupt {
  startDate!: moment.Moment | undefined;
  endDate!: moment.Moment | undefined;
  id!: number;

  constructor(data?: ITachyonDealerBidDtoInupt) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startDate = _data['startDate'] ? moment(_data['startDate'].toString()) : <any>undefined;
      this.endDate = _data['endDate'] ? moment(_data['endDate'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TachyonDealerBidDtoInupt {
    data = typeof data === 'object' ? data : {};
    let result = new TachyonDealerBidDtoInupt();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface ITachyonDealerBidDtoInupt {
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  id: number;
}

export class ShippingRequestStatusDto implements IShippingRequestStatusDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestStatusDto {
  displayName: string | undefined;
  id: number;
}

export class GetShippingRequestStatusForViewDto implements IGetShippingRequestStatusForViewDto {
  shippingRequestStatus!: ShippingRequestStatusDto;

  constructor(data?: IGetShippingRequestStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestStatus = _data['shippingRequestStatus'] ? ShippingRequestStatusDto.fromJS(_data['shippingRequestStatus']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetShippingRequestStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestStatus'] = this.shippingRequestStatus ? this.shippingRequestStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetShippingRequestStatusForViewDto {
  shippingRequestStatus: ShippingRequestStatusDto;
}

export class PagedResultDtoOfGetShippingRequestStatusForViewDto implements IPagedResultDtoOfGetShippingRequestStatusForViewDto {
  totalCount!: number;
  items!: GetShippingRequestStatusForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetShippingRequestStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetShippingRequestStatusForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetShippingRequestStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetShippingRequestStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetShippingRequestStatusForViewDto {
  totalCount: number;
  items: GetShippingRequestStatusForViewDto[] | undefined;
}

export class CreateOrEditShippingRequestStatusDto implements ICreateOrEditShippingRequestStatusDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestStatusDto {
  displayName: string;
  id: number | undefined;
}

export class GetShippingRequestStatusForEditOutput implements IGetShippingRequestStatusForEditOutput {
  shippingRequestStatus!: CreateOrEditShippingRequestStatusDto;

  constructor(data?: IGetShippingRequestStatusForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestStatus = _data['shippingRequestStatus']
        ? CreateOrEditShippingRequestStatusDto.fromJS(_data['shippingRequestStatus'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetShippingRequestStatusForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestStatusForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestStatus'] = this.shippingRequestStatus ? this.shippingRequestStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetShippingRequestStatusForEditOutput {
  shippingRequestStatus: CreateOrEditShippingRequestStatusDto;
}

export class ShippingRequestsTripListDto implements IShippingRequestsTripListDto {
  startTripDate!: moment.Moment;
  endTripDate!: moment.Moment;
  startWorking!: moment.Moment | undefined;
  endWorking!: moment.Moment | undefined;
  status!: ShippingRequestTripStatus;
  hasAttachment!: boolean;
  needsDeliveryNote!: boolean;
  readonly statusTitle!: string | undefined;
  driver!: string | undefined;
  truck!: string | undefined;
  originFacility!: string | undefined;
  destinationFacility!: string | undefined;
  hasAccident!: boolean;
  isApproveCancledByShipper!: boolean;
  isApproveCancledByCarrier!: boolean;
  driverStatus!: ShippingRequestTripDriverStatus;
  driverStatusTitle!: string | undefined;
  rejectedReason!: string | undefined;
  waybillNumber!: number | undefined;
  id!: number;

  constructor(data?: IShippingRequestsTripListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.startWorking = _data['startWorking'] ? moment(_data['startWorking'].toString()) : <any>undefined;
      this.endWorking = _data['endWorking'] ? moment(_data['endWorking'].toString()) : <any>undefined;
      this.status = _data['status'];
      this.hasAttachment = _data['hasAttachment'];
      this.needsDeliveryNote = _data['needsDeliveryNote'];
      (<any>this).statusTitle = _data['statusTitle'];
      this.driver = _data['driver'];
      this.truck = _data['truck'];
      this.originFacility = _data['originFacility'];
      this.destinationFacility = _data['destinationFacility'];
      this.hasAccident = _data['hasAccident'];
      this.isApproveCancledByShipper = _data['isApproveCancledByShipper'];
      this.isApproveCancledByCarrier = _data['isApproveCancledByCarrier'];
      this.driverStatus = _data['driverStatus'];
      this.driverStatusTitle = _data['driverStatusTitle'];
      this.rejectedReason = _data['rejectedReason'];
      this.waybillNumber = _data['waybillNumber'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestsTripListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestsTripListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['startWorking'] = this.startWorking ? this.startWorking.toISOString() : <any>undefined;
    data['endWorking'] = this.endWorking ? this.endWorking.toISOString() : <any>undefined;
    data['status'] = this.status;
    data['hasAttachment'] = this.hasAttachment;
    data['needsDeliveryNote'] = this.needsDeliveryNote;
    data['statusTitle'] = this.statusTitle;
    data['driver'] = this.driver;
    data['truck'] = this.truck;
    data['originFacility'] = this.originFacility;
    data['destinationFacility'] = this.destinationFacility;
    data['hasAccident'] = this.hasAccident;
    data['isApproveCancledByShipper'] = this.isApproveCancledByShipper;
    data['isApproveCancledByCarrier'] = this.isApproveCancledByCarrier;
    data['driverStatus'] = this.driverStatus;
    data['driverStatusTitle'] = this.driverStatusTitle;
    data['rejectedReason'] = this.rejectedReason;
    data['waybillNumber'] = this.waybillNumber;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestsTripListDto {
  startTripDate: moment.Moment;
  endTripDate: moment.Moment;
  startWorking: moment.Moment | undefined;
  endWorking: moment.Moment | undefined;
  status: ShippingRequestTripStatus;
  hasAttachment: boolean;
  needsDeliveryNote: boolean;
  statusTitle: string | undefined;
  driver: string | undefined;
  truck: string | undefined;
  originFacility: string | undefined;
  destinationFacility: string | undefined;
  hasAccident: boolean;
  isApproveCancledByShipper: boolean;
  isApproveCancledByCarrier: boolean;
  driverStatus: ShippingRequestTripDriverStatus;
  driverStatusTitle: string | undefined;
  rejectedReason: string | undefined;
  waybillNumber: number | undefined;
  id: number;
}

export class PagedResultDtoOfShippingRequestsTripListDto implements IPagedResultDtoOfShippingRequestsTripListDto {
  totalCount!: number;
  items!: ShippingRequestsTripListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfShippingRequestsTripListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestsTripListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfShippingRequestsTripListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfShippingRequestsTripListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfShippingRequestsTripListDto {
  totalCount: number;
  items: ShippingRequestsTripListDto[] | undefined;
}

export class ShippingRequestTripVasDto implements IShippingRequestTripVasDto {
  name!: string | undefined;

  constructor(data?: IShippingRequestTripVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): ShippingRequestTripVasDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripVasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface IShippingRequestTripVasDto {
  name: string | undefined;
}

export class ShippingRequestsTripForViewDto implements IShippingRequestsTripForViewDto {
  startTripDate!: moment.Moment;
  endTripDate!: moment.Moment;
  startWorking!: moment.Moment | undefined;
  endWorking!: moment.Moment | undefined;
  status!: string | undefined;
  assignedDriverUserId!: number | undefined;
  assignedTruckId!: number | undefined;
  hasAttachment!: boolean;
  needsDeliveryNote!: boolean;
  driver!: string | undefined;
  truck!: string | undefined;
  originFacility!: string | undefined;
  destinationFacility!: string | undefined;
  routPoints!: RoutPointDto[] | undefined;
  shippingRequestTripVases!: ShippingRequestTripVasDto[] | undefined;
  driverStatus!: ShippingRequestTripDriverStatus;
  driverStatusTitle!: string | undefined;
  rejectedReason!: string | undefined;
  totalValue!: string | undefined;

  constructor(data?: IShippingRequestsTripForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.startWorking = _data['startWorking'] ? moment(_data['startWorking'].toString()) : <any>undefined;
      this.endWorking = _data['endWorking'] ? moment(_data['endWorking'].toString()) : <any>undefined;
      this.status = _data['status'];
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.assignedTruckId = _data['assignedTruckId'];
      this.hasAttachment = _data['hasAttachment'];
      this.needsDeliveryNote = _data['needsDeliveryNote'];
      this.driver = _data['driver'];
      this.truck = _data['truck'];
      this.originFacility = _data['originFacility'];
      this.destinationFacility = _data['destinationFacility'];
      if (Array.isArray(_data['routPoints'])) {
        this.routPoints = [] as any;
        for (let item of _data['routPoints']) this.routPoints!.push(RoutPointDto.fromJS(item));
      }
      if (Array.isArray(_data['shippingRequestTripVases'])) {
        this.shippingRequestTripVases = [] as any;
        for (let item of _data['shippingRequestTripVases']) this.shippingRequestTripVases!.push(ShippingRequestTripVasDto.fromJS(item));
      }
      this.driverStatus = _data['driverStatus'];
      this.driverStatusTitle = _data['driverStatusTitle'];
      this.rejectedReason = _data['rejectedReason'];
      this.totalValue = _data['totalValue'];
    }
  }

  static fromJS(data: any): ShippingRequestsTripForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestsTripForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['startWorking'] = this.startWorking ? this.startWorking.toISOString() : <any>undefined;
    data['endWorking'] = this.endWorking ? this.endWorking.toISOString() : <any>undefined;
    data['status'] = this.status;
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['assignedTruckId'] = this.assignedTruckId;
    data['hasAttachment'] = this.hasAttachment;
    data['needsDeliveryNote'] = this.needsDeliveryNote;
    data['driver'] = this.driver;
    data['truck'] = this.truck;
    data['originFacility'] = this.originFacility;
    data['destinationFacility'] = this.destinationFacility;
    if (Array.isArray(this.routPoints)) {
      data['routPoints'] = [];
      for (let item of this.routPoints) data['routPoints'].push(item.toJSON());
    }
    if (Array.isArray(this.shippingRequestTripVases)) {
      data['shippingRequestTripVases'] = [];
      for (let item of this.shippingRequestTripVases) data['shippingRequestTripVases'].push(item.toJSON());
    }
    data['driverStatus'] = this.driverStatus;
    data['driverStatusTitle'] = this.driverStatusTitle;
    data['rejectedReason'] = this.rejectedReason;
    data['totalValue'] = this.totalValue;
    return data;
  }
}

export interface IShippingRequestsTripForViewDto {
  startTripDate: moment.Moment;
  endTripDate: moment.Moment;
  startWorking: moment.Moment | undefined;
  endWorking: moment.Moment | undefined;
  status: string | undefined;
  assignedDriverUserId: number | undefined;
  assignedTruckId: number | undefined;
  hasAttachment: boolean;
  needsDeliveryNote: boolean;
  driver: string | undefined;
  truck: string | undefined;
  originFacility: string | undefined;
  destinationFacility: string | undefined;
  routPoints: RoutPointDto[] | undefined;
  shippingRequestTripVases: ShippingRequestTripVasDto[] | undefined;
  driverStatus: ShippingRequestTripDriverStatus;
  driverStatusTitle: string | undefined;
  rejectedReason: string | undefined;
  totalValue: string | undefined;
}

export class CreateOrEditShippingRequestTripVasDto implements ICreateOrEditShippingRequestTripVasDto {
  shippingRequestVasId!: number | undefined;
  shippingRequestTripId!: number | undefined;
  name!: string | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestTripVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestVasId = _data['shippingRequestVasId'];
      this.shippingRequestTripId = _data['shippingRequestTripId'];
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestTripVasDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestTripVasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestVasId'] = this.shippingRequestVasId;
    data['shippingRequestTripId'] = this.shippingRequestTripId;
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestTripVasDto {
  shippingRequestVasId: number | undefined;
  shippingRequestTripId: number | undefined;
  name: string | undefined;
  id: number | undefined;
}

export class CreateOrEditShippingRequestTripDto implements ICreateOrEditShippingRequestTripDto {
  startTripDate!: moment.Moment;
  endTripDate!: moment.Moment;
  shippingRequestId!: number;
  hasAttachment!: boolean;
  needsDeliveryNote!: boolean;
  originFacilityId!: number | undefined;
  destinationFacilityId!: number | undefined;
  totalValue!: string | undefined;
  routPoints!: CreateOrEditRoutPointDto[] | undefined;
  shippingRequestTripVases!: CreateOrEditShippingRequestTripVasDto[] | undefined;
  createOrEditDocumentFileDto!: CreateOrEditDocumentFileDto;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestTripDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startTripDate = _data['startTripDate'] ? moment(_data['startTripDate'].toString()) : <any>undefined;
      this.endTripDate = _data['endTripDate'] ? moment(_data['endTripDate'].toString()) : <any>undefined;
      this.shippingRequestId = _data['shippingRequestId'];
      this.hasAttachment = _data['hasAttachment'];
      this.needsDeliveryNote = _data['needsDeliveryNote'];
      this.originFacilityId = _data['originFacilityId'];
      this.destinationFacilityId = _data['destinationFacilityId'];
      this.totalValue = _data['totalValue'];
      if (Array.isArray(_data['routPoints'])) {
        this.routPoints = [] as any;
        for (let item of _data['routPoints']) this.routPoints!.push(CreateOrEditRoutPointDto.fromJS(item));
      }
      if (Array.isArray(_data['shippingRequestTripVases'])) {
        this.shippingRequestTripVases = [] as any;
        for (let item of _data['shippingRequestTripVases']) this.shippingRequestTripVases!.push(CreateOrEditShippingRequestTripVasDto.fromJS(item));
      }
      this.createOrEditDocumentFileDto = _data['createOrEditDocumentFileDto']
        ? CreateOrEditDocumentFileDto.fromJS(_data['createOrEditDocumentFileDto'])
        : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestTripDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestTripDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['startTripDate'] = this.startTripDate ? this.startTripDate.toISOString() : <any>undefined;
    data['endTripDate'] = this.endTripDate ? this.endTripDate.toISOString() : <any>undefined;
    data['shippingRequestId'] = this.shippingRequestId;
    data['hasAttachment'] = this.hasAttachment;
    data['needsDeliveryNote'] = this.needsDeliveryNote;
    data['originFacilityId'] = this.originFacilityId;
    data['destinationFacilityId'] = this.destinationFacilityId;
    data['totalValue'] = this.totalValue;
    if (Array.isArray(this.routPoints)) {
      data['routPoints'] = [];
      for (let item of this.routPoints) data['routPoints'].push(item.toJSON());
    }
    if (Array.isArray(this.shippingRequestTripVases)) {
      data['shippingRequestTripVases'] = [];
      for (let item of this.shippingRequestTripVases) data['shippingRequestTripVases'].push(item.toJSON());
    }
    data['createOrEditDocumentFileDto'] = this.createOrEditDocumentFileDto ? this.createOrEditDocumentFileDto.toJSON() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestTripDto {
  startTripDate: moment.Moment;
  endTripDate: moment.Moment;
  shippingRequestId: number;
  hasAttachment: boolean;
  needsDeliveryNote: boolean;
  originFacilityId: number | undefined;
  destinationFacilityId: number | undefined;
  totalValue: string | undefined;
  routPoints: CreateOrEditRoutPointDto[] | undefined;
  shippingRequestTripVases: CreateOrEditShippingRequestTripVasDto[] | undefined;
  createOrEditDocumentFileDto: CreateOrEditDocumentFileDto;
  id: number | undefined;
}

export class AssignDriverAndTruckToShippmentByCarrierInput implements IAssignDriverAndTruckToShippmentByCarrierInput {
  assignedDriverUserId!: number | undefined;
  assignedTruckId!: number | undefined;
  id!: number;

  constructor(data?: IAssignDriverAndTruckToShippmentByCarrierInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.assignedTruckId = _data['assignedTruckId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): AssignDriverAndTruckToShippmentByCarrierInput {
    data = typeof data === 'object' ? data : {};
    let result = new AssignDriverAndTruckToShippmentByCarrierInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['assignedTruckId'] = this.assignedTruckId;
    data['id'] = this.id;
    return data;
  }
}

export interface IAssignDriverAndTruckToShippmentByCarrierInput {
  assignedDriverUserId: number | undefined;
  assignedTruckId: number | undefined;
  id: number;
}

export class ShippingRequestTripAccidentListDto implements IShippingRequestTripAccidentListDto {
  pointId!: number;
  pickingType!: string | undefined;
  address!: string | undefined;
  reason!: string | undefined;
  description!: string | undefined;
  isResolve!: boolean;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  creationTime!: moment.Moment;
  id!: number;

  constructor(data?: IShippingRequestTripAccidentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pointId = _data['pointId'];
      this.pickingType = _data['pickingType'];
      this.address = _data['address'];
      this.reason = _data['reason'];
      this.description = _data['description'];
      this.isResolve = _data['isResolve'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripAccidentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripAccidentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pointId'] = this.pointId;
    data['pickingType'] = this.pickingType;
    data['address'] = this.address;
    data['reason'] = this.reason;
    data['description'] = this.description;
    data['isResolve'] = this.isResolve;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripAccidentListDto {
  pointId: number;
  pickingType: string | undefined;
  address: string | undefined;
  reason: string | undefined;
  description: string | undefined;
  isResolve: boolean;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  creationTime: moment.Moment;
  id: number;
}

export class ListResultDtoOfShippingRequestTripAccidentListDto implements IListResultDtoOfShippingRequestTripAccidentListDto {
  items!: ShippingRequestTripAccidentListDto[] | undefined;

  constructor(data?: IListResultDtoOfShippingRequestTripAccidentListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestTripAccidentListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfShippingRequestTripAccidentListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfShippingRequestTripAccidentListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfShippingRequestTripAccidentListDto {
  items: ShippingRequestTripAccidentListDto[] | undefined;
}

export class CreateOrEditShippingRequestTripAccidentDto implements ICreateOrEditShippingRequestTripAccidentDto {
  tripId!: number | undefined;
  reasoneId!: number | undefined;
  description!: string | undefined;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  documentBase64!: string | undefined;
  lat!: number | undefined;
  lng!: number | undefined;
  id!: number;

  constructor(data?: ICreateOrEditShippingRequestTripAccidentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tripId = _data['tripId'];
      this.reasoneId = _data['reasoneId'];
      this.description = _data['description'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.documentBase64 = _data['documentBase64'];
      this.lat = _data['lat'];
      this.lng = _data['lng'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestTripAccidentDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestTripAccidentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tripId'] = this.tripId;
    data['reasoneId'] = this.reasoneId;
    data['description'] = this.description;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['documentBase64'] = this.documentBase64;
    data['lat'] = this.lat;
    data['lng'] = this.lng;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestTripAccidentDto {
  tripId: number | undefined;
  reasoneId: number | undefined;
  description: string | undefined;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  documentBase64: string | undefined;
  lat: number | undefined;
  lng: number | undefined;
  id: number;
}

export class CreateOrEditShippingRequestTripAccidentResolveDto implements ICreateOrEditShippingRequestTripAccidentResolveDto {
  accidentId!: number;
  description!: string | undefined;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  documentBase64!: string | undefined;
  id!: number;

  constructor(data?: ICreateOrEditShippingRequestTripAccidentResolveDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accidentId = _data['accidentId'];
      this.description = _data['description'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.documentBase64 = _data['documentBase64'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestTripAccidentResolveDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestTripAccidentResolveDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accidentId'] = this.accidentId;
    data['description'] = this.description;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['documentBase64'] = this.documentBase64;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestTripAccidentResolveDto {
  accidentId: number;
  description: string | undefined;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  documentBase64: string | undefined;
  id: number;
}

export class ShippingRequestTripRejectReasonListDto implements IShippingRequestTripRejectReasonListDto {
  name!: string | undefined;
  id!: number;

  constructor(data?: IShippingRequestTripRejectReasonListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingRequestTripRejectReasonListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripRejectReasonListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingRequestTripRejectReasonListDto {
  name: string | undefined;
  id: number;
}

export class ListResultDtoOfShippingRequestTripRejectReasonListDto implements IListResultDtoOfShippingRequestTripRejectReasonListDto {
  items!: ShippingRequestTripRejectReasonListDto[] | undefined;

  constructor(data?: IListResultDtoOfShippingRequestTripRejectReasonListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShippingRequestTripRejectReasonListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfShippingRequestTripRejectReasonListDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfShippingRequestTripRejectReasonListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfShippingRequestTripRejectReasonListDto {
  items: ShippingRequestTripRejectReasonListDto[] | undefined;
}

export class ShippingRequestTripRejectReasonTranslationDto implements IShippingRequestTripRejectReasonTranslationDto {
  name!: string;
  language!: string;
  icon!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: IShippingRequestTripRejectReasonTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.language = _data['language'];
      this.icon = _data['icon'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): ShippingRequestTripRejectReasonTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestTripRejectReasonTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['language'] = this.language;
    data['icon'] = this.icon;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IShippingRequestTripRejectReasonTranslationDto {
  name: string;
  language: string;
  icon: string | undefined;
  displayName: string | undefined;
}

export class CreateOrEditShippingRequestTripRejectReasonDto implements ICreateOrEditShippingRequestTripRejectReasonDto {
  translations!: ShippingRequestTripRejectReasonTranslationDto[] | undefined;
  id!: number;

  constructor(data?: ICreateOrEditShippingRequestTripRejectReasonDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(ShippingRequestTripRejectReasonTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestTripRejectReasonDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestTripRejectReasonDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestTripRejectReasonDto {
  translations: ShippingRequestTripRejectReasonTranslationDto[] | undefined;
  id: number;
}

export class PagedResultDtoOfGetShippingRequestVasForViewDto implements IPagedResultDtoOfGetShippingRequestVasForViewDto {
  totalCount!: number;
  items!: GetShippingRequestVasForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetShippingRequestVasForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetShippingRequestVasForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetShippingRequestVasForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetShippingRequestVasForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetShippingRequestVasForViewDto {
  totalCount: number;
  items: GetShippingRequestVasForViewDto[] | undefined;
}

export class CreateOrEditShippingRequestVasDto implements ICreateOrEditShippingRequestVasDto {
  vasId!: number;
  requestMaxAmount!: number;
  requestMaxCount!: number;
  numberOfTrips!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingRequestVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vasId = _data['vasId'];
      this.requestMaxAmount = _data['requestMaxAmount'];
      this.requestMaxCount = _data['requestMaxCount'];
      this.numberOfTrips = _data['numberOfTrips'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingRequestVasDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingRequestVasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vasId'] = this.vasId;
    data['requestMaxAmount'] = this.requestMaxAmount;
    data['requestMaxCount'] = this.requestMaxCount;
    data['numberOfTrips'] = this.numberOfTrips;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingRequestVasDto {
  vasId: number;
  requestMaxAmount: number;
  requestMaxCount: number;
  numberOfTrips: number;
  id: number | undefined;
}

export class GetShippingRequestVasForEditOutput implements IGetShippingRequestVasForEditOutput {
  shippingRequestVas!: CreateOrEditShippingRequestVasDto;
  vasName!: string | undefined;

  constructor(data?: IGetShippingRequestVasForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingRequestVas = _data['shippingRequestVas'] ? CreateOrEditShippingRequestVasDto.fromJS(_data['shippingRequestVas']) : <any>undefined;
      this.vasName = _data['vasName'];
    }
  }

  static fromJS(data: any): GetShippingRequestVasForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingRequestVasForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingRequestVas'] = this.shippingRequestVas ? this.shippingRequestVas.toJSON() : <any>undefined;
    data['vasName'] = this.vasName;
    return data;
  }
}

export interface IGetShippingRequestVasForEditOutput {
  shippingRequestVas: CreateOrEditShippingRequestVasDto;
  vasName: string | undefined;
}

export class ShippingRequestVasVasLookupTableDto implements IShippingRequestVasVasLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IShippingRequestVasVasLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): ShippingRequestVasVasLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingRequestVasVasLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IShippingRequestVasVasLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class ShippingTypeDto implements IShippingTypeDto {
  displayName!: string | undefined;
  description!: string | undefined;
  id!: number;

  constructor(data?: IShippingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ShippingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShippingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface IShippingTypeDto {
  displayName: string | undefined;
  description: string | undefined;
  id: number;
}

export class GetShippingTypeForViewDto implements IGetShippingTypeForViewDto {
  shippingType!: ShippingTypeDto;

  constructor(data?: IGetShippingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingType = _data['shippingType'] ? ShippingTypeDto.fromJS(_data['shippingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetShippingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingType'] = this.shippingType ? this.shippingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetShippingTypeForViewDto {
  shippingType: ShippingTypeDto;
}

export class PagedResultDtoOfGetShippingTypeForViewDto implements IPagedResultDtoOfGetShippingTypeForViewDto {
  totalCount!: number;
  items!: GetShippingTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetShippingTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetShippingTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetShippingTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetShippingTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetShippingTypeForViewDto {
  totalCount: number;
  items: GetShippingTypeForViewDto[] | undefined;
}

export class CreateOrEditShippingTypeDto implements ICreateOrEditShippingTypeDto {
  displayName!: string;
  description!: string | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditShippingTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditShippingTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditShippingTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditShippingTypeDto {
  displayName: string;
  description: string | undefined;
  id: number | undefined;
}

export class GetShippingTypeForEditOutput implements IGetShippingTypeForEditOutput {
  shippingType!: CreateOrEditShippingTypeDto;

  constructor(data?: IGetShippingTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shippingType = _data['shippingType'] ? CreateOrEditShippingTypeDto.fromJS(_data['shippingType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetShippingTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetShippingTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shippingType'] = this.shippingType ? this.shippingType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetShippingTypeForEditOutput {
  shippingType: CreateOrEditShippingTypeDto;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
  publishableKey!: string | undefined;

  constructor(data?: IStripeConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.publishableKey = _data['publishableKey'];
    }
  }

  static fromJS(data: any): StripeConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new StripeConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['publishableKey'] = this.publishableKey;
    return data;
  }
}

export interface IStripeConfigurationDto {
  publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
  paymentId!: number;
  successUrl!: string | undefined;
  cancelUrl!: string | undefined;

  constructor(data?: IStripeCreatePaymentSessionInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentId = _data['paymentId'];
      this.successUrl = _data['successUrl'];
      this.cancelUrl = _data['cancelUrl'];
    }
  }

  static fromJS(data: any): StripeCreatePaymentSessionInput {
    data = typeof data === 'object' ? data : {};
    let result = new StripeCreatePaymentSessionInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentId'] = this.paymentId;
    data['successUrl'] = this.successUrl;
    data['cancelUrl'] = this.cancelUrl;
    return data;
  }
}

export interface IStripeCreatePaymentSessionInput {
  paymentId: number;
  successUrl: string | undefined;
  cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
  paymentDone!: boolean;

  constructor(data?: IStripePaymentResultOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentDone = _data['paymentDone'];
    }
  }

  static fromJS(data: any): StripePaymentResultOutput {
    data = typeof data === 'object' ? data : {};
    let result = new StripePaymentResultOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentDone'] = this.paymentDone;
    return data;
  }
}

export interface IStripePaymentResultOutput {
  paymentDone: boolean;
}

export enum SubmitInvoiceStatus {
  New = 0,
  Claim = 1,
  Accepted = 2,
  Rejected = 3,
}

export class SubmitInvoiceListDto implements ISubmitInvoiceListDto {
  referencNumber!: number | undefined;
  tenantName!: string | undefined;
  period!: string | undefined;
  status!: SubmitInvoiceStatus;
  readonly statusTitle!: string | undefined;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  creationTime!: moment.Moment;
  totalAmount!: number;
  id!: number;

  constructor(data?: ISubmitInvoiceListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.referencNumber = _data['referencNumber'];
      this.tenantName = _data['tenantName'];
      this.period = _data['period'];
      this.status = _data['status'];
      (<any>this).statusTitle = _data['statusTitle'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.totalAmount = _data['totalAmount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubmitInvoiceListDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubmitInvoiceListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['referencNumber'] = this.referencNumber;
    data['tenantName'] = this.tenantName;
    data['period'] = this.period;
    data['status'] = this.status;
    data['statusTitle'] = this.statusTitle;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['totalAmount'] = this.totalAmount;
    data['id'] = this.id;
    return data;
  }
}

export interface ISubmitInvoiceListDto {
  referencNumber: number | undefined;
  tenantName: string | undefined;
  period: string | undefined;
  status: SubmitInvoiceStatus;
  statusTitle: string | undefined;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  creationTime: moment.Moment;
  totalAmount: number;
  id: number;
}

export class PagedResultDtoOfSubmitInvoiceListDto implements IPagedResultDtoOfSubmitInvoiceListDto {
  totalCount!: number;
  items!: SubmitInvoiceListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfSubmitInvoiceListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubmitInvoiceListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfSubmitInvoiceListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfSubmitInvoiceListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfSubmitInvoiceListDto {
  totalCount: number;
  items: SubmitInvoiceListDto[] | undefined;
}

export class SubmitInvoiceInfoDto implements ISubmitInvoiceInfoDto {
  clientName!: string | undefined;
  email!: string | undefined;
  address!: string | undefined;
  phone!: string | undefined;
  faxNo!: string | undefined;
  attn!: string | undefined;
  cr!: string | undefined;
  contractNo!: string | undefined;
  projectName!: string | undefined;
  period!: string | undefined;
  dueDate!: moment.Moment;
  creationTime!: moment.Moment;
  note!: string | undefined;
  subTotalAmount!: number;
  totalAmount!: number;
  vatAmount!: number;
  taxVat!: number;
  invoiceNumber!: number;
  items!: InvoiceItemDto[] | undefined;
  id!: number;

  constructor(data?: ISubmitInvoiceInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientName = _data['clientName'];
      this.email = _data['email'];
      this.address = _data['address'];
      this.phone = _data['phone'];
      this.faxNo = _data['faxNo'];
      this.attn = _data['attn'];
      this.cr = _data['cr'];
      this.contractNo = _data['contractNo'];
      this.projectName = _data['projectName'];
      this.period = _data['period'];
      this.dueDate = _data['dueDate'] ? moment(_data['dueDate'].toString()) : <any>undefined;
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.note = _data['note'];
      this.subTotalAmount = _data['subTotalAmount'];
      this.totalAmount = _data['totalAmount'];
      this.vatAmount = _data['vatAmount'];
      this.taxVat = _data['taxVat'];
      this.invoiceNumber = _data['invoiceNumber'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(InvoiceItemDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubmitInvoiceInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubmitInvoiceInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientName'] = this.clientName;
    data['email'] = this.email;
    data['address'] = this.address;
    data['phone'] = this.phone;
    data['faxNo'] = this.faxNo;
    data['attn'] = this.attn;
    data['cr'] = this.cr;
    data['contractNo'] = this.contractNo;
    data['projectName'] = this.projectName;
    data['period'] = this.period;
    data['dueDate'] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['note'] = this.note;
    data['subTotalAmount'] = this.subTotalAmount;
    data['totalAmount'] = this.totalAmount;
    data['vatAmount'] = this.vatAmount;
    data['taxVat'] = this.taxVat;
    data['invoiceNumber'] = this.invoiceNumber;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ISubmitInvoiceInfoDto {
  clientName: string | undefined;
  email: string | undefined;
  address: string | undefined;
  phone: string | undefined;
  faxNo: string | undefined;
  attn: string | undefined;
  cr: string | undefined;
  contractNo: string | undefined;
  projectName: string | undefined;
  period: string | undefined;
  dueDate: moment.Moment;
  creationTime: moment.Moment;
  note: string | undefined;
  subTotalAmount: number;
  totalAmount: number;
  vatAmount: number;
  taxVat: number;
  invoiceNumber: number;
  items: InvoiceItemDto[] | undefined;
  id: number;
}

export class SubmitInvoiceClaimCreateInput implements ISubmitInvoiceClaimCreateInput {
  documentBase64!: string;
  documentId!: string | undefined;
  documentName!: string | undefined;
  documentContentType!: string | undefined;
  id!: number;

  constructor(data?: ISubmitInvoiceClaimCreateInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentBase64 = _data['documentBase64'];
      this.documentId = _data['documentId'];
      this.documentName = _data['documentName'];
      this.documentContentType = _data['documentContentType'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubmitInvoiceClaimCreateInput {
    data = typeof data === 'object' ? data : {};
    let result = new SubmitInvoiceClaimCreateInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentBase64'] = this.documentBase64;
    data['documentId'] = this.documentId;
    data['documentName'] = this.documentName;
    data['documentContentType'] = this.documentContentType;
    data['id'] = this.id;
    return data;
  }
}

export interface ISubmitInvoiceClaimCreateInput {
  documentBase64: string;
  documentId: string | undefined;
  documentName: string | undefined;
  documentContentType: string | undefined;
  id: number;
}

export class SubmitInvoiceRejectedInput implements ISubmitInvoiceRejectedInput {
  reason!: string;
  id!: number;

  constructor(data?: ISubmitInvoiceRejectedInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reason = _data['reason'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubmitInvoiceRejectedInput {
    data = typeof data === 'object' ? data : {};
    let result = new SubmitInvoiceRejectedInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reason'] = this.reason;
    data['id'] = this.id;
    return data;
  }
}

export interface ISubmitInvoiceRejectedInput {
  reason: string;
  id: number;
}

export class SubmitInvoiceFilterInput implements ISubmitInvoiceFilterInput {
  tenantId!: number | undefined;
  periodId!: number | undefined;
  fromDate!: moment.Moment | undefined;
  toDate!: moment.Moment | undefined;
  status!: SubmitInvoiceStatus;
  sorting!: string | undefined;
  skipCount!: number;
  maxResultCount!: number;

  constructor(data?: ISubmitInvoiceFilterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.periodId = _data['periodId'];
      this.fromDate = _data['fromDate'] ? moment(_data['fromDate'].toString()) : <any>undefined;
      this.toDate = _data['toDate'] ? moment(_data['toDate'].toString()) : <any>undefined;
      this.status = _data['status'];
      this.sorting = _data['sorting'];
      this.skipCount = _data['skipCount'];
      this.maxResultCount = _data['maxResultCount'];
    }
  }

  static fromJS(data: any): SubmitInvoiceFilterInput {
    data = typeof data === 'object' ? data : {};
    let result = new SubmitInvoiceFilterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['periodId'] = this.periodId;
    data['fromDate'] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
    data['toDate'] = this.toDate ? this.toDate.toISOString() : <any>undefined;
    data['status'] = this.status;
    data['sorting'] = this.sorting;
    data['skipCount'] = this.skipCount;
    data['maxResultCount'] = this.maxResultCount;
    return data;
  }
}

export interface ISubmitInvoiceFilterInput {
  tenantId: number | undefined;
  periodId: number | undefined;
  fromDate: moment.Moment | undefined;
  toDate: moment.Moment | undefined;
  status: SubmitInvoiceStatus;
  sorting: string | undefined;
  skipCount: number;
  maxResultCount: number;
}

export class TenantListDto implements ITenantListDto {
  tenancyName!: string | undefined;
  name!: string | undefined;
  accountNumber!: string | undefined;
  editionDisplayName!: string | undefined;
  connectionString!: string | undefined;
  isActive!: boolean;
  creationTime!: moment.Moment;
  subscriptionEndDateUtc!: moment.Moment | undefined;
  editionId!: number | undefined;
  isInTrialPeriod!: boolean;
  id!: number;

  constructor(data?: ITenantListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.accountNumber = _data['accountNumber'];
      this.editionDisplayName = _data['editionDisplayName'];
      this.connectionString = _data['connectionString'];
      this.isActive = _data['isActive'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.subscriptionEndDateUtc = _data['subscriptionEndDateUtc'] ? moment(_data['subscriptionEndDateUtc'].toString()) : <any>undefined;
      this.editionId = _data['editionId'];
      this.isInTrialPeriod = _data['isInTrialPeriod'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantListDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['accountNumber'] = this.accountNumber;
    data['editionDisplayName'] = this.editionDisplayName;
    data['connectionString'] = this.connectionString;
    data['isActive'] = this.isActive;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['subscriptionEndDateUtc'] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
    data['editionId'] = this.editionId;
    data['isInTrialPeriod'] = this.isInTrialPeriod;
    data['id'] = this.id;
    return data;
  }
}

export interface ITenantListDto {
  tenancyName: string | undefined;
  name: string | undefined;
  accountNumber: string | undefined;
  editionDisplayName: string | undefined;
  connectionString: string | undefined;
  isActive: boolean;
  creationTime: moment.Moment;
  subscriptionEndDateUtc: moment.Moment | undefined;
  editionId: number | undefined;
  isInTrialPeriod: boolean;
  id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
  totalCount!: number;
  items!: TenantListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTenantListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenantListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTenantListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTenantListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfTenantListDto {
  totalCount: number;
  items: TenantListDto[] | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
  tenancyName!: string;
  companyName!: string;
  mobileNo!: string | undefined;
  name!: string;
  address!: string;
  countryId!: number;
  cityId!: number;
  adminEmailAddress!: string;
  adminPassword!: string | undefined;
  connectionString!: string | undefined;
  shouldChangePasswordOnNextLogin!: boolean;
  sendActivationEmail!: boolean;
  editionId!: number | undefined;
  isActive!: boolean;
  subscriptionEndDateUtc!: moment.Moment | undefined;
  isInTrialPeriod!: boolean;
  userAdminFirstName!: string;
  userAdminSurname!: string;

  constructor(data?: ICreateTenantInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.companyName = _data['companyName'];
      this.mobileNo = _data['mobileNo'];
      this.name = _data['name'];
      this.address = _data['address'];
      this.countryId = _data['countryId'];
      this.cityId = _data['cityId'];
      this.adminEmailAddress = _data['adminEmailAddress'];
      this.adminPassword = _data['adminPassword'];
      this.connectionString = _data['connectionString'];
      this.shouldChangePasswordOnNextLogin = _data['shouldChangePasswordOnNextLogin'];
      this.sendActivationEmail = _data['sendActivationEmail'];
      this.editionId = _data['editionId'];
      this.isActive = _data['isActive'];
      this.subscriptionEndDateUtc = _data['subscriptionEndDateUtc'] ? moment(_data['subscriptionEndDateUtc'].toString()) : <any>undefined;
      this.isInTrialPeriod = _data['isInTrialPeriod'];
      this.userAdminFirstName = _data['userAdminFirstName'];
      this.userAdminSurname = _data['userAdminSurname'];
    }
  }

  static fromJS(data: any): CreateTenantInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTenantInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['companyName'] = this.companyName;
    data['mobileNo'] = this.mobileNo;
    data['name'] = this.name;
    data['address'] = this.address;
    data['countryId'] = this.countryId;
    data['cityId'] = this.cityId;
    data['adminEmailAddress'] = this.adminEmailAddress;
    data['adminPassword'] = this.adminPassword;
    data['connectionString'] = this.connectionString;
    data['shouldChangePasswordOnNextLogin'] = this.shouldChangePasswordOnNextLogin;
    data['sendActivationEmail'] = this.sendActivationEmail;
    data['editionId'] = this.editionId;
    data['isActive'] = this.isActive;
    data['subscriptionEndDateUtc'] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
    data['isInTrialPeriod'] = this.isInTrialPeriod;
    data['userAdminFirstName'] = this.userAdminFirstName;
    data['userAdminSurname'] = this.userAdminSurname;
    return data;
  }
}

export interface ICreateTenantInput {
  tenancyName: string;
  companyName: string;
  mobileNo: string | undefined;
  name: string;
  address: string;
  countryId: number;
  cityId: number;
  adminEmailAddress: string;
  adminPassword: string | undefined;
  connectionString: string | undefined;
  shouldChangePasswordOnNextLogin: boolean;
  sendActivationEmail: boolean;
  editionId: number | undefined;
  isActive: boolean;
  subscriptionEndDateUtc: moment.Moment | undefined;
  isInTrialPeriod: boolean;
  userAdminFirstName: string;
  userAdminSurname: string;
}

export class TenantEditDto implements ITenantEditDto {
  tenancyName!: string;
  name!: string;
  mobileNo!: string | undefined;
  address!: string;
  countryId!: number;
  cityId!: number;
  connectionString!: string | undefined;
  editionId!: number | undefined;
  isActive!: boolean;
  subscriptionEndDateUtc!: moment.Moment | undefined;
  isInTrialPeriod!: boolean;
  id!: number;

  constructor(data?: ITenantEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.mobileNo = _data['mobileNo'];
      this.address = _data['address'];
      this.countryId = _data['countryId'];
      this.cityId = _data['cityId'];
      this.connectionString = _data['connectionString'];
      this.editionId = _data['editionId'];
      this.isActive = _data['isActive'];
      this.subscriptionEndDateUtc = _data['subscriptionEndDateUtc'] ? moment(_data['subscriptionEndDateUtc'].toString()) : <any>undefined;
      this.isInTrialPeriod = _data['isInTrialPeriod'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['mobileNo'] = this.mobileNo;
    data['address'] = this.address;
    data['countryId'] = this.countryId;
    data['cityId'] = this.cityId;
    data['connectionString'] = this.connectionString;
    data['editionId'] = this.editionId;
    data['isActive'] = this.isActive;
    data['subscriptionEndDateUtc'] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
    data['isInTrialPeriod'] = this.isInTrialPeriod;
    data['id'] = this.id;
    return data;
  }
}

export interface ITenantEditDto {
  tenancyName: string;
  name: string;
  mobileNo: string | undefined;
  address: string;
  countryId: number;
  cityId: number;
  connectionString: string | undefined;
  editionId: number | undefined;
  isActive: boolean;
  subscriptionEndDateUtc: moment.Moment | undefined;
  isInTrialPeriod: boolean;
  id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
  featureValues!: NameValueDto[] | undefined;
  features!: FlatFeatureDto[] | undefined;

  constructor(data?: IGetTenantFeaturesEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
      if (Array.isArray(_data['features'])) {
        this.features = [] as any;
        for (let item of _data['features']) this.features!.push(FlatFeatureDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetTenantFeaturesEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTenantFeaturesEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    if (Array.isArray(this.features)) {
      data['features'] = [];
      for (let item of this.features) data['features'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetTenantFeaturesEditOutput {
  featureValues: NameValueDto[] | undefined;
  features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
  id!: number;
  featureValues!: NameValueDto[];

  constructor(data?: IUpdateTenantFeaturesInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.featureValues = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdateTenantFeaturesInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTenantFeaturesInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdateTenantFeaturesInput {
  id: number;
  featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
  id!: number;

  constructor(data?: IEntityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDto {
  id: number;
}

export class TenantCountryLookupTableDto implements ITenantCountryLookupTableDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: ITenantCountryLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): TenantCountryLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantCountryLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ITenantCountryLookupTableDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class TenantCityLookupTableDto implements ITenantCityLookupTableDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: ITenantCityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): TenantCityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantCityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ITenantCityLookupTableDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class TenantCarriersListDto implements ITenantCarriersListDto {
  carrierName!: string | undefined;
  id!: number;

  constructor(data?: ITenantCarriersListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.carrierName = _data['carrierName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TenantCarriersListDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantCarriersListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['carrierName'] = this.carrierName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITenantCarriersListDto {
  carrierName: string | undefined;
  id: number;
}

export class PagedResultDtoOfTenantCarriersListDto implements IPagedResultDtoOfTenantCarriersListDto {
  totalCount!: number;
  items!: TenantCarriersListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTenantCarriersListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenantCarriersListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTenantCarriersListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTenantCarriersListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfTenantCarriersListDto {
  totalCount: number;
  items: TenantCarriersListDto[] | undefined;
}

export class CreateTenantCarrierInput implements ICreateTenantCarrierInput {
  carrierTenantId!: number;
  tenantId!: number;

  constructor(data?: ICreateTenantCarrierInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.carrierTenantId = _data['carrierTenantId'];
      this.tenantId = _data['tenantId'];
    }
  }

  static fromJS(data: any): CreateTenantCarrierInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTenantCarrierInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['carrierTenantId'] = this.carrierTenantId;
    data['tenantId'] = this.tenantId;
    return data;
  }
}

export interface ICreateTenantCarrierInput {
  carrierTenantId: number;
  tenantId: number;
}

export class MemberActivity implements IMemberActivity {
  name!: string | undefined;
  earnings!: string | undefined;
  cases!: number;
  closed!: number;
  rate!: string | undefined;

  constructor(data?: IMemberActivity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.earnings = _data['earnings'];
      this.cases = _data['cases'];
      this.closed = _data['closed'];
      this.rate = _data['rate'];
    }
  }

  static fromJS(data: any): MemberActivity {
    data = typeof data === 'object' ? data : {};
    let result = new MemberActivity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['earnings'] = this.earnings;
    data['cases'] = this.cases;
    data['closed'] = this.closed;
    data['rate'] = this.rate;
    return data;
  }
}

export interface IMemberActivity {
  name: string | undefined;
  earnings: string | undefined;
  cases: number;
  closed: number;
  rate: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
  memberActivities!: MemberActivity[] | undefined;

  constructor(data?: IGetMemberActivityOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['memberActivities'])) {
        this.memberActivities = [] as any;
        for (let item of _data['memberActivities']) this.memberActivities!.push(MemberActivity.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetMemberActivityOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetMemberActivityOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.memberActivities)) {
      data['memberActivities'] = [];
      for (let item of this.memberActivities) data['memberActivities'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetMemberActivityOutput {
  memberActivities: MemberActivity[] | undefined;
}

export enum SalesSummaryDatePeriod {
  Daily = 1,
  Weekly = 2,
  Monthly = 3,
}

export class SalesSummaryData implements ISalesSummaryData {
  period!: string | undefined;
  sales!: number;
  profit!: number;

  constructor(data?: ISalesSummaryData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.period = _data['period'];
      this.sales = _data['sales'];
      this.profit = _data['profit'];
    }
  }

  static fromJS(data: any): SalesSummaryData {
    data = typeof data === 'object' ? data : {};
    let result = new SalesSummaryData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['period'] = this.period;
    data['sales'] = this.sales;
    data['profit'] = this.profit;
    return data;
  }
}

export interface ISalesSummaryData {
  period: string | undefined;
  sales: number;
  profit: number;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
  totalProfit!: number;
  newFeedbacks!: number;
  newOrders!: number;
  newUsers!: number;
  salesSummary!: SalesSummaryData[] | undefined;
  totalSales!: number;
  revenue!: number;
  expenses!: number;
  growth!: number;
  transactionPercent!: number;
  newVisitPercent!: number;
  bouncePercent!: number;
  dailySales!: number[] | undefined;
  profitShares!: number[] | undefined;

  constructor(data?: IGetDashboardDataOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalProfit = _data['totalProfit'];
      this.newFeedbacks = _data['newFeedbacks'];
      this.newOrders = _data['newOrders'];
      this.newUsers = _data['newUsers'];
      if (Array.isArray(_data['salesSummary'])) {
        this.salesSummary = [] as any;
        for (let item of _data['salesSummary']) this.salesSummary!.push(SalesSummaryData.fromJS(item));
      }
      this.totalSales = _data['totalSales'];
      this.revenue = _data['revenue'];
      this.expenses = _data['expenses'];
      this.growth = _data['growth'];
      this.transactionPercent = _data['transactionPercent'];
      this.newVisitPercent = _data['newVisitPercent'];
      this.bouncePercent = _data['bouncePercent'];
      if (Array.isArray(_data['dailySales'])) {
        this.dailySales = [] as any;
        for (let item of _data['dailySales']) this.dailySales!.push(item);
      }
      if (Array.isArray(_data['profitShares'])) {
        this.profitShares = [] as any;
        for (let item of _data['profitShares']) this.profitShares!.push(item);
      }
    }
  }

  static fromJS(data: any): GetDashboardDataOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDashboardDataOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalProfit'] = this.totalProfit;
    data['newFeedbacks'] = this.newFeedbacks;
    data['newOrders'] = this.newOrders;
    data['newUsers'] = this.newUsers;
    if (Array.isArray(this.salesSummary)) {
      data['salesSummary'] = [];
      for (let item of this.salesSummary) data['salesSummary'].push(item.toJSON());
    }
    data['totalSales'] = this.totalSales;
    data['revenue'] = this.revenue;
    data['expenses'] = this.expenses;
    data['growth'] = this.growth;
    data['transactionPercent'] = this.transactionPercent;
    data['newVisitPercent'] = this.newVisitPercent;
    data['bouncePercent'] = this.bouncePercent;
    if (Array.isArray(this.dailySales)) {
      data['dailySales'] = [];
      for (let item of this.dailySales) data['dailySales'].push(item);
    }
    if (Array.isArray(this.profitShares)) {
      data['profitShares'] = [];
      for (let item of this.profitShares) data['profitShares'].push(item);
    }
    return data;
  }
}

export interface IGetDashboardDataOutput {
  totalProfit: number;
  newFeedbacks: number;
  newOrders: number;
  newUsers: number;
  salesSummary: SalesSummaryData[] | undefined;
  totalSales: number;
  revenue: number;
  expenses: number;
  growth: number;
  transactionPercent: number;
  newVisitPercent: number;
  bouncePercent: number;
  dailySales: number[] | undefined;
  profitShares: number[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
  totalProfit!: number;
  newFeedbacks!: number;
  newOrders!: number;
  newUsers!: number;

  constructor(data?: IGetTopStatsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalProfit = _data['totalProfit'];
      this.newFeedbacks = _data['newFeedbacks'];
      this.newOrders = _data['newOrders'];
      this.newUsers = _data['newUsers'];
    }
  }

  static fromJS(data: any): GetTopStatsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTopStatsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalProfit'] = this.totalProfit;
    data['newFeedbacks'] = this.newFeedbacks;
    data['newOrders'] = this.newOrders;
    data['newUsers'] = this.newUsers;
    return data;
  }
}

export interface IGetTopStatsOutput {
  totalProfit: number;
  newFeedbacks: number;
  newOrders: number;
  newUsers: number;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
  profitShares!: number[] | undefined;

  constructor(data?: IGetProfitShareOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['profitShares'])) {
        this.profitShares = [] as any;
        for (let item of _data['profitShares']) this.profitShares!.push(item);
      }
    }
  }

  static fromJS(data: any): GetProfitShareOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetProfitShareOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.profitShares)) {
      data['profitShares'] = [];
      for (let item of this.profitShares) data['profitShares'].push(item);
    }
    return data;
  }
}

export interface IGetProfitShareOutput {
  profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
  dailySales!: number[] | undefined;

  constructor(data?: IGetDailySalesOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['dailySales'])) {
        this.dailySales = [] as any;
        for (let item of _data['dailySales']) this.dailySales!.push(item);
      }
    }
  }

  static fromJS(data: any): GetDailySalesOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetDailySalesOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.dailySales)) {
      data['dailySales'] = [];
      for (let item of this.dailySales) data['dailySales'].push(item);
    }
    return data;
  }
}

export interface IGetDailySalesOutput {
  dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
  totalSales!: number;
  revenue!: number;
  expenses!: number;
  growth!: number;
  salesSummary!: SalesSummaryData[] | undefined;

  constructor(data?: IGetSalesSummaryOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalSales = _data['totalSales'];
      this.revenue = _data['revenue'];
      this.expenses = _data['expenses'];
      this.growth = _data['growth'];
      if (Array.isArray(_data['salesSummary'])) {
        this.salesSummary = [] as any;
        for (let item of _data['salesSummary']) this.salesSummary!.push(SalesSummaryData.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetSalesSummaryOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetSalesSummaryOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalSales'] = this.totalSales;
    data['revenue'] = this.revenue;
    data['expenses'] = this.expenses;
    data['growth'] = this.growth;
    if (Array.isArray(this.salesSummary)) {
      data['salesSummary'] = [];
      for (let item of this.salesSummary) data['salesSummary'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetSalesSummaryOutput {
  totalSales: number;
  revenue: number;
  expenses: number;
  growth: number;
  salesSummary: SalesSummaryData[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
  countryName!: string | undefined;
  sales!: number;
  change!: number[] | undefined;
  averagePrice!: number;
  totalPrice!: number;

  constructor(data?: IRegionalStatCountry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryName = _data['countryName'];
      this.sales = _data['sales'];
      if (Array.isArray(_data['change'])) {
        this.change = [] as any;
        for (let item of _data['change']) this.change!.push(item);
      }
      this.averagePrice = _data['averagePrice'];
      this.totalPrice = _data['totalPrice'];
    }
  }

  static fromJS(data: any): RegionalStatCountry {
    data = typeof data === 'object' ? data : {};
    let result = new RegionalStatCountry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['countryName'] = this.countryName;
    data['sales'] = this.sales;
    if (Array.isArray(this.change)) {
      data['change'] = [];
      for (let item of this.change) data['change'].push(item);
    }
    data['averagePrice'] = this.averagePrice;
    data['totalPrice'] = this.totalPrice;
    return data;
  }
}

export interface IRegionalStatCountry {
  countryName: string | undefined;
  sales: number;
  change: number[] | undefined;
  averagePrice: number;
  totalPrice: number;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
  stats!: RegionalStatCountry[] | undefined;

  constructor(data?: IGetRegionalStatsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['stats'])) {
        this.stats = [] as any;
        for (let item of _data['stats']) this.stats!.push(RegionalStatCountry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetRegionalStatsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRegionalStatsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.stats)) {
      data['stats'] = [];
      for (let item of this.stats) data['stats'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetRegionalStatsOutput {
  stats: RegionalStatCountry[] | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
  transactionPercent!: number;
  newVisitPercent!: number;
  bouncePercent!: number;

  constructor(data?: IGetGeneralStatsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transactionPercent = _data['transactionPercent'];
      this.newVisitPercent = _data['newVisitPercent'];
      this.bouncePercent = _data['bouncePercent'];
    }
  }

  static fromJS(data: any): GetGeneralStatsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetGeneralStatsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transactionPercent'] = this.transactionPercent;
    data['newVisitPercent'] = this.newVisitPercent;
    data['bouncePercent'] = this.bouncePercent;
    return data;
  }
}

export interface IGetGeneralStatsOutput {
  transactionPercent: number;
  newVisitPercent: number;
  bouncePercent: number;
}

export enum SubscriptionStartType {
  Free = 1,
  Trial = 2,
  Paid = 3,
}

export class RegisterTenantInput implements IRegisterTenantInput {
  tenancyName!: string;
  companyName!: string;
  mobileNo!: string | undefined;
  name!: string;
  adminEmailAddress!: string;
  adminPassword!: string | undefined;
  captchaResponse!: string | undefined;
  subscriptionStartType!: SubscriptionStartType;
  editionId!: number | undefined;
  address!: string | undefined;
  countryId!: number;
  cityId!: number;
  userAdminFirstName!: string;
  userAdminSurname!: string;

  constructor(data?: IRegisterTenantInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.companyName = _data['companyName'];
      this.mobileNo = _data['mobileNo'];
      this.name = _data['name'];
      this.adminEmailAddress = _data['adminEmailAddress'];
      this.adminPassword = _data['adminPassword'];
      this.captchaResponse = _data['captchaResponse'];
      this.subscriptionStartType = _data['subscriptionStartType'];
      this.editionId = _data['editionId'];
      this.address = _data['address'];
      this.countryId = _data['countryId'];
      this.cityId = _data['cityId'];
      this.userAdminFirstName = _data['userAdminFirstName'];
      this.userAdminSurname = _data['userAdminSurname'];
    }
  }

  static fromJS(data: any): RegisterTenantInput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterTenantInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['companyName'] = this.companyName;
    data['mobileNo'] = this.mobileNo;
    data['name'] = this.name;
    data['adminEmailAddress'] = this.adminEmailAddress;
    data['adminPassword'] = this.adminPassword;
    data['captchaResponse'] = this.captchaResponse;
    data['subscriptionStartType'] = this.subscriptionStartType;
    data['editionId'] = this.editionId;
    data['address'] = this.address;
    data['countryId'] = this.countryId;
    data['cityId'] = this.cityId;
    data['userAdminFirstName'] = this.userAdminFirstName;
    data['userAdminSurname'] = this.userAdminSurname;
    return data;
  }
}

export interface IRegisterTenantInput {
  tenancyName: string;
  companyName: string;
  mobileNo: string | undefined;
  name: string;
  adminEmailAddress: string;
  adminPassword: string | undefined;
  captchaResponse: string | undefined;
  subscriptionStartType: SubscriptionStartType;
  editionId: number | undefined;
  address: string | undefined;
  countryId: number;
  cityId: number;
  userAdminFirstName: string;
  userAdminSurname: string;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
  tenantId!: number;
  tenancyName!: string | undefined;
  name!: string | undefined;
  userName!: string | undefined;
  emailAddress!: string | undefined;
  isTenantActive!: boolean;
  isActive!: boolean;
  isEmailConfirmationRequired!: boolean;

  constructor(data?: IRegisterTenantOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.tenancyName = _data['tenancyName'];
      this.name = _data['name'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.isTenantActive = _data['isTenantActive'];
      this.isActive = _data['isActive'];
      this.isEmailConfirmationRequired = _data['isEmailConfirmationRequired'];
    }
  }

  static fromJS(data: any): RegisterTenantOutput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterTenantOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['tenancyName'] = this.tenancyName;
    data['name'] = this.name;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['isTenantActive'] = this.isTenantActive;
    data['isActive'] = this.isActive;
    data['isEmailConfirmationRequired'] = this.isEmailConfirmationRequired;
    return data;
  }
}

export interface IRegisterTenantOutput {
  tenantId: number;
  tenancyName: string | undefined;
  name: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  isTenantActive: boolean;
  isActive: boolean;
  isEmailConfirmationRequired: boolean;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
  parentName!: string | undefined;
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;
  defaultValue!: string | undefined;
  inputType!: IInputType;
  textHtmlColor!: string | undefined;

  constructor(data?: IFlatFeatureSelectDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentName = _data['parentName'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.defaultValue = _data['defaultValue'];
      this.inputType = _data['inputType'] ? IInputType.fromJS(_data['inputType']) : <any>undefined;
      this.textHtmlColor = _data['textHtmlColor'];
    }
  }

  static fromJS(data: any): FlatFeatureSelectDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatFeatureSelectDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['parentName'] = this.parentName;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['defaultValue'] = this.defaultValue;
    data['inputType'] = this.inputType ? this.inputType.toJSON() : <any>undefined;
    data['textHtmlColor'] = this.textHtmlColor;
    return data;
  }
}

export interface IFlatFeatureSelectDto {
  parentName: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  defaultValue: string | undefined;
  inputType: IInputType;
  textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
  edition!: EditionSelectDto;
  featureValues!: NameValueDto[] | undefined;

  constructor(data?: IEditionWithFeaturesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.edition = _data['edition'] ? EditionSelectDto.fromJS(_data['edition']) : <any>undefined;
      if (Array.isArray(_data['featureValues'])) {
        this.featureValues = [] as any;
        for (let item of _data['featureValues']) this.featureValues!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EditionWithFeaturesDto {
    data = typeof data === 'object' ? data : {};
    let result = new EditionWithFeaturesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['edition'] = this.edition ? this.edition.toJSON() : <any>undefined;
    if (Array.isArray(this.featureValues)) {
      data['featureValues'] = [];
      for (let item of this.featureValues) data['featureValues'].push(item.toJSON());
    }
    return data;
  }
}

export interface IEditionWithFeaturesDto {
  edition: EditionSelectDto;
  featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
  allFeatures!: FlatFeatureSelectDto[] | undefined;
  editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

  constructor(data?: IEditionsSelectOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['allFeatures'])) {
        this.allFeatures = [] as any;
        for (let item of _data['allFeatures']) this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
      }
      if (Array.isArray(_data['editionsWithFeatures'])) {
        this.editionsWithFeatures = [] as any;
        for (let item of _data['editionsWithFeatures']) this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EditionsSelectOutput {
    data = typeof data === 'object' ? data : {};
    let result = new EditionsSelectOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.allFeatures)) {
      data['allFeatures'] = [];
      for (let item of this.allFeatures) data['allFeatures'].push(item.toJSON());
    }
    if (Array.isArray(this.editionsWithFeatures)) {
      data['editionsWithFeatures'] = [];
      for (let item of this.editionsWithFeatures) data['editionsWithFeatures'].push(item.toJSON());
    }
    return data;
  }
}

export interface IEditionsSelectOutput {
  allFeatures: FlatFeatureSelectDto[] | undefined;
  editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class TermAndConditionDto implements ITermAndConditionDto {
  title!: string | undefined;
  content!: string | undefined;
  version!: number;
  editionId!: number | undefined;
  editionName!: string | undefined;
  isActive!: boolean;
  id!: number;

  constructor(data?: ITermAndConditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      this.version = _data['version'];
      this.editionId = _data['editionId'];
      this.editionName = _data['editionName'];
      this.isActive = _data['isActive'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TermAndConditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new TermAndConditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    data['version'] = this.version;
    data['editionId'] = this.editionId;
    data['editionName'] = this.editionName;
    data['isActive'] = this.isActive;
    data['id'] = this.id;
    return data;
  }
}

export interface ITermAndConditionDto {
  title: string | undefined;
  content: string | undefined;
  version: number;
  editionId: number | undefined;
  editionName: string | undefined;
  isActive: boolean;
  id: number;
}

export class GetTermAndConditionForViewDto implements IGetTermAndConditionForViewDto {
  termAndCondition!: TermAndConditionDto;

  constructor(data?: IGetTermAndConditionForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.termAndCondition = _data['termAndCondition'] ? TermAndConditionDto.fromJS(_data['termAndCondition']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTermAndConditionForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTermAndConditionForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['termAndCondition'] = this.termAndCondition ? this.termAndCondition.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTermAndConditionForViewDto {
  termAndCondition: TermAndConditionDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
  allowSelfRegistration!: boolean;
  isNewRegisteredUserActiveByDefault!: boolean;
  isEmailConfirmationRequiredForLogin!: boolean;
  useCaptchaOnRegistration!: boolean;
  useCaptchaOnLogin!: boolean;
  isCookieConsentEnabled!: boolean;
  isQuickThemeSelectEnabled!: boolean;
  allowUsingGravatarProfilePicture!: boolean;
  sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

  constructor(data?: ITenantUserManagementSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.allowSelfRegistration = _data['allowSelfRegistration'];
      this.isNewRegisteredUserActiveByDefault = _data['isNewRegisteredUserActiveByDefault'];
      this.isEmailConfirmationRequiredForLogin = _data['isEmailConfirmationRequiredForLogin'];
      this.useCaptchaOnRegistration = _data['useCaptchaOnRegistration'];
      this.useCaptchaOnLogin = _data['useCaptchaOnLogin'];
      this.isCookieConsentEnabled = _data['isCookieConsentEnabled'];
      this.isQuickThemeSelectEnabled = _data['isQuickThemeSelectEnabled'];
      this.allowUsingGravatarProfilePicture = _data['allowUsingGravatarProfilePicture'];
      this.sessionTimeOutSettings = _data['sessionTimeOutSettings']
        ? SessionTimeOutSettingsEditDto.fromJS(_data['sessionTimeOutSettings'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): TenantUserManagementSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantUserManagementSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['allowSelfRegistration'] = this.allowSelfRegistration;
    data['isNewRegisteredUserActiveByDefault'] = this.isNewRegisteredUserActiveByDefault;
    data['isEmailConfirmationRequiredForLogin'] = this.isEmailConfirmationRequiredForLogin;
    data['useCaptchaOnRegistration'] = this.useCaptchaOnRegistration;
    data['useCaptchaOnLogin'] = this.useCaptchaOnLogin;
    data['isCookieConsentEnabled'] = this.isCookieConsentEnabled;
    data['isQuickThemeSelectEnabled'] = this.isQuickThemeSelectEnabled;
    data['allowUsingGravatarProfilePicture'] = this.allowUsingGravatarProfilePicture;
    data['sessionTimeOutSettings'] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITenantUserManagementSettingsEditDto {
  allowSelfRegistration: boolean;
  isNewRegisteredUserActiveByDefault: boolean;
  isEmailConfirmationRequiredForLogin: boolean;
  useCaptchaOnRegistration: boolean;
  useCaptchaOnLogin: boolean;
  isCookieConsentEnabled: boolean;
  isQuickThemeSelectEnabled: boolean;
  allowUsingGravatarProfilePicture: boolean;
  sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
  useHostDefaultEmailSettings!: boolean;
  defaultFromAddress!: string | undefined;
  defaultFromDisplayName!: string | undefined;
  smtpHost!: string | undefined;
  smtpPort!: number;
  smtpUserName!: string | undefined;
  smtpPassword!: string | undefined;
  smtpDomain!: string | undefined;
  smtpEnableSsl!: boolean;
  smtpUseDefaultCredentials!: boolean;

  constructor(data?: ITenantEmailSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.useHostDefaultEmailSettings = _data['useHostDefaultEmailSettings'];
      this.defaultFromAddress = _data['defaultFromAddress'];
      this.defaultFromDisplayName = _data['defaultFromDisplayName'];
      this.smtpHost = _data['smtpHost'];
      this.smtpPort = _data['smtpPort'];
      this.smtpUserName = _data['smtpUserName'];
      this.smtpPassword = _data['smtpPassword'];
      this.smtpDomain = _data['smtpDomain'];
      this.smtpEnableSsl = _data['smtpEnableSsl'];
      this.smtpUseDefaultCredentials = _data['smtpUseDefaultCredentials'];
    }
  }

  static fromJS(data: any): TenantEmailSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantEmailSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['useHostDefaultEmailSettings'] = this.useHostDefaultEmailSettings;
    data['defaultFromAddress'] = this.defaultFromAddress;
    data['defaultFromDisplayName'] = this.defaultFromDisplayName;
    data['smtpHost'] = this.smtpHost;
    data['smtpPort'] = this.smtpPort;
    data['smtpUserName'] = this.smtpUserName;
    data['smtpPassword'] = this.smtpPassword;
    data['smtpDomain'] = this.smtpDomain;
    data['smtpEnableSsl'] = this.smtpEnableSsl;
    data['smtpUseDefaultCredentials'] = this.smtpUseDefaultCredentials;
    return data;
  }
}

export interface ITenantEmailSettingsEditDto {
  useHostDefaultEmailSettings: boolean;
  defaultFromAddress: string | undefined;
  defaultFromDisplayName: string | undefined;
  smtpHost: string | undefined;
  smtpPort: number;
  smtpUserName: string | undefined;
  smtpPassword: string | undefined;
  smtpDomain: string | undefined;
  smtpEnableSsl: boolean;
  smtpUseDefaultCredentials: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
  isModuleEnabled!: boolean;
  isEnabled!: boolean;
  domain!: string | undefined;
  userName!: string | undefined;
  password!: string | undefined;

  constructor(data?: ILdapSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isModuleEnabled = _data['isModuleEnabled'];
      this.isEnabled = _data['isEnabled'];
      this.domain = _data['domain'];
      this.userName = _data['userName'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LdapSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new LdapSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isModuleEnabled'] = this.isModuleEnabled;
    data['isEnabled'] = this.isEnabled;
    data['domain'] = this.domain;
    data['userName'] = this.userName;
    data['password'] = this.password;
    return data;
  }
}

export interface ILdapSettingsEditDto {
  isModuleEnabled: boolean;
  isEnabled: boolean;
  domain: string | undefined;
  userName: string | undefined;
  password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
  legalName!: string | undefined;
  address!: string | undefined;
  taxVatNo!: string | undefined;

  constructor(data?: ITenantBillingSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.legalName = _data['legalName'];
      this.address = _data['address'];
      this.taxVatNo = _data['taxVatNo'];
    }
  }

  static fromJS(data: any): TenantBillingSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantBillingSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['legalName'] = this.legalName;
    data['address'] = this.address;
    data['taxVatNo'] = this.taxVatNo;
    return data;
  }
}

export interface ITenantBillingSettingsEditDto {
  legalName: string | undefined;
  address: string | undefined;
  taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
  isQuickThemeSelectEnabled!: boolean;

  constructor(data?: ITenantOtherSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isQuickThemeSelectEnabled = _data['isQuickThemeSelectEnabled'];
    }
  }

  static fromJS(data: any): TenantOtherSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantOtherSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isQuickThemeSelectEnabled'] = this.isQuickThemeSelectEnabled;
    return data;
  }
}

export interface ITenantOtherSettingsEditDto {
  isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
  general!: GeneralSettingsEditDto;
  userManagement!: TenantUserManagementSettingsEditDto;
  email!: TenantEmailSettingsEditDto;
  ldap!: LdapSettingsEditDto;
  security!: SecuritySettingsEditDto;
  billing!: TenantBillingSettingsEditDto;
  otherSettings!: TenantOtherSettingsEditDto;
  externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

  constructor(data?: ITenantSettingsEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.userManagement = new TenantUserManagementSettingsEditDto();
      this.security = new SecuritySettingsEditDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.general = _data['general'] ? GeneralSettingsEditDto.fromJS(_data['general']) : <any>undefined;
      this.userManagement = _data['userManagement']
        ? TenantUserManagementSettingsEditDto.fromJS(_data['userManagement'])
        : new TenantUserManagementSettingsEditDto();
      this.email = _data['email'] ? TenantEmailSettingsEditDto.fromJS(_data['email']) : <any>undefined;
      this.ldap = _data['ldap'] ? LdapSettingsEditDto.fromJS(_data['ldap']) : <any>undefined;
      this.security = _data['security'] ? SecuritySettingsEditDto.fromJS(_data['security']) : new SecuritySettingsEditDto();
      this.billing = _data['billing'] ? TenantBillingSettingsEditDto.fromJS(_data['billing']) : <any>undefined;
      this.otherSettings = _data['otherSettings'] ? TenantOtherSettingsEditDto.fromJS(_data['otherSettings']) : <any>undefined;
      this.externalLoginProviderSettings = _data['externalLoginProviderSettings']
        ? ExternalLoginProviderSettingsEditDto.fromJS(_data['externalLoginProviderSettings'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): TenantSettingsEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantSettingsEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['general'] = this.general ? this.general.toJSON() : <any>undefined;
    data['userManagement'] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
    data['email'] = this.email ? this.email.toJSON() : <any>undefined;
    data['ldap'] = this.ldap ? this.ldap.toJSON() : <any>undefined;
    data['security'] = this.security ? this.security.toJSON() : <any>undefined;
    data['billing'] = this.billing ? this.billing.toJSON() : <any>undefined;
    data['otherSettings'] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
    data['externalLoginProviderSettings'] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITenantSettingsEditDto {
  general: GeneralSettingsEditDto;
  userManagement: TenantUserManagementSettingsEditDto;
  email: TenantEmailSettingsEditDto;
  ldap: LdapSettingsEditDto;
  security: SecuritySettingsEditDto;
  billing: TenantBillingSettingsEditDto;
  otherSettings: TenantOtherSettingsEditDto;
  externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class PagedResultDtoOfGetTermAndConditionForViewDto implements IPagedResultDtoOfGetTermAndConditionForViewDto {
  totalCount!: number;
  items!: GetTermAndConditionForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTermAndConditionForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTermAndConditionForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTermAndConditionForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTermAndConditionForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTermAndConditionForViewDto {
  totalCount: number;
  items: GetTermAndConditionForViewDto[] | undefined;
}

export class CreateOrEditTermAndConditionDto implements ICreateOrEditTermAndConditionDto {
  title!: string;
  content!: string;
  version!: number;
  editionId!: number | undefined;
  isActive!: boolean;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTermAndConditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      this.version = _data['version'];
      this.editionId = _data['editionId'];
      this.isActive = _data['isActive'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTermAndConditionDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTermAndConditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    data['version'] = this.version;
    data['editionId'] = this.editionId;
    data['isActive'] = this.isActive;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTermAndConditionDto {
  title: string;
  content: string;
  version: number;
  editionId: number | undefined;
  isActive: boolean;
  id: number | undefined;
}

export class GetTermAndConditionForEditOutput implements IGetTermAndConditionForEditOutput {
  termAndCondition!: CreateOrEditTermAndConditionDto;

  constructor(data?: IGetTermAndConditionForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.termAndCondition = _data['termAndCondition'] ? CreateOrEditTermAndConditionDto.fromJS(_data['termAndCondition']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTermAndConditionForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTermAndConditionForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['termAndCondition'] = this.termAndCondition ? this.termAndCondition.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTermAndConditionForEditOutput {
  termAndCondition: CreateOrEditTermAndConditionDto;
}

export class TermAndConditionTranslationDto implements ITermAndConditionTranslationDto {
  language!: string | undefined;
  coreId!: number | undefined;
  id!: number;

  constructor(data?: ITermAndConditionTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TermAndConditionTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new TermAndConditionTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITermAndConditionTranslationDto {
  language: string | undefined;
  coreId: number | undefined;
  id: number;
}

export class GetTermAndConditionTranslationForViewDto implements IGetTermAndConditionTranslationForViewDto {
  termAndConditionTranslation!: TermAndConditionTranslationDto;
  termAndConditionTitle!: string | undefined;

  constructor(data?: IGetTermAndConditionTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.termAndConditionTranslation = _data['termAndConditionTranslation']
        ? TermAndConditionTranslationDto.fromJS(_data['termAndConditionTranslation'])
        : <any>undefined;
      this.termAndConditionTitle = _data['termAndConditionTitle'];
    }
  }

  static fromJS(data: any): GetTermAndConditionTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTermAndConditionTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['termAndConditionTranslation'] = this.termAndConditionTranslation ? this.termAndConditionTranslation.toJSON() : <any>undefined;
    data['termAndConditionTitle'] = this.termAndConditionTitle;
    return data;
  }
}

export interface IGetTermAndConditionTranslationForViewDto {
  termAndConditionTranslation: TermAndConditionTranslationDto;
  termAndConditionTitle: string | undefined;
}

export class PagedResultDtoOfGetTermAndConditionTranslationForViewDto implements IPagedResultDtoOfGetTermAndConditionTranslationForViewDto {
  totalCount!: number;
  items!: GetTermAndConditionTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTermAndConditionTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTermAndConditionTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTermAndConditionTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTermAndConditionTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTermAndConditionTranslationForViewDto {
  totalCount: number;
  items: GetTermAndConditionTranslationForViewDto[] | undefined;
}

export class CreateOrEditTermAndConditionTranslationDto implements ICreateOrEditTermAndConditionTranslationDto {
  content!: string;
  language!: string;
  coreId!: number | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTermAndConditionTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTermAndConditionTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTermAndConditionTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTermAndConditionTranslationDto {
  content: string;
  language: string;
  coreId: number | undefined;
  id: number | undefined;
}

export class GetTermAndConditionTranslationForEditOutput implements IGetTermAndConditionTranslationForEditOutput {
  termAndConditionTranslation!: CreateOrEditTermAndConditionTranslationDto;
  termAndConditionTitle!: string | undefined;

  constructor(data?: IGetTermAndConditionTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.termAndConditionTranslation = _data['termAndConditionTranslation']
        ? CreateOrEditTermAndConditionTranslationDto.fromJS(_data['termAndConditionTranslation'])
        : <any>undefined;
      this.termAndConditionTitle = _data['termAndConditionTitle'];
    }
  }

  static fromJS(data: any): GetTermAndConditionTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTermAndConditionTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['termAndConditionTranslation'] = this.termAndConditionTranslation ? this.termAndConditionTranslation.toJSON() : <any>undefined;
    data['termAndConditionTitle'] = this.termAndConditionTitle;
    return data;
  }
}

export interface IGetTermAndConditionTranslationForEditOutput {
  termAndConditionTranslation: CreateOrEditTermAndConditionTranslationDto;
  termAndConditionTitle: string | undefined;
}

export class TermAndConditionTranslationTermAndConditionLookupTableDto implements ITermAndConditionTranslationTermAndConditionLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITermAndConditionTranslationTermAndConditionLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TermAndConditionTranslationTermAndConditionLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TermAndConditionTranslationTermAndConditionLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITermAndConditionTranslationTermAndConditionLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export enum SettingScopes {
  Application = 1,
  Tenant = 2,
  User = 4,
  All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
  items!: NameValueDto[] | undefined;

  constructor(data?: IListResultDtoOfNameValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(NameValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfNameValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfNameValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfNameValueDto {
  items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress!: string;
  password!: string;
  twoFactorVerificationCode!: string | undefined;
  rememberClient!: boolean;
  twoFactorRememberClientToken!: string | undefined;
  singleSignIn!: boolean | undefined;
  returnUrl!: string | undefined;
  captchaResponse!: string | undefined;
  usePhoneNumberForSignIn!: boolean | undefined;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data['userNameOrEmailAddress'];
      this.password = _data['password'];
      this.twoFactorVerificationCode = _data['twoFactorVerificationCode'];
      this.rememberClient = _data['rememberClient'];
      this.twoFactorRememberClientToken = _data['twoFactorRememberClientToken'];
      this.singleSignIn = _data['singleSignIn'];
      this.returnUrl = _data['returnUrl'];
      this.captchaResponse = _data['captchaResponse'];
      this.usePhoneNumberForSignIn = _data['usePhoneNumberForSignIn'];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userNameOrEmailAddress'] = this.userNameOrEmailAddress;
    data['password'] = this.password;
    data['twoFactorVerificationCode'] = this.twoFactorVerificationCode;
    data['rememberClient'] = this.rememberClient;
    data['twoFactorRememberClientToken'] = this.twoFactorRememberClientToken;
    data['singleSignIn'] = this.singleSignIn;
    data['returnUrl'] = this.returnUrl;
    data['captchaResponse'] = this.captchaResponse;
    data['usePhoneNumberForSignIn'] = this.usePhoneNumberForSignIn;
    return data;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  twoFactorVerificationCode: string | undefined;
  rememberClient: boolean;
  twoFactorRememberClientToken: string | undefined;
  singleSignIn: boolean | undefined;
  returnUrl: string | undefined;
  captchaResponse: string | undefined;
  usePhoneNumberForSignIn: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken!: string | undefined;
  encryptedAccessToken!: string | undefined;
  expireInSeconds!: number;
  shouldResetPassword!: boolean;
  passwordResetCode!: string | undefined;
  userId!: number;
  requiresTwoFactorVerification!: boolean;
  twoFactorAuthProviders!: string[] | undefined;
  twoFactorRememberClientToken!: string | undefined;
  returnUrl!: string | undefined;
  refreshToken!: string | undefined;
  refreshTokenExpireInSeconds!: number;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
      this.shouldResetPassword = _data['shouldResetPassword'];
      this.passwordResetCode = _data['passwordResetCode'];
      this.userId = _data['userId'];
      this.requiresTwoFactorVerification = _data['requiresTwoFactorVerification'];
      if (Array.isArray(_data['twoFactorAuthProviders'])) {
        this.twoFactorAuthProviders = [] as any;
        for (let item of _data['twoFactorAuthProviders']) this.twoFactorAuthProviders!.push(item);
      }
      this.twoFactorRememberClientToken = _data['twoFactorRememberClientToken'];
      this.returnUrl = _data['returnUrl'];
      this.refreshToken = _data['refreshToken'];
      this.refreshTokenExpireInSeconds = _data['refreshTokenExpireInSeconds'];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    data['shouldResetPassword'] = this.shouldResetPassword;
    data['passwordResetCode'] = this.passwordResetCode;
    data['userId'] = this.userId;
    data['requiresTwoFactorVerification'] = this.requiresTwoFactorVerification;
    if (Array.isArray(this.twoFactorAuthProviders)) {
      data['twoFactorAuthProviders'] = [];
      for (let item of this.twoFactorAuthProviders) data['twoFactorAuthProviders'].push(item);
    }
    data['twoFactorRememberClientToken'] = this.twoFactorRememberClientToken;
    data['returnUrl'] = this.returnUrl;
    data['refreshToken'] = this.refreshToken;
    data['refreshTokenExpireInSeconds'] = this.refreshTokenExpireInSeconds;
    return data;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  shouldResetPassword: boolean;
  passwordResetCode: string | undefined;
  userId: number;
  requiresTwoFactorVerification: boolean;
  twoFactorAuthProviders: string[] | undefined;
  twoFactorRememberClientToken: string | undefined;
  returnUrl: string | undefined;
  refreshToken: string | undefined;
  refreshTokenExpireInSeconds: number;
}

export class AuthenticateMobileModel implements IAuthenticateMobileModel {
  username!: string | undefined;
  otp!: string | undefined;
  language!: string | undefined;
  deviceToken!: string | undefined;
  deviceId!: string | undefined;
  deviceExpireDate!: moment.Moment | undefined;

  constructor(data?: IAuthenticateMobileModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.otp = _data['otp'];
      this.language = _data['language'];
      this.deviceToken = _data['deviceToken'];
      this.deviceId = _data['deviceId'];
      this.deviceExpireDate = _data['deviceExpireDate'] ? moment(_data['deviceExpireDate'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): AuthenticateMobileModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateMobileModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['otp'] = this.otp;
    data['language'] = this.language;
    data['deviceToken'] = this.deviceToken;
    data['deviceId'] = this.deviceId;
    data['deviceExpireDate'] = this.deviceExpireDate ? this.deviceExpireDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAuthenticateMobileModel {
  username: string | undefined;
  otp: string | undefined;
  language: string | undefined;
  deviceToken: string | undefined;
  deviceId: string | undefined;
  deviceExpireDate: moment.Moment | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
  accessToken!: string | undefined;
  encryptedAccessToken!: string | undefined;
  expireInSeconds!: number;

  constructor(data?: IRefreshTokenResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
    }
  }

  static fromJS(data: any): RefreshTokenResult {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    return data;
  }
}

export interface IRefreshTokenResult {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
  userId!: number;
  provider!: string;

  constructor(data?: ISendTwoFactorAuthCodeModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.provider = _data['provider'];
    }
  }

  static fromJS(data: any): SendTwoFactorAuthCodeModel {
    data = typeof data === 'object' ? data : {};
    let result = new SendTwoFactorAuthCodeModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['provider'] = this.provider;
    return data;
  }
}

export interface ISendTwoFactorAuthCodeModel {
  userId: number;
  provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
  accessToken!: string | undefined;
  encryptedAccessToken!: string | undefined;
  expireInSeconds!: number;

  constructor(data?: IImpersonatedAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
    }
  }

  static fromJS(data: any): ImpersonatedAuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new ImpersonatedAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    return data;
  }
}

export interface IImpersonatedAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
  accessToken!: string | undefined;
  encryptedAccessToken!: string | undefined;
  expireInSeconds!: number;

  constructor(data?: ISwitchedAccountAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
    }
  }

  static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new SwitchedAccountAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    return data;
  }
}

export interface ISwitchedAccountAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
  name!: string | undefined;
  clientId!: string | undefined;
  additionalParams!: { [key: string]: string } | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.clientId = _data['clientId'];
      if (_data['additionalParams']) {
        this.additionalParams = {} as any;
        for (let key in _data['additionalParams']) {
          if (_data['additionalParams'].hasOwnProperty(key)) this.additionalParams![key] = _data['additionalParams'][key];
        }
      }
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['clientId'] = this.clientId;
    if (this.additionalParams) {
      data['additionalParams'] = {};
      for (let key in this.additionalParams) {
        if (this.additionalParams.hasOwnProperty(key)) data['additionalParams'][key] = this.additionalParams[key];
      }
    }
    return data;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
  additionalParams: { [key: string]: string } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider!: string;
  providerKey!: string;
  providerAccessCode!: string;
  returnUrl!: string | undefined;
  singleSignIn!: boolean | undefined;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data['authProvider'];
      this.providerKey = _data['providerKey'];
      this.providerAccessCode = _data['providerAccessCode'];
      this.returnUrl = _data['returnUrl'];
      this.singleSignIn = _data['singleSignIn'];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['authProvider'] = this.authProvider;
    data['providerKey'] = this.providerKey;
    data['providerAccessCode'] = this.providerAccessCode;
    data['returnUrl'] = this.returnUrl;
    data['singleSignIn'] = this.singleSignIn;
    return data;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
  returnUrl: string | undefined;
  singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
  accessToken!: string | undefined;
  encryptedAccessToken!: string | undefined;
  expireInSeconds!: number;
  waitingForActivation!: boolean;
  returnUrl!: string | undefined;
  refreshToken!: string | undefined;
  refreshTokenExpireInSeconds!: number;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.encryptedAccessToken = _data['encryptedAccessToken'];
      this.expireInSeconds = _data['expireInSeconds'];
      this.waitingForActivation = _data['waitingForActivation'];
      this.returnUrl = _data['returnUrl'];
      this.refreshToken = _data['refreshToken'];
      this.refreshTokenExpireInSeconds = _data['refreshTokenExpireInSeconds'];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['encryptedAccessToken'] = this.encryptedAccessToken;
    data['expireInSeconds'] = this.expireInSeconds;
    data['waitingForActivation'] = this.waitingForActivation;
    data['returnUrl'] = this.returnUrl;
    data['refreshToken'] = this.refreshToken;
    data['refreshTokenExpireInSeconds'] = this.refreshTokenExpireInSeconds;
    return data;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;
  returnUrl: string | undefined;
  refreshToken: string | undefined;
  refreshTokenExpireInSeconds: number;
}

export class TrackingListDto implements ITrackingListDto {
  name!: string | undefined;
  status!: ShippingRequestTripStatus;
  readonly statusTitle!: string | undefined;
  driver!: string | undefined;
  assignedDriverUserId!: number | undefined;
  profilePictureUrl!: string | undefined;
  driverImageProfile!: string | undefined;
  origin!: string | undefined;
  destination!: string | undefined;
  truckType!: string | undefined;
  goodsCategory!: string | undefined;
  routeTypeId!: ShippingRequestRouteType;
  readonly routeType!: string | undefined;
  reason!: string | undefined;

  constructor(data?: ITrackingListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.status = _data['status'];
      (<any>this).statusTitle = _data['statusTitle'];
      this.driver = _data['driver'];
      this.assignedDriverUserId = _data['assignedDriverUserId'];
      this.profilePictureUrl = _data['profilePictureUrl'];
      this.driverImageProfile = _data['driverImageProfile'];
      this.origin = _data['origin'];
      this.destination = _data['destination'];
      this.truckType = _data['truckType'];
      this.goodsCategory = _data['goodsCategory'];
      this.routeTypeId = _data['routeTypeId'];
      (<any>this).routeType = _data['routeType'];
      this.reason = _data['reason'];
    }
  }

  static fromJS(data: any): TrackingListDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrackingListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['status'] = this.status;
    data['statusTitle'] = this.statusTitle;
    data['driver'] = this.driver;
    data['assignedDriverUserId'] = this.assignedDriverUserId;
    data['profilePictureUrl'] = this.profilePictureUrl;
    data['driverImageProfile'] = this.driverImageProfile;
    data['origin'] = this.origin;
    data['destination'] = this.destination;
    data['truckType'] = this.truckType;
    data['goodsCategory'] = this.goodsCategory;
    data['routeTypeId'] = this.routeTypeId;
    data['routeType'] = this.routeType;
    data['reason'] = this.reason;
    return data;
  }
}

export interface ITrackingListDto {
  name: string | undefined;
  status: ShippingRequestTripStatus;
  statusTitle: string | undefined;
  driver: string | undefined;
  assignedDriverUserId: number | undefined;
  profilePictureUrl: string | undefined;
  driverImageProfile: string | undefined;
  origin: string | undefined;
  destination: string | undefined;
  truckType: string | undefined;
  goodsCategory: string | undefined;
  routeTypeId: ShippingRequestRouteType;
  routeType: string | undefined;
  reason: string | undefined;
}

export class PagedResultDtoOfTrackingListDto implements IPagedResultDtoOfTrackingListDto {
  totalCount!: number;
  items!: TrackingListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTrackingListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TrackingListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTrackingListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTrackingListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfTrackingListDto {
  totalCount: number;
  items: TrackingListDto[] | undefined;
}

export class TrailerDto implements ITrailerDto {
  trailerCode!: string | undefined;
  plateNumber!: string | undefined;
  model!: string | undefined;
  year!: string | undefined;
  width!: number;
  height!: number;
  length!: number;
  isLiftgate!: boolean;
  isReefer!: boolean;
  isVented!: boolean;
  isRollDoor!: boolean;
  trailerStatusId!: number;
  trailerTypeId!: number;
  payloadMaxWeightId!: number;
  hookedTruckId!: number | undefined;
  id!: number;

  constructor(data?: ITrailerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerCode = _data['trailerCode'];
      this.plateNumber = _data['plateNumber'];
      this.model = _data['model'];
      this.year = _data['year'];
      this.width = _data['width'];
      this.height = _data['height'];
      this.length = _data['length'];
      this.isLiftgate = _data['isLiftgate'];
      this.isReefer = _data['isReefer'];
      this.isVented = _data['isVented'];
      this.isRollDoor = _data['isRollDoor'];
      this.trailerStatusId = _data['trailerStatusId'];
      this.trailerTypeId = _data['trailerTypeId'];
      this.payloadMaxWeightId = _data['payloadMaxWeightId'];
      this.hookedTruckId = _data['hookedTruckId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TrailerDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerCode'] = this.trailerCode;
    data['plateNumber'] = this.plateNumber;
    data['model'] = this.model;
    data['year'] = this.year;
    data['width'] = this.width;
    data['height'] = this.height;
    data['length'] = this.length;
    data['isLiftgate'] = this.isLiftgate;
    data['isReefer'] = this.isReefer;
    data['isVented'] = this.isVented;
    data['isRollDoor'] = this.isRollDoor;
    data['trailerStatusId'] = this.trailerStatusId;
    data['trailerTypeId'] = this.trailerTypeId;
    data['payloadMaxWeightId'] = this.payloadMaxWeightId;
    data['hookedTruckId'] = this.hookedTruckId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITrailerDto {
  trailerCode: string | undefined;
  plateNumber: string | undefined;
  model: string | undefined;
  year: string | undefined;
  width: number;
  height: number;
  length: number;
  isLiftgate: boolean;
  isReefer: boolean;
  isVented: boolean;
  isRollDoor: boolean;
  trailerStatusId: number;
  trailerTypeId: number;
  payloadMaxWeightId: number;
  hookedTruckId: number | undefined;
  id: number;
}

export class GetTrailerForViewDto implements IGetTrailerForViewDto {
  trailer!: TrailerDto;
  trailerStatusDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  payloadMaxWeightDisplayName!: string | undefined;
  truckPlateNumber!: string | undefined;

  constructor(data?: IGetTrailerForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailer = _data['trailer'] ? TrailerDto.fromJS(_data['trailer']) : <any>undefined;
      this.trailerStatusDisplayName = _data['trailerStatusDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.payloadMaxWeightDisplayName = _data['payloadMaxWeightDisplayName'];
      this.truckPlateNumber = _data['truckPlateNumber'];
    }
  }

  static fromJS(data: any): GetTrailerForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailer'] = this.trailer ? this.trailer.toJSON() : <any>undefined;
    data['trailerStatusDisplayName'] = this.trailerStatusDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['payloadMaxWeightDisplayName'] = this.payloadMaxWeightDisplayName;
    data['truckPlateNumber'] = this.truckPlateNumber;
    return data;
  }
}

export interface IGetTrailerForViewDto {
  trailer: TrailerDto;
  trailerStatusDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  payloadMaxWeightDisplayName: string | undefined;
  truckPlateNumber: string | undefined;
}

export class PagedResultDtoOfGetTrailerForViewDto implements IPagedResultDtoOfGetTrailerForViewDto {
  totalCount!: number;
  items!: GetTrailerForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTrailerForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTrailerForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTrailerForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTrailerForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTrailerForViewDto {
  totalCount: number;
  items: GetTrailerForViewDto[] | undefined;
}

export class CreateOrEditTrailerDto implements ICreateOrEditTrailerDto {
  trailerCode!: string;
  plateNumber!: string;
  model!: string;
  year!: string;
  width!: number;
  height!: number;
  length!: number;
  isLiftgate!: boolean;
  isReefer!: boolean;
  isVented!: boolean;
  isRollDoor!: boolean;
  trailerStatusId!: number;
  trailerTypeId!: number;
  payloadMaxWeightId!: number;
  hookedTruckId!: number | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTrailerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerCode = _data['trailerCode'];
      this.plateNumber = _data['plateNumber'];
      this.model = _data['model'];
      this.year = _data['year'];
      this.width = _data['width'];
      this.height = _data['height'];
      this.length = _data['length'];
      this.isLiftgate = _data['isLiftgate'];
      this.isReefer = _data['isReefer'];
      this.isVented = _data['isVented'];
      this.isRollDoor = _data['isRollDoor'];
      this.trailerStatusId = _data['trailerStatusId'];
      this.trailerTypeId = _data['trailerTypeId'];
      this.payloadMaxWeightId = _data['payloadMaxWeightId'];
      this.hookedTruckId = _data['hookedTruckId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTrailerDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTrailerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerCode'] = this.trailerCode;
    data['plateNumber'] = this.plateNumber;
    data['model'] = this.model;
    data['year'] = this.year;
    data['width'] = this.width;
    data['height'] = this.height;
    data['length'] = this.length;
    data['isLiftgate'] = this.isLiftgate;
    data['isReefer'] = this.isReefer;
    data['isVented'] = this.isVented;
    data['isRollDoor'] = this.isRollDoor;
    data['trailerStatusId'] = this.trailerStatusId;
    data['trailerTypeId'] = this.trailerTypeId;
    data['payloadMaxWeightId'] = this.payloadMaxWeightId;
    data['hookedTruckId'] = this.hookedTruckId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTrailerDto {
  trailerCode: string;
  plateNumber: string;
  model: string;
  year: string;
  width: number;
  height: number;
  length: number;
  isLiftgate: boolean;
  isReefer: boolean;
  isVented: boolean;
  isRollDoor: boolean;
  trailerStatusId: number;
  trailerTypeId: number;
  payloadMaxWeightId: number;
  hookedTruckId: number | undefined;
  id: number | undefined;
}

export class GetTrailerForEditOutput implements IGetTrailerForEditOutput {
  trailer!: CreateOrEditTrailerDto;
  trailerStatusDisplayName!: string | undefined;
  trailerTypeDisplayName!: string | undefined;
  payloadMaxWeightDisplayName!: string | undefined;
  truckPlateNumber!: string | undefined;

  constructor(data?: IGetTrailerForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailer = _data['trailer'] ? CreateOrEditTrailerDto.fromJS(_data['trailer']) : <any>undefined;
      this.trailerStatusDisplayName = _data['trailerStatusDisplayName'];
      this.trailerTypeDisplayName = _data['trailerTypeDisplayName'];
      this.payloadMaxWeightDisplayName = _data['payloadMaxWeightDisplayName'];
      this.truckPlateNumber = _data['truckPlateNumber'];
    }
  }

  static fromJS(data: any): GetTrailerForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailer'] = this.trailer ? this.trailer.toJSON() : <any>undefined;
    data['trailerStatusDisplayName'] = this.trailerStatusDisplayName;
    data['trailerTypeDisplayName'] = this.trailerTypeDisplayName;
    data['payloadMaxWeightDisplayName'] = this.payloadMaxWeightDisplayName;
    data['truckPlateNumber'] = this.truckPlateNumber;
    return data;
  }
}

export interface IGetTrailerForEditOutput {
  trailer: CreateOrEditTrailerDto;
  trailerStatusDisplayName: string | undefined;
  trailerTypeDisplayName: string | undefined;
  payloadMaxWeightDisplayName: string | undefined;
  truckPlateNumber: string | undefined;
}

export class TrailerTrailerStatusLookupTableDto implements ITrailerTrailerStatusLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITrailerTrailerStatusLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TrailerTrailerStatusLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerTrailerStatusLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITrailerTrailerStatusLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class TrailerTrailerTypeLookupTableDto implements ITrailerTrailerTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITrailerTrailerTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TrailerTrailerTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerTrailerTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITrailerTrailerTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class TrailerPayloadMaxWeightLookupTableDto implements ITrailerPayloadMaxWeightLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITrailerPayloadMaxWeightLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TrailerPayloadMaxWeightLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerPayloadMaxWeightLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITrailerPayloadMaxWeightLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class TrailerTruckLookupTableDto implements ITrailerTruckLookupTableDto {
  id!: string | undefined;
  displayName!: string | undefined;

  constructor(data?: ITrailerTruckLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TrailerTruckLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerTruckLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITrailerTruckLookupTableDto {
  id: string | undefined;
  displayName: string | undefined;
}

export class TrailerStatusDto implements ITrailerStatusDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: ITrailerStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TrailerStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITrailerStatusDto {
  displayName: string | undefined;
  id: number;
}

export class GetTrailerStatusForViewDto implements IGetTrailerStatusForViewDto {
  trailerStatus!: TrailerStatusDto;

  constructor(data?: IGetTrailerStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerStatus = _data['trailerStatus'] ? TrailerStatusDto.fromJS(_data['trailerStatus']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTrailerStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerStatus'] = this.trailerStatus ? this.trailerStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTrailerStatusForViewDto {
  trailerStatus: TrailerStatusDto;
}

export class PagedResultDtoOfGetTrailerStatusForViewDto implements IPagedResultDtoOfGetTrailerStatusForViewDto {
  totalCount!: number;
  items!: GetTrailerStatusForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTrailerStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTrailerStatusForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTrailerStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTrailerStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTrailerStatusForViewDto {
  totalCount: number;
  items: GetTrailerStatusForViewDto[] | undefined;
}

export class CreateOrEditTrailerStatusDto implements ICreateOrEditTrailerStatusDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTrailerStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTrailerStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTrailerStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTrailerStatusDto {
  displayName: string;
  id: number | undefined;
}

export class GetTrailerStatusForEditOutput implements IGetTrailerStatusForEditOutput {
  trailerStatus!: CreateOrEditTrailerStatusDto;

  constructor(data?: IGetTrailerStatusForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerStatus = _data['trailerStatus'] ? CreateOrEditTrailerStatusDto.fromJS(_data['trailerStatus']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTrailerStatusForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerStatusForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerStatus'] = this.trailerStatus ? this.trailerStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTrailerStatusForEditOutput {
  trailerStatus: CreateOrEditTrailerStatusDto;
}

export class TrailerTypeDto implements ITrailerTypeDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: ITrailerTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TrailerTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrailerTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITrailerTypeDto {
  displayName: string | undefined;
  id: number;
}

export class GetTrailerTypeForViewDto implements IGetTrailerTypeForViewDto {
  trailerType!: TrailerTypeDto;

  constructor(data?: IGetTrailerTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerType = _data['trailerType'] ? TrailerTypeDto.fromJS(_data['trailerType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTrailerTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerType'] = this.trailerType ? this.trailerType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTrailerTypeForViewDto {
  trailerType: TrailerTypeDto;
}

export class PagedResultDtoOfGetTrailerTypeForViewDto implements IPagedResultDtoOfGetTrailerTypeForViewDto {
  totalCount!: number;
  items!: GetTrailerTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTrailerTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTrailerTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTrailerTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTrailerTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTrailerTypeForViewDto {
  totalCount: number;
  items: GetTrailerTypeForViewDto[] | undefined;
}

export class CreateOrEditTrailerTypeDto implements ICreateOrEditTrailerTypeDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTrailerTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTrailerTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTrailerTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTrailerTypeDto {
  displayName: string;
  id: number | undefined;
}

export class GetTrailerTypeForEditOutput implements IGetTrailerTypeForEditOutput {
  trailerType!: CreateOrEditTrailerTypeDto;

  constructor(data?: IGetTrailerTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trailerType = _data['trailerType'] ? CreateOrEditTrailerTypeDto.fromJS(_data['trailerType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTrailerTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrailerTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trailerType'] = this.trailerType ? this.trailerType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTrailerTypeForEditOutput {
  trailerType: CreateOrEditTrailerTypeDto;
}

export enum ChannelType {
  Invoices = 1,
  BalanceRecharge = 2,
}

export class TransactionListDto implements ITransactionListDto {
  creationTime!: moment.Moment;
  clientName!: string | undefined;
  edition!: string | undefined;
  channelId!: number;
  channel!: string | undefined;
  amount!: number;
  count!: number;
  sourceId!: number;
  id!: number;

  constructor(data?: ITransactionListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.clientName = _data['clientName'];
      this.edition = _data['edition'];
      this.channelId = _data['channelId'];
      this.channel = _data['channel'];
      this.amount = _data['amount'];
      this.count = _data['count'];
      this.sourceId = _data['sourceId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TransactionListDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['clientName'] = this.clientName;
    data['edition'] = this.edition;
    data['channelId'] = this.channelId;
    data['channel'] = this.channel;
    data['amount'] = this.amount;
    data['count'] = this.count;
    data['sourceId'] = this.sourceId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITransactionListDto {
  creationTime: moment.Moment;
  clientName: string | undefined;
  edition: string | undefined;
  channelId: number;
  channel: string | undefined;
  amount: number;
  count: number;
  sourceId: number;
  id: number;
}

export class PagedResultDtoOfTransactionListDto implements IPagedResultDtoOfTransactionListDto {
  totalCount!: number;
  items!: TransactionListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTransactionListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TransactionListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTransactionListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTransactionListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfTransactionListDto {
  totalCount: number;
  items: TransactionListDto[] | undefined;
}

export class TransactionFilterInput implements ITransactionFilterInput {
  channelType!: ChannelType;
  tenantId!: number | undefined;
  fromDate!: moment.Moment | undefined;
  toDate!: moment.Moment | undefined;
  minLongitude!: number | undefined;
  maxLongitude!: number | undefined;
  editionId!: number | undefined;
  sorting!: string | undefined;
  skipCount!: number;
  maxResultCount!: number;

  constructor(data?: ITransactionFilterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.channelType = _data['channelType'];
      this.tenantId = _data['tenantId'];
      this.fromDate = _data['fromDate'] ? moment(_data['fromDate'].toString()) : <any>undefined;
      this.toDate = _data['toDate'] ? moment(_data['toDate'].toString()) : <any>undefined;
      this.minLongitude = _data['minLongitude'];
      this.maxLongitude = _data['maxLongitude'];
      this.editionId = _data['editionId'];
      this.sorting = _data['sorting'];
      this.skipCount = _data['skipCount'];
      this.maxResultCount = _data['maxResultCount'];
    }
  }

  static fromJS(data: any): TransactionFilterInput {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionFilterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['channelType'] = this.channelType;
    data['tenantId'] = this.tenantId;
    data['fromDate'] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
    data['toDate'] = this.toDate ? this.toDate.toISOString() : <any>undefined;
    data['minLongitude'] = this.minLongitude;
    data['maxLongitude'] = this.maxLongitude;
    data['editionId'] = this.editionId;
    data['sorting'] = this.sorting;
    data['skipCount'] = this.skipCount;
    data['maxResultCount'] = this.maxResultCount;
    return data;
  }
}

export interface ITransactionFilterInput {
  channelType: ChannelType;
  tenantId: number | undefined;
  fromDate: moment.Moment | undefined;
  toDate: moment.Moment | undefined;
  minLongitude: number | undefined;
  maxLongitude: number | undefined;
  editionId: number | undefined;
  sorting: string | undefined;
  skipCount: number;
  maxResultCount: number;
}

export class TransportTypeDto implements ITransportTypeDto {
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ITransportTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TransportTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransportTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITransportTypeDto {
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetTransportTypeForViewDto implements IGetTransportTypeForViewDto {
  transportType!: TransportTypeDto;

  constructor(data?: IGetTransportTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportType = _data['transportType'] ? TransportTypeDto.fromJS(_data['transportType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTransportTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransportTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportType'] = this.transportType ? this.transportType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTransportTypeForViewDto {
  transportType: TransportTypeDto;
}

export class PagedResultDtoOfGetTransportTypeForViewDto implements IPagedResultDtoOfGetTransportTypeForViewDto {
  totalCount!: number;
  items!: GetTransportTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTransportTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTransportTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTransportTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTransportTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTransportTypeForViewDto {
  totalCount: number;
  items: GetTransportTypeForViewDto[] | undefined;
}

export class CreateOrEditTransportTypeDto implements ICreateOrEditTransportTypeDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTransportTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTransportTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTransportTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTransportTypeDto {
  displayName: string;
  id: number | undefined;
}

export class GetTransportTypeForEditOutput implements IGetTransportTypeForEditOutput {
  transportType!: CreateOrEditTransportTypeDto;

  constructor(data?: IGetTransportTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportType = _data['transportType'] ? CreateOrEditTransportTypeDto.fromJS(_data['transportType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTransportTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransportTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportType'] = this.transportType ? this.transportType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTransportTypeForEditOutput {
  transportType: CreateOrEditTransportTypeDto;
}

export class TransportTypesTranslationDto implements ITransportTypesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: ITransportTypesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TransportTypesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransportTypesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITransportTypesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetTransportTypesTranslationForViewDto implements IGetTransportTypesTranslationForViewDto {
  transportTypesTranslation!: TransportTypesTranslationDto;
  transportTypeDisplayName!: string | undefined;

  constructor(data?: IGetTransportTypesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportTypesTranslation = _data['transportTypesTranslation']
        ? TransportTypesTranslationDto.fromJS(_data['transportTypesTranslation'])
        : <any>undefined;
      this.transportTypeDisplayName = _data['transportTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetTransportTypesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransportTypesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportTypesTranslation'] = this.transportTypesTranslation ? this.transportTypesTranslation.toJSON() : <any>undefined;
    data['transportTypeDisplayName'] = this.transportTypeDisplayName;
    return data;
  }
}

export interface IGetTransportTypesTranslationForViewDto {
  transportTypesTranslation: TransportTypesTranslationDto;
  transportTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetTransportTypesTranslationForViewDto implements IPagedResultDtoOfGetTransportTypesTranslationForViewDto {
  totalCount!: number;
  items!: GetTransportTypesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTransportTypesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTransportTypesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTransportTypesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTransportTypesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTransportTypesTranslationForViewDto {
  totalCount: number;
  items: GetTransportTypesTranslationForViewDto[] | undefined;
}

export class CreateOrEditTransportTypesTranslationDto implements ICreateOrEditTransportTypesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTransportTypesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTransportTypesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTransportTypesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTransportTypesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetTransportTypesTranslationForEditOutput implements IGetTransportTypesTranslationForEditOutput {
  transportTypesTranslation!: CreateOrEditTransportTypesTranslationDto;
  transportTypeDisplayName!: string | undefined;

  constructor(data?: IGetTransportTypesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportTypesTranslation = _data['transportTypesTranslation']
        ? CreateOrEditTransportTypesTranslationDto.fromJS(_data['transportTypesTranslation'])
        : <any>undefined;
      this.transportTypeDisplayName = _data['transportTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetTransportTypesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTransportTypesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportTypesTranslation'] = this.transportTypesTranslation ? this.transportTypesTranslation.toJSON() : <any>undefined;
    data['transportTypeDisplayName'] = this.transportTypeDisplayName;
    return data;
  }
}

export interface IGetTransportTypesTranslationForEditOutput {
  transportTypesTranslation: CreateOrEditTransportTypesTranslationDto;
  transportTypeDisplayName: string | undefined;
}

export class TransportTypesTranslationTransportTypeLookupTableDto implements ITransportTypesTranslationTransportTypeLookupTableDto {
  id!: number;
  translatedDisplayName!: string | undefined;

  constructor(data?: ITransportTypesTranslationTransportTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): TransportTypesTranslationTransportTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TransportTypesTranslationTransportTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ITransportTypesTranslationTransportTypeLookupTableDto {
  id: number;
  translatedDisplayName: string | undefined;
}

export class TruckCapacitiesTranslationDto implements ITruckCapacitiesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: ITruckCapacitiesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TruckCapacitiesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckCapacitiesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITruckCapacitiesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetTruckCapacitiesTranslationForViewDto implements IGetTruckCapacitiesTranslationForViewDto {
  truckCapacitiesTranslation!: TruckCapacitiesTranslationDto;
  capacityDisplayName!: string | undefined;

  constructor(data?: IGetTruckCapacitiesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckCapacitiesTranslation = _data['truckCapacitiesTranslation']
        ? TruckCapacitiesTranslationDto.fromJS(_data['truckCapacitiesTranslation'])
        : <any>undefined;
      this.capacityDisplayName = _data['capacityDisplayName'];
    }
  }

  static fromJS(data: any): GetTruckCapacitiesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckCapacitiesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckCapacitiesTranslation'] = this.truckCapacitiesTranslation ? this.truckCapacitiesTranslation.toJSON() : <any>undefined;
    data['capacityDisplayName'] = this.capacityDisplayName;
    return data;
  }
}

export interface IGetTruckCapacitiesTranslationForViewDto {
  truckCapacitiesTranslation: TruckCapacitiesTranslationDto;
  capacityDisplayName: string | undefined;
}

export class PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto implements IPagedResultDtoOfGetTruckCapacitiesTranslationForViewDto {
  totalCount!: number;
  items!: GetTruckCapacitiesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTruckCapacitiesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTruckCapacitiesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTruckCapacitiesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTruckCapacitiesTranslationForViewDto {
  totalCount: number;
  items: GetTruckCapacitiesTranslationForViewDto[] | undefined;
}

export class CreateOrEditTruckCapacitiesTranslationDto implements ICreateOrEditTruckCapacitiesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTruckCapacitiesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTruckCapacitiesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTruckCapacitiesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTruckCapacitiesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetTruckCapacitiesTranslationForEditOutput implements IGetTruckCapacitiesTranslationForEditOutput {
  truckCapacitiesTranslation!: CreateOrEditTruckCapacitiesTranslationDto;
  capacityDisplayName!: string | undefined;

  constructor(data?: IGetTruckCapacitiesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckCapacitiesTranslation = _data['truckCapacitiesTranslation']
        ? CreateOrEditTruckCapacitiesTranslationDto.fromJS(_data['truckCapacitiesTranslation'])
        : <any>undefined;
      this.capacityDisplayName = _data['capacityDisplayName'];
    }
  }

  static fromJS(data: any): GetTruckCapacitiesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckCapacitiesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckCapacitiesTranslation'] = this.truckCapacitiesTranslation ? this.truckCapacitiesTranslation.toJSON() : <any>undefined;
    data['capacityDisplayName'] = this.capacityDisplayName;
    return data;
  }
}

export interface IGetTruckCapacitiesTranslationForEditOutput {
  truckCapacitiesTranslation: CreateOrEditTruckCapacitiesTranslationDto;
  capacityDisplayName: string | undefined;
}

export class TruckCapacitiesTranslationCapacityLookupTableDto implements ITruckCapacitiesTranslationCapacityLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITruckCapacitiesTranslationCapacityLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TruckCapacitiesTranslationCapacityLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckCapacitiesTranslationCapacityLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITruckCapacitiesTranslationCapacityLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class PagedResultDtoOfGetTruckForViewOutput implements IPagedResultDtoOfGetTruckForViewOutput {
  totalCount!: number;
  items!: GetTruckForViewOutput[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTruckForViewOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTruckForViewOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTruckForViewOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTruckForViewOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTruckForViewOutput {
  totalCount: number;
  items: GetTruckForViewOutput[] | undefined;
}

export class UpdateTruckPictureInput implements IUpdateTruckPictureInput {
  fileToken!: string | undefined;
  x!: number;
  y!: number;
  width!: number;
  height!: number;

  constructor(data?: IUpdateTruckPictureInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileToken = _data['fileToken'];
      this.x = _data['x'];
      this.y = _data['y'];
      this.width = _data['width'];
      this.height = _data['height'];
    }
  }

  static fromJS(data: any): UpdateTruckPictureInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTruckPictureInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileToken'] = this.fileToken;
    data['x'] = this.x;
    data['y'] = this.y;
    data['width'] = this.width;
    data['height'] = this.height;
    return data;
  }
}

export interface IUpdateTruckPictureInput {
  fileToken: string | undefined;
  x: number;
  y: number;
  width: number;
  height: number;
}

export class CreateOrEditTruckDto implements ICreateOrEditTruckDto {
  plateNumber!: string;
  modelName!: string;
  modelYear!: string;
  capacity!: string | undefined;
  isAttachable!: boolean;
  note!: string | undefined;
  truckStatusId!: number;
  updateTruckPictureInput!: UpdateTruckPictureInput;
  createOrEditDocumentFileDtos!: CreateOrEditDocumentFileDto[] | undefined;
  transportTypeId!: number | undefined;
  trucksTypeId!: number | undefined;
  capacityId!: number | undefined;
  length!: number | undefined;
  plateTypeId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTruckDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.plateNumber = _data['plateNumber'];
      this.modelName = _data['modelName'];
      this.modelYear = _data['modelYear'];
      this.capacity = _data['capacity'];
      this.isAttachable = _data['isAttachable'];
      this.note = _data['note'];
      this.truckStatusId = _data['truckStatusId'];
      this.updateTruckPictureInput = _data['updateTruckPictureInput']
        ? UpdateTruckPictureInput.fromJS(_data['updateTruckPictureInput'])
        : <any>undefined;
      if (Array.isArray(_data['createOrEditDocumentFileDtos'])) {
        this.createOrEditDocumentFileDtos = [] as any;
        for (let item of _data['createOrEditDocumentFileDtos']) this.createOrEditDocumentFileDtos!.push(CreateOrEditDocumentFileDto.fromJS(item));
      }
      this.transportTypeId = _data['transportTypeId'];
      this.trucksTypeId = _data['trucksTypeId'];
      this.capacityId = _data['capacityId'];
      this.length = _data['length'];
      this.plateTypeId = _data['plateTypeId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTruckDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTruckDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['plateNumber'] = this.plateNumber;
    data['modelName'] = this.modelName;
    data['modelYear'] = this.modelYear;
    data['capacity'] = this.capacity;
    data['isAttachable'] = this.isAttachable;
    data['note'] = this.note;
    data['truckStatusId'] = this.truckStatusId;
    data['updateTruckPictureInput'] = this.updateTruckPictureInput ? this.updateTruckPictureInput.toJSON() : <any>undefined;
    if (Array.isArray(this.createOrEditDocumentFileDtos)) {
      data['createOrEditDocumentFileDtos'] = [];
      for (let item of this.createOrEditDocumentFileDtos) data['createOrEditDocumentFileDtos'].push(item.toJSON());
    }
    data['transportTypeId'] = this.transportTypeId;
    data['trucksTypeId'] = this.trucksTypeId;
    data['capacityId'] = this.capacityId;
    data['length'] = this.length;
    data['plateTypeId'] = this.plateTypeId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTruckDto {
  plateNumber: string;
  modelName: string;
  modelYear: string;
  capacity: string | undefined;
  isAttachable: boolean;
  note: string | undefined;
  truckStatusId: number;
  updateTruckPictureInput: UpdateTruckPictureInput;
  createOrEditDocumentFileDtos: CreateOrEditDocumentFileDto[] | undefined;
  transportTypeId: number | undefined;
  trucksTypeId: number | undefined;
  capacityId: number | undefined;
  length: number | undefined;
  plateTypeId: number;
  id: number | undefined;
}

export class GetTruckForEditOutput implements IGetTruckForEditOutput {
  truck!: CreateOrEditTruckDto;
  trucksTypeDisplayName!: string | undefined;
  truckStatusDisplayName!: string | undefined;

  constructor(data?: IGetTruckForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truck = _data['truck'] ? CreateOrEditTruckDto.fromJS(_data['truck']) : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
      this.truckStatusDisplayName = _data['truckStatusDisplayName'];
    }
  }

  static fromJS(data: any): GetTruckForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truck'] = this.truck ? this.truck.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    data['truckStatusDisplayName'] = this.truckStatusDisplayName;
    return data;
  }
}

export interface IGetTruckForEditOutput {
  truck: CreateOrEditTruckDto;
  trucksTypeDisplayName: string | undefined;
  truckStatusDisplayName: string | undefined;
}

export class TruckTruckStatusLookupTableDto implements ITruckTruckStatusLookupTableDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: ITruckTruckStatusLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): TruckTruckStatusLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckTruckStatusLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface ITruckTruckStatusLookupTableDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class TruckUserLookupTableDto implements ITruckUserLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITruckUserLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TruckUserLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckUserLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITruckUserLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class PagedResultDtoOfTruckUserLookupTableDto implements IPagedResultDtoOfTruckUserLookupTableDto {
  totalCount!: number;
  items!: TruckUserLookupTableDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTruckUserLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TruckUserLookupTableDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTruckUserLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTruckUserLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfTruckUserLookupTableDto {
  totalCount: number;
  items: TruckUserLookupTableDto[] | undefined;
}

export class PlateTypeSelectItemDto implements IPlateTypeSelectItemDto {
  id!: string | undefined;
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;

  constructor(data?: IPlateTypeSelectItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
    }
  }

  static fromJS(data: any): PlateTypeSelectItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new PlateTypeSelectItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    return data;
  }
}

export interface IPlateTypeSelectItemDto {
  id: string | undefined;
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
}

export class TruckStatusDto implements ITruckStatusDto {
  displayName!: string | undefined;
  translatedDisplayName!: string | undefined;
  id!: number;

  constructor(data?: ITruckStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TruckStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ITruckStatusDto {
  displayName: string | undefined;
  translatedDisplayName: string | undefined;
  id: number;
}

export class GetTruckStatusForViewDto implements IGetTruckStatusForViewDto {
  truckStatus!: TruckStatusDto;

  constructor(data?: IGetTruckStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckStatus = _data['truckStatus'] ? TruckStatusDto.fromJS(_data['truckStatus']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTruckStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckStatus'] = this.truckStatus ? this.truckStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTruckStatusForViewDto {
  truckStatus: TruckStatusDto;
}

export class PagedResultDtoOfGetTruckStatusForViewDto implements IPagedResultDtoOfGetTruckStatusForViewDto {
  totalCount!: number;
  items!: GetTruckStatusForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTruckStatusForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTruckStatusForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTruckStatusForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTruckStatusForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTruckStatusForViewDto {
  totalCount: number;
  items: GetTruckStatusForViewDto[] | undefined;
}

export class CreateOrEditTruckStatusDto implements ICreateOrEditTruckStatusDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTruckStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTruckStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTruckStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTruckStatusDto {
  displayName: string;
  id: number | undefined;
}

export class GetTruckStatusForEditOutput implements IGetTruckStatusForEditOutput {
  truckStatus!: CreateOrEditTruckStatusDto;

  constructor(data?: IGetTruckStatusForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckStatus = _data['truckStatus'] ? CreateOrEditTruckStatusDto.fromJS(_data['truckStatus']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTruckStatusForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckStatusForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckStatus'] = this.truckStatus ? this.truckStatus.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTruckStatusForEditOutput {
  truckStatus: CreateOrEditTruckStatusDto;
}

export class TruckStatusesTranslationDto implements ITruckStatusesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  coreId!: number;
  id!: number;

  constructor(data?: ITruckStatusesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TruckStatusesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckStatusesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ITruckStatusesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  coreId: number;
  id: number;
}

export class GetTruckStatusesTranslationForViewDto implements IGetTruckStatusesTranslationForViewDto {
  truckStatusesTranslation!: TruckStatusesTranslationDto;
  truckStatusDisplayName!: string | undefined;

  constructor(data?: IGetTruckStatusesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckStatusesTranslation = _data['truckStatusesTranslation']
        ? TruckStatusesTranslationDto.fromJS(_data['truckStatusesTranslation'])
        : <any>undefined;
      this.truckStatusDisplayName = _data['truckStatusDisplayName'];
    }
  }

  static fromJS(data: any): GetTruckStatusesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckStatusesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckStatusesTranslation'] = this.truckStatusesTranslation ? this.truckStatusesTranslation.toJSON() : <any>undefined;
    data['truckStatusDisplayName'] = this.truckStatusDisplayName;
    return data;
  }
}

export interface IGetTruckStatusesTranslationForViewDto {
  truckStatusesTranslation: TruckStatusesTranslationDto;
  truckStatusDisplayName: string | undefined;
}

export class PagedResultDtoOfGetTruckStatusesTranslationForViewDto implements IPagedResultDtoOfGetTruckStatusesTranslationForViewDto {
  totalCount!: number;
  items!: GetTruckStatusesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTruckStatusesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTruckStatusesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTruckStatusesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTruckStatusesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTruckStatusesTranslationForViewDto {
  totalCount: number;
  items: GetTruckStatusesTranslationForViewDto[] | undefined;
}

export class CreateOrEditTruckStatusesTranslationDto implements ICreateOrEditTruckStatusesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTruckStatusesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTruckStatusesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTruckStatusesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTruckStatusesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetTruckStatusesTranslationForEditOutput implements IGetTruckStatusesTranslationForEditOutput {
  truckStatusesTranslation!: CreateOrEditTruckStatusesTranslationDto;
  truckStatusDisplayName!: string | undefined;

  constructor(data?: IGetTruckStatusesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckStatusesTranslation = _data['truckStatusesTranslation']
        ? CreateOrEditTruckStatusesTranslationDto.fromJS(_data['truckStatusesTranslation'])
        : <any>undefined;
      this.truckStatusDisplayName = _data['truckStatusDisplayName'];
    }
  }

  static fromJS(data: any): GetTruckStatusesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTruckStatusesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckStatusesTranslation'] = this.truckStatusesTranslation ? this.truckStatusesTranslation.toJSON() : <any>undefined;
    data['truckStatusDisplayName'] = this.truckStatusDisplayName;
    return data;
  }
}

export interface IGetTruckStatusesTranslationForEditOutput {
  truckStatusesTranslation: CreateOrEditTruckStatusesTranslationDto;
  truckStatusDisplayName: string | undefined;
}

export class TruckStatusesTranslationTruckStatusLookupTableDto implements ITruckStatusesTranslationTruckStatusLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITruckStatusesTranslationTruckStatusLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TruckStatusesTranslationTruckStatusLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TruckStatusesTranslationTruckStatusLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITruckStatusesTranslationTruckStatusLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class GetTrucksTypeForViewDto implements IGetTrucksTypeForViewDto {
  trucksType!: TrucksTypeDto;
  transportTypeDisplayName!: string | undefined;

  constructor(data?: IGetTrucksTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trucksType = _data['trucksType'] ? TrucksTypeDto.fromJS(_data['trucksType']) : <any>undefined;
      this.transportTypeDisplayName = _data['transportTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetTrucksTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrucksTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trucksType'] = this.trucksType ? this.trucksType.toJSON() : <any>undefined;
    data['transportTypeDisplayName'] = this.transportTypeDisplayName;
    return data;
  }
}

export interface IGetTrucksTypeForViewDto {
  trucksType: TrucksTypeDto;
  transportTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetTrucksTypeForViewDto implements IPagedResultDtoOfGetTrucksTypeForViewDto {
  totalCount!: number;
  items!: GetTrucksTypeForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTrucksTypeForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTrucksTypeForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTrucksTypeForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTrucksTypeForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTrucksTypeForViewDto {
  totalCount: number;
  items: GetTrucksTypeForViewDto[] | undefined;
}

export class TrucksTypesTranslationDto implements ITrucksTypesTranslationDto {
  translatedDisplayName!: string | undefined;
  language!: string | undefined;
  languageDisplayName!: string | undefined;
  icon!: string | undefined;
  id!: number;

  constructor(data?: ITrucksTypesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.languageDisplayName = _data['languageDisplayName'];
      this.icon = _data['icon'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): TrucksTypesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrucksTypesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['languageDisplayName'] = this.languageDisplayName;
    data['icon'] = this.icon;
    data['id'] = this.id;
    return data;
  }
}

export interface ITrucksTypesTranslationDto {
  translatedDisplayName: string | undefined;
  language: string | undefined;
  languageDisplayName: string | undefined;
  icon: string | undefined;
  id: number;
}

export class CreateOrEditTrucksTypeDto implements ICreateOrEditTrucksTypeDto {
  transportTypeId!: number | undefined;
  translations!: TrucksTypesTranslationDto[] | undefined;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTrucksTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.transportTypeId = _data['transportTypeId'];
      if (Array.isArray(_data['translations'])) {
        this.translations = [] as any;
        for (let item of _data['translations']) this.translations!.push(TrucksTypesTranslationDto.fromJS(item));
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTrucksTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTrucksTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['transportTypeId'] = this.transportTypeId;
    if (Array.isArray(this.translations)) {
      data['translations'] = [];
      for (let item of this.translations) data['translations'].push(item.toJSON());
    }
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTrucksTypeDto {
  transportTypeId: number | undefined;
  translations: TrucksTypesTranslationDto[] | undefined;
  id: number | undefined;
}

export class GetTrucksTypeForEditOutput implements IGetTrucksTypeForEditOutput {
  trucksType!: CreateOrEditTrucksTypeDto;

  constructor(data?: IGetTrucksTypeForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trucksType = _data['trucksType'] ? CreateOrEditTrucksTypeDto.fromJS(_data['trucksType']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetTrucksTypeForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrucksTypeForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trucksType'] = this.trucksType ? this.trucksType.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetTrucksTypeForEditOutput {
  trucksType: CreateOrEditTrucksTypeDto;
}

export class GetTrucksTypesTranslationForViewDto implements IGetTrucksTypesTranslationForViewDto {
  trucksTypesTranslation!: TrucksTypesTranslationDto;
  trucksTypeDisplayName!: string | undefined;

  constructor(data?: IGetTrucksTypesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trucksTypesTranslation = _data['trucksTypesTranslation']
        ? TrucksTypesTranslationDto.fromJS(_data['trucksTypesTranslation'])
        : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetTrucksTypesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrucksTypesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trucksTypesTranslation'] = this.trucksTypesTranslation ? this.trucksTypesTranslation.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    return data;
  }
}

export interface IGetTrucksTypesTranslationForViewDto {
  trucksTypesTranslation: TrucksTypesTranslationDto;
  trucksTypeDisplayName: string | undefined;
}

export class PagedResultDtoOfGetTrucksTypesTranslationForViewDto implements IPagedResultDtoOfGetTrucksTypesTranslationForViewDto {
  totalCount!: number;
  items!: GetTrucksTypesTranslationForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetTrucksTypesTranslationForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetTrucksTypesTranslationForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetTrucksTypesTranslationForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetTrucksTypesTranslationForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetTrucksTypesTranslationForViewDto {
  totalCount: number;
  items: GetTrucksTypesTranslationForViewDto[] | undefined;
}

export class CreateOrEditTrucksTypesTranslationDto implements ICreateOrEditTrucksTypesTranslationDto {
  translatedDisplayName!: string;
  language!: string;
  coreId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditTrucksTypesTranslationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.translatedDisplayName = _data['translatedDisplayName'];
      this.language = _data['language'];
      this.coreId = _data['coreId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditTrucksTypesTranslationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditTrucksTypesTranslationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['translatedDisplayName'] = this.translatedDisplayName;
    data['language'] = this.language;
    data['coreId'] = this.coreId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditTrucksTypesTranslationDto {
  translatedDisplayName: string;
  language: string;
  coreId: number;
  id: number | undefined;
}

export class GetTrucksTypesTranslationForEditOutput implements IGetTrucksTypesTranslationForEditOutput {
  trucksTypesTranslation!: CreateOrEditTrucksTypesTranslationDto;
  trucksTypeDisplayName!: string | undefined;

  constructor(data?: IGetTrucksTypesTranslationForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.trucksTypesTranslation = _data['trucksTypesTranslation']
        ? CreateOrEditTrucksTypesTranslationDto.fromJS(_data['trucksTypesTranslation'])
        : <any>undefined;
      this.trucksTypeDisplayName = _data['trucksTypeDisplayName'];
    }
  }

  static fromJS(data: any): GetTrucksTypesTranslationForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetTrucksTypesTranslationForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['trucksTypesTranslation'] = this.trucksTypesTranslation ? this.trucksTypesTranslation.toJSON() : <any>undefined;
    data['trucksTypeDisplayName'] = this.trucksTypeDisplayName;
    return data;
  }
}

export interface IGetTrucksTypesTranslationForEditOutput {
  trucksTypesTranslation: CreateOrEditTrucksTypesTranslationDto;
  trucksTypeDisplayName: string | undefined;
}

export class TrucksTypesTranslationTrucksTypeLookupTableDto implements ITrucksTypesTranslationTrucksTypeLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: ITrucksTypesTranslationTrucksTypeLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): TrucksTypesTranslationTrucksTypeLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new TrucksTypesTranslationTrucksTypeLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface ITrucksTypesTranslationTrucksTypeLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class UnitOfMeasureDto implements IUnitOfMeasureDto {
  displayName!: string | undefined;
  id!: number;

  constructor(data?: IUnitOfMeasureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UnitOfMeasureDto {
    data = typeof data === 'object' ? data : {};
    let result = new UnitOfMeasureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IUnitOfMeasureDto {
  displayName: string | undefined;
  id: number;
}

export class GetUnitOfMeasureForViewDto implements IGetUnitOfMeasureForViewDto {
  unitOfMeasure!: UnitOfMeasureDto;

  constructor(data?: IGetUnitOfMeasureForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.unitOfMeasure = _data['unitOfMeasure'] ? UnitOfMeasureDto.fromJS(_data['unitOfMeasure']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetUnitOfMeasureForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnitOfMeasureForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['unitOfMeasure'] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetUnitOfMeasureForViewDto {
  unitOfMeasure: UnitOfMeasureDto;
}

export class PagedResultDtoOfGetUnitOfMeasureForViewDto implements IPagedResultDtoOfGetUnitOfMeasureForViewDto {
  totalCount!: number;
  items!: GetUnitOfMeasureForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetUnitOfMeasureForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetUnitOfMeasureForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetUnitOfMeasureForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetUnitOfMeasureForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetUnitOfMeasureForViewDto {
  totalCount: number;
  items: GetUnitOfMeasureForViewDto[] | undefined;
}

export class CreateOrEditUnitOfMeasureDto implements ICreateOrEditUnitOfMeasureDto {
  displayName!: string;
  id!: number | undefined;

  constructor(data?: ICreateOrEditUnitOfMeasureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditUnitOfMeasureDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditUnitOfMeasureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditUnitOfMeasureDto {
  displayName: string;
  id: number | undefined;
}

export class GetUnitOfMeasureForEditOutput implements IGetUnitOfMeasureForEditOutput {
  unitOfMeasure!: CreateOrEditUnitOfMeasureDto;

  constructor(data?: IGetUnitOfMeasureForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.unitOfMeasure = _data['unitOfMeasure'] ? CreateOrEditUnitOfMeasureDto.fromJS(_data['unitOfMeasure']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetUnitOfMeasureForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnitOfMeasureForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['unitOfMeasure'] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetUnitOfMeasureForEditOutput {
  unitOfMeasure: CreateOrEditUnitOfMeasureDto;
}

export class UserListRoleDto implements IUserListRoleDto {
  roleId!: number;
  roleName!: string | undefined;

  constructor(data?: IUserListRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data['roleId'];
      this.roleName = _data['roleName'];
    }
  }

  static fromJS(data: any): UserListRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserListRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleId'] = this.roleId;
    data['roleName'] = this.roleName;
    return data;
  }
}

export interface IUserListRoleDto {
  roleId: number;
  roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
  accountNumber!: string | undefined;
  name!: string | undefined;
  surname!: string | undefined;
  userName!: string | undefined;
  emailAddress!: string | undefined;
  phoneNumber!: string | undefined;
  profilePictureId!: string | undefined;
  isEmailConfirmed!: boolean;
  roles!: UserListRoleDto[] | undefined;
  isActive!: boolean;
  isMissingDocumentFiles!: boolean;
  creationTime!: moment.Moment;
  dateOfBirth!: moment.Moment | undefined;
  id!: number;

  constructor(data?: IUserListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountNumber = _data['accountNumber'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.phoneNumber = _data['phoneNumber'];
      this.profilePictureId = _data['profilePictureId'];
      this.isEmailConfirmed = _data['isEmailConfirmed'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(UserListRoleDto.fromJS(item));
      }
      this.isActive = _data['isActive'];
      this.isMissingDocumentFiles = _data['isMissingDocumentFiles'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.dateOfBirth = _data['dateOfBirth'] ? moment(_data['dateOfBirth'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserListDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accountNumber'] = this.accountNumber;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['phoneNumber'] = this.phoneNumber;
    data['profilePictureId'] = this.profilePictureId;
    data['isEmailConfirmed'] = this.isEmailConfirmed;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item.toJSON());
    }
    data['isActive'] = this.isActive;
    data['isMissingDocumentFiles'] = this.isMissingDocumentFiles;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['dateOfBirth'] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IUserListDto {
  accountNumber: string | undefined;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  profilePictureId: string | undefined;
  isEmailConfirmed: boolean;
  roles: UserListRoleDto[] | undefined;
  isActive: boolean;
  isMissingDocumentFiles: boolean;
  creationTime: moment.Moment;
  dateOfBirth: moment.Moment | undefined;
  id: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
  totalCount!: number;
  items!: UserListDto[] | undefined;

  constructor(data?: IPagedResultDtoOfUserListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfUserListDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfUserListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfUserListDto {
  totalCount: number;
  items: UserListDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
  id!: number | undefined;
  name!: string;
  surname!: string;
  userName!: string;
  emailAddress!: string;
  phoneNumber!: string | undefined;
  password!: string | undefined;
  isActive!: boolean;
  shouldChangePasswordOnNextLogin!: boolean;
  isTwoFactorEnabled!: boolean;
  isLockoutEnabled!: boolean;
  isDriver!: boolean;
  address!: string | undefined;
  nationalityId!: number | undefined;
  experienceField!: string | undefined;
  dateOfBirth!: moment.Moment | undefined;
  hijriDateOfBirth!: string | undefined;

  constructor(data?: IUserEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.userName = _data['userName'];
      this.emailAddress = _data['emailAddress'];
      this.phoneNumber = _data['phoneNumber'];
      this.password = _data['password'];
      this.isActive = _data['isActive'];
      this.shouldChangePasswordOnNextLogin = _data['shouldChangePasswordOnNextLogin'];
      this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
      this.isLockoutEnabled = _data['isLockoutEnabled'];
      this.isDriver = _data['isDriver'];
      this.address = _data['address'];
      this.nationalityId = _data['nationalityId'];
      this.experienceField = _data['experienceField'];
      this.dateOfBirth = _data['dateOfBirth'] ? moment(_data['dateOfBirth'].toString()) : <any>undefined;
      this.hijriDateOfBirth = _data['hijriDateOfBirth'];
    }
  }

  static fromJS(data: any): UserEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['userName'] = this.userName;
    data['emailAddress'] = this.emailAddress;
    data['phoneNumber'] = this.phoneNumber;
    data['password'] = this.password;
    data['isActive'] = this.isActive;
    data['shouldChangePasswordOnNextLogin'] = this.shouldChangePasswordOnNextLogin;
    data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
    data['isLockoutEnabled'] = this.isLockoutEnabled;
    data['isDriver'] = this.isDriver;
    data['address'] = this.address;
    data['nationalityId'] = this.nationalityId;
    data['experienceField'] = this.experienceField;
    data['dateOfBirth'] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
    data['hijriDateOfBirth'] = this.hijriDateOfBirth;
    return data;
  }
}

export interface IUserEditDto {
  id: number | undefined;
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  phoneNumber: string | undefined;
  password: string | undefined;
  isActive: boolean;
  shouldChangePasswordOnNextLogin: boolean;
  isTwoFactorEnabled: boolean;
  isLockoutEnabled: boolean;
  isDriver: boolean;
  address: string | undefined;
  nationalityId: number | undefined;
  experienceField: string | undefined;
  dateOfBirth: moment.Moment | undefined;
  hijriDateOfBirth: string | undefined;
}

export class UserRoleDto implements IUserRoleDto {
  roleId!: number;
  roleName!: string | undefined;
  roleDisplayName!: string | undefined;
  isAssigned!: boolean;
  inheritedFromOrganizationUnit!: boolean;

  constructor(data?: IUserRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data['roleId'];
      this.roleName = _data['roleName'];
      this.roleDisplayName = _data['roleDisplayName'];
      this.isAssigned = _data['isAssigned'];
      this.inheritedFromOrganizationUnit = _data['inheritedFromOrganizationUnit'];
    }
  }

  static fromJS(data: any): UserRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleId'] = this.roleId;
    data['roleName'] = this.roleName;
    data['roleDisplayName'] = this.roleDisplayName;
    data['isAssigned'] = this.isAssigned;
    data['inheritedFromOrganizationUnit'] = this.inheritedFromOrganizationUnit;
    return data;
  }
}

export interface IUserRoleDto {
  roleId: number;
  roleName: string | undefined;
  roleDisplayName: string | undefined;
  isAssigned: boolean;
  inheritedFromOrganizationUnit: boolean;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
  profilePictureId!: string | undefined;
  user!: UserEditDto;
  roles!: UserRoleDto[] | undefined;
  allOrganizationUnits!: OrganizationUnitDto[] | undefined;
  memberedOrganizationUnits!: string[] | undefined;

  constructor(data?: IGetUserForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.profilePictureId = _data['profilePictureId'];
      this.user = _data['user'] ? UserEditDto.fromJS(_data['user']) : <any>undefined;
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(UserRoleDto.fromJS(item));
      }
      if (Array.isArray(_data['allOrganizationUnits'])) {
        this.allOrganizationUnits = [] as any;
        for (let item of _data['allOrganizationUnits']) this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
      }
      if (Array.isArray(_data['memberedOrganizationUnits'])) {
        this.memberedOrganizationUnits = [] as any;
        for (let item of _data['memberedOrganizationUnits']) this.memberedOrganizationUnits!.push(item);
      }
    }
  }

  static fromJS(data: any): GetUserForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['profilePictureId'] = this.profilePictureId;
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item.toJSON());
    }
    if (Array.isArray(this.allOrganizationUnits)) {
      data['allOrganizationUnits'] = [];
      for (let item of this.allOrganizationUnits) data['allOrganizationUnits'].push(item.toJSON());
    }
    if (Array.isArray(this.memberedOrganizationUnits)) {
      data['memberedOrganizationUnits'] = [];
      for (let item of this.memberedOrganizationUnits) data['memberedOrganizationUnits'].push(item);
    }
    return data;
  }
}

export interface IGetUserForEditOutput {
  profilePictureId: string | undefined;
  user: UserEditDto;
  roles: UserRoleDto[] | undefined;
  allOrganizationUnits: OrganizationUnitDto[] | undefined;
  memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
  permissions!: FlatPermissionDto[] | undefined;
  grantedPermissionNames!: string[] | undefined;

  constructor(data?: IGetUserPermissionsForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions']) this.permissions!.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data['grantedPermissionNames'])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames!.push(item);
      }
    }
  }

  static fromJS(data: any): GetUserPermissionsForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUserPermissionsForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data['grantedPermissionNames'] = [];
      for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
    }
    return data;
  }
}

export interface IGetUserPermissionsForEditOutput {
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
  id!: number;

  constructor(data?: IEntityDtoOfInt64) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): EntityDtoOfInt64 {
    data = typeof data === 'object' ? data : {};
    let result = new EntityDtoOfInt64();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IEntityDtoOfInt64 {
  id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
  id!: number;
  grantedPermissionNames!: string[];

  constructor(data?: IUpdateUserPermissionsInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.grantedPermissionNames = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      if (Array.isArray(_data['grantedPermissionNames'])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data['grantedPermissionNames']) this.grantedPermissionNames!.push(item);
      }
    }
  }

  static fromJS(data: any): UpdateUserPermissionsInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserPermissionsInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    if (Array.isArray(this.grantedPermissionNames)) {
      data['grantedPermissionNames'] = [];
      for (let item of this.grantedPermissionNames) data['grantedPermissionNames'].push(item);
    }
    return data;
  }
}

export interface IUpdateUserPermissionsInput {
  id: number;
  grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
  user!: UserEditDto;
  assignedRoleNames!: string[];
  sendActivationEmail!: boolean;
  setRandomPassword!: boolean;
  organizationUnits!: number[] | undefined;
  createOrEditDocumentFileDtos!: CreateOrEditDocumentFileDto[] | undefined;

  constructor(data?: ICreateOrUpdateUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.user = new UserEditDto();
      this.assignedRoleNames = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data['user'] ? UserEditDto.fromJS(_data['user']) : new UserEditDto();
      if (Array.isArray(_data['assignedRoleNames'])) {
        this.assignedRoleNames = [] as any;
        for (let item of _data['assignedRoleNames']) this.assignedRoleNames!.push(item);
      }
      this.sendActivationEmail = _data['sendActivationEmail'];
      this.setRandomPassword = _data['setRandomPassword'];
      if (Array.isArray(_data['organizationUnits'])) {
        this.organizationUnits = [] as any;
        for (let item of _data['organizationUnits']) this.organizationUnits!.push(item);
      }
      if (Array.isArray(_data['createOrEditDocumentFileDtos'])) {
        this.createOrEditDocumentFileDtos = [] as any;
        for (let item of _data['createOrEditDocumentFileDtos']) this.createOrEditDocumentFileDtos!.push(CreateOrEditDocumentFileDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateOrUpdateUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrUpdateUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['user'] = this.user ? this.user.toJSON() : <any>undefined;
    if (Array.isArray(this.assignedRoleNames)) {
      data['assignedRoleNames'] = [];
      for (let item of this.assignedRoleNames) data['assignedRoleNames'].push(item);
    }
    data['sendActivationEmail'] = this.sendActivationEmail;
    data['setRandomPassword'] = this.setRandomPassword;
    if (Array.isArray(this.organizationUnits)) {
      data['organizationUnits'] = [];
      for (let item of this.organizationUnits) data['organizationUnits'].push(item);
    }
    if (Array.isArray(this.createOrEditDocumentFileDtos)) {
      data['createOrEditDocumentFileDtos'] = [];
      for (let item of this.createOrEditDocumentFileDtos) data['createOrEditDocumentFileDtos'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateOrUpdateUserInput {
  user: UserEditDto;
  assignedRoleNames: string[];
  sendActivationEmail: boolean;
  setRandomPassword: boolean;
  organizationUnits: number[] | undefined;
  createOrEditDocumentFileDtos: CreateOrEditDocumentFileDto[] | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
  username!: string | undefined;
  startTime!: moment.Moment;
  endTime!: moment.Moment;
  id!: number;

  constructor(data?: IUserDelegationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.startTime = _data['startTime'] ? moment(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? moment(_data['endTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UserDelegationDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDelegationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['startTime'] = this.startTime ? this.startTime.toISOString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IUserDelegationDto {
  username: string | undefined;
  startTime: moment.Moment;
  endTime: moment.Moment;
  id: number;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
  totalCount!: number;
  items!: UserDelegationDto[] | undefined;

  constructor(data?: IPagedResultDtoOfUserDelegationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserDelegationDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfUserDelegationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfUserDelegationDto {
  totalCount: number;
  items: UserDelegationDto[] | undefined;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
  targetUserId!: number;
  startTime!: moment.Moment;
  endTime!: moment.Moment;

  constructor(data?: ICreateUserDelegationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.targetUserId = _data['targetUserId'];
      this.startTime = _data['startTime'] ? moment(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? moment(_data['endTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): CreateUserDelegationDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserDelegationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['targetUserId'] = this.targetUserId;
    data['startTime'] = this.startTime ? this.startTime.toISOString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface ICreateUserDelegationDto {
  targetUserId: number;
  startTime: moment.Moment;
  endTime: moment.Moment;
}

export class LinkToUserInput implements ILinkToUserInput {
  tenancyName!: string | undefined;
  usernameOrEmailAddress!: string;
  password!: string;

  constructor(data?: ILinkToUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.usernameOrEmailAddress = _data['usernameOrEmailAddress'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LinkToUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new LinkToUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['usernameOrEmailAddress'] = this.usernameOrEmailAddress;
    data['password'] = this.password;
    return data;
  }
}

export interface ILinkToUserInput {
  tenancyName: string | undefined;
  usernameOrEmailAddress: string;
  password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
  tenantId!: number | undefined;
  tenancyName!: string | undefined;
  username!: string | undefined;
  id!: number;

  constructor(data?: ILinkedUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.tenancyName = _data['tenancyName'];
      this.username = _data['username'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): LinkedUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new LinkedUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['tenancyName'] = this.tenancyName;
    data['username'] = this.username;
    data['id'] = this.id;
    return data;
  }
}

export interface ILinkedUserDto {
  tenantId: number | undefined;
  tenancyName: string | undefined;
  username: string | undefined;
  id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
  totalCount!: number;
  items!: LinkedUserDto[] | undefined;

  constructor(data?: IPagedResultDtoOfLinkedUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LinkedUserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfLinkedUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfLinkedUserDto {
  totalCount: number;
  items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
  items!: LinkedUserDto[] | undefined;

  constructor(data?: IListResultDtoOfLinkedUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LinkedUserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfLinkedUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfLinkedUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfLinkedUserDto {
  items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
  tenantId!: number | undefined;
  userId!: number;

  constructor(data?: IUnlinkUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): UnlinkUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new UnlinkUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IUnlinkUserInput {
  tenantId: number | undefined;
  userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
  tenancyName!: string | undefined;
  userNameOrEmail!: string | undefined;
  clientIpAddress!: string | undefined;
  clientName!: string | undefined;
  browserInfo!: string | undefined;
  result!: string | undefined;
  creationTime!: moment.Moment;

  constructor(data?: IUserLoginAttemptDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data['tenancyName'];
      this.userNameOrEmail = _data['userNameOrEmail'];
      this.clientIpAddress = _data['clientIpAddress'];
      this.clientName = _data['clientName'];
      this.browserInfo = _data['browserInfo'];
      this.result = _data['result'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): UserLoginAttemptDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginAttemptDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenancyName'] = this.tenancyName;
    data['userNameOrEmail'] = this.userNameOrEmail;
    data['clientIpAddress'] = this.clientIpAddress;
    data['clientName'] = this.clientName;
    data['browserInfo'] = this.browserInfo;
    data['result'] = this.result;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUserLoginAttemptDto {
  tenancyName: string | undefined;
  userNameOrEmail: string | undefined;
  clientIpAddress: string | undefined;
  clientName: string | undefined;
  browserInfo: string | undefined;
  result: string | undefined;
  creationTime: moment.Moment;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
  items!: UserLoginAttemptDto[] | undefined;

  constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserLoginAttemptDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfUserLoginAttemptDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfUserLoginAttemptDto {
  items: UserLoginAttemptDto[] | undefined;
}

export class VasDto implements IVasDto {
  name!: string | undefined;
  hasAmount!: boolean;
  hasCount!: boolean;
  creationTime!: moment.Moment;
  id!: number;

  constructor(data?: IVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.hasAmount = _data['hasAmount'];
      this.hasCount = _data['hasCount'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): VasDto {
    data = typeof data === 'object' ? data : {};
    let result = new VasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['hasAmount'] = this.hasAmount;
    data['hasCount'] = this.hasCount;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IVasDto {
  name: string | undefined;
  hasAmount: boolean;
  hasCount: boolean;
  creationTime: moment.Moment;
  id: number;
}

export class GetVasForViewDto implements IGetVasForViewDto {
  vas!: VasDto;

  constructor(data?: IGetVasForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vas = _data['vas'] ? VasDto.fromJS(_data['vas']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetVasForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetVasForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vas'] = this.vas ? this.vas.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetVasForViewDto {
  vas: VasDto;
}

export class PagedResultDtoOfGetVasForViewDto implements IPagedResultDtoOfGetVasForViewDto {
  totalCount!: number;
  items!: GetVasForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetVasForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetVasForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetVasForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetVasForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetVasForViewDto {
  totalCount: number;
  items: GetVasForViewDto[] | undefined;
}

export class CreateOrEditVasDto implements ICreateOrEditVasDto {
  name!: string;
  displayName!: string | undefined;
  hasAmount!: boolean;
  hasCount!: boolean;
  id!: number | undefined;

  constructor(data?: ICreateOrEditVasDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.hasAmount = _data['hasAmount'];
      this.hasCount = _data['hasCount'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditVasDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditVasDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['hasAmount'] = this.hasAmount;
    data['hasCount'] = this.hasCount;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditVasDto {
  name: string;
  displayName: string | undefined;
  hasAmount: boolean;
  hasCount: boolean;
  id: number | undefined;
}

export class GetVasForEditOutput implements IGetVasForEditOutput {
  vas!: CreateOrEditVasDto;

  constructor(data?: IGetVasForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vas = _data['vas'] ? CreateOrEditVasDto.fromJS(_data['vas']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetVasForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetVasForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vas'] = this.vas ? this.vas.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetVasForEditOutput {
  vas: CreateOrEditVasDto;
}

export class VasPriceDto implements IVasPriceDto {
  price!: number | undefined;
  maxAmount!: number | undefined;
  maxCount!: number | undefined;
  vasId!: number;
  id!: number;

  constructor(data?: IVasPriceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data['price'];
      this.maxAmount = _data['maxAmount'];
      this.maxCount = _data['maxCount'];
      this.vasId = _data['vasId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): VasPriceDto {
    data = typeof data === 'object' ? data : {};
    let result = new VasPriceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['price'] = this.price;
    data['maxAmount'] = this.maxAmount;
    data['maxCount'] = this.maxCount;
    data['vasId'] = this.vasId;
    data['id'] = this.id;
    return data;
  }
}

export interface IVasPriceDto {
  price: number | undefined;
  maxAmount: number | undefined;
  maxCount: number | undefined;
  vasId: number;
  id: number;
}

export class GetVasPriceForViewDto implements IGetVasPriceForViewDto {
  vasPrice!: VasPriceDto;
  vasName!: string | undefined;
  hasAmount!: boolean;
  hasCount!: boolean;

  constructor(data?: IGetVasPriceForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vasPrice = _data['vasPrice'] ? VasPriceDto.fromJS(_data['vasPrice']) : <any>undefined;
      this.vasName = _data['vasName'];
      this.hasAmount = _data['hasAmount'];
      this.hasCount = _data['hasCount'];
    }
  }

  static fromJS(data: any): GetVasPriceForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetVasPriceForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vasPrice'] = this.vasPrice ? this.vasPrice.toJSON() : <any>undefined;
    data['vasName'] = this.vasName;
    data['hasAmount'] = this.hasAmount;
    data['hasCount'] = this.hasCount;
    return data;
  }
}

export interface IGetVasPriceForViewDto {
  vasPrice: VasPriceDto;
  vasName: string | undefined;
  hasAmount: boolean;
  hasCount: boolean;
}

export class PagedResultDtoOfGetVasPriceForViewDto implements IPagedResultDtoOfGetVasPriceForViewDto {
  totalCount!: number;
  items!: GetVasPriceForViewDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGetVasPriceForViewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetVasPriceForViewDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetVasPriceForViewDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetVasPriceForViewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetVasPriceForViewDto {
  totalCount: number;
  items: GetVasPriceForViewDto[] | undefined;
}

export class CreateOrEditVasPriceDto implements ICreateOrEditVasPriceDto {
  price!: number | undefined;
  maxAmount!: number | undefined;
  maxCount!: number | undefined;
  vasId!: number;
  id!: number | undefined;

  constructor(data?: ICreateOrEditVasPriceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data['price'];
      this.maxAmount = _data['maxAmount'];
      this.maxCount = _data['maxCount'];
      this.vasId = _data['vasId'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CreateOrEditVasPriceDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrEditVasPriceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['price'] = this.price;
    data['maxAmount'] = this.maxAmount;
    data['maxCount'] = this.maxCount;
    data['vasId'] = this.vasId;
    data['id'] = this.id;
    return data;
  }
}

export interface ICreateOrEditVasPriceDto {
  price: number | undefined;
  maxAmount: number | undefined;
  maxCount: number | undefined;
  vasId: number;
  id: number | undefined;
}

export class GetVasPriceForEditOutput implements IGetVasPriceForEditOutput {
  vasPrice!: CreateOrEditVasPriceDto;
  vasName!: string | undefined;

  constructor(data?: IGetVasPriceForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vasPrice = _data['vasPrice'] ? CreateOrEditVasPriceDto.fromJS(_data['vasPrice']) : <any>undefined;
      this.vasName = _data['vasName'];
    }
  }

  static fromJS(data: any): GetVasPriceForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetVasPriceForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vasPrice'] = this.vasPrice ? this.vasPrice.toJSON() : <any>undefined;
    data['vasName'] = this.vasName;
    return data;
  }
}

export interface IGetVasPriceForEditOutput {
  vasPrice: CreateOrEditVasPriceDto;
  vasName: string | undefined;
}

export class VasPriceVasLookupTableDto implements IVasPriceVasLookupTableDto {
  id!: number;
  displayName!: string | undefined;

  constructor(data?: IVasPriceVasLookupTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.displayName = _data['displayName'];
    }
  }

  static fromJS(data: any): VasPriceVasLookupTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new VasPriceVasLookupTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['displayName'] = this.displayName;
    return data;
  }
}

export interface IVasPriceVasLookupTableDto {
  id: number;
  displayName: string | undefined;
}

export class WebhookEvent implements IWebhookEvent {
  webhookName!: string;
  data!: string | undefined;
  creationTime!: moment.Moment;
  tenantId!: number | undefined;
  isDeleted!: boolean;
  deletionTime!: moment.Moment | undefined;
  id!: string;

  constructor(data?: IWebhookEvent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webhookName = _data['webhookName'];
      this.data = _data['data'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.tenantId = _data['tenantId'];
      this.isDeleted = _data['isDeleted'];
      this.deletionTime = _data['deletionTime'] ? moment(_data['deletionTime'].toString()) : <any>undefined;
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): WebhookEvent {
    data = typeof data === 'object' ? data : {};
    let result = new WebhookEvent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['webhookName'] = this.webhookName;
    data['data'] = this.data;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['tenantId'] = this.tenantId;
    data['isDeleted'] = this.isDeleted;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
    data['id'] = this.id;
    return data;
  }
}

export interface IWebhookEvent {
  webhookName: string;
  data: string | undefined;
  creationTime: moment.Moment;
  tenantId: number | undefined;
  isDeleted: boolean;
  deletionTime: moment.Moment | undefined;
  id: string;
}

export enum HttpStatusCode {
  Continue = 100,
  SwitchingProtocols = 101,
  Processing = 102,
  EarlyHints = 103,
  OK = 200,
  Created = 201,
  Accepted = 202,
  NonAuthoritativeInformation = 203,
  NoContent = 204,
  ResetContent = 205,
  PartialContent = 206,
  MultiStatus = 207,
  AlreadyReported = 208,
  IMUsed = 226,
  MultipleChoices = 300,
  Ambiguous = 301,
  MovedPermanently = 302,
  Moved = 303,
  Found = 304,
  Redirect = 305,
  SeeOther = 306,
  RedirectMethod = 307,
  NotModified = 308,
  UseProxy = 400,
  Unused = 401,
  TemporaryRedirect = 402,
  RedirectKeepVerb = 403,
  PermanentRedirect = 404,
  BadRequest = 405,
  Unauthorized = 406,
  PaymentRequired = 407,
  Forbidden = 408,
  NotFound = 409,
  MethodNotAllowed = 410,
  NotAcceptable = 411,
  ProxyAuthenticationRequired = 412,
  RequestTimeout = 413,
  Conflict = 414,
  Gone = 415,
  LengthRequired = 416,
  PreconditionFailed = 417,
  RequestEntityTooLarge = 421,
  RequestUriTooLong = 422,
  UnsupportedMediaType = 423,
  RequestedRangeNotSatisfiable = 424,
  ExpectationFailed = 426,
  MisdirectedRequest = 428,
  UnprocessableEntity = 429,
  Locked = 431,
  FailedDependency = 451,
  UpgradeRequired = 500,
  PreconditionRequired = 501,
  TooManyRequests = 502,
  RequestHeaderFieldsTooLarge = 503,
  UnavailableForLegalReasons = 504,
  InternalServerError = 505,
  NotImplemented = 506,
  BadGateway = 507,
  ServiceUnavailable = 508,
  GatewayTimeout = 510,
  HttpVersionNotSupported = 511,
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
  id!: string;
  webhookEventId!: string;
  webhookName!: string | undefined;
  data!: string | undefined;
  response!: string | undefined;
  responseStatusCode!: HttpStatusCode;
  creationTime!: moment.Moment;

  constructor(data?: IGetAllSendAttemptsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.webhookEventId = _data['webhookEventId'];
      this.webhookName = _data['webhookName'];
      this.data = _data['data'];
      this.response = _data['response'];
      this.responseStatusCode = _data['responseStatusCode'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllSendAttemptsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllSendAttemptsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['webhookEventId'] = this.webhookEventId;
    data['webhookName'] = this.webhookName;
    data['data'] = this.data;
    data['response'] = this.response;
    data['responseStatusCode'] = this.responseStatusCode;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetAllSendAttemptsOutput {
  id: string;
  webhookEventId: string;
  webhookName: string | undefined;
  data: string | undefined;
  response: string | undefined;
  responseStatusCode: HttpStatusCode;
  creationTime: moment.Moment;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
  totalCount!: number;
  items!: GetAllSendAttemptsOutput[] | undefined;

  constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
  totalCount: number;
  items: GetAllSendAttemptsOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
  id!: string;
  webhookUri!: string | undefined;
  webhookSubscriptionId!: string;
  response!: string | undefined;
  responseStatusCode!: HttpStatusCode;
  creationTime!: moment.Moment;
  lastModificationTime!: moment.Moment | undefined;

  constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.webhookUri = _data['webhookUri'];
      this.webhookSubscriptionId = _data['webhookSubscriptionId'];
      this.response = _data['response'];
      this.responseStatusCode = _data['responseStatusCode'];
      this.creationTime = _data['creationTime'] ? moment(_data['creationTime'].toString()) : <any>undefined;
      this.lastModificationTime = _data['lastModificationTime'] ? moment(_data['lastModificationTime'].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllSendAttemptsOfWebhookEventOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['webhookUri'] = this.webhookUri;
    data['webhookSubscriptionId'] = this.webhookSubscriptionId;
    data['response'] = this.response;
    data['responseStatusCode'] = this.responseStatusCode;
    data['creationTime'] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data['lastModificationTime'] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    return data;
  }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
  id: string;
  webhookUri: string | undefined;
  webhookSubscriptionId: string;
  response: string | undefined;
  responseStatusCode: HttpStatusCode;
  creationTime: moment.Moment;
  lastModificationTime: moment.Moment | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
  items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

  constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
  items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
  webhookUri!: string | undefined;
  isActive!: boolean;
  webhooks!: string[] | undefined;
  id!: string;

  constructor(data?: IGetAllSubscriptionsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webhookUri = _data['webhookUri'];
      this.isActive = _data['isActive'];
      if (Array.isArray(_data['webhooks'])) {
        this.webhooks = [] as any;
        for (let item of _data['webhooks']) this.webhooks!.push(item);
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): GetAllSubscriptionsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllSubscriptionsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['webhookUri'] = this.webhookUri;
    data['isActive'] = this.isActive;
    if (Array.isArray(this.webhooks)) {
      data['webhooks'] = [];
      for (let item of this.webhooks) data['webhooks'].push(item);
    }
    data['id'] = this.id;
    return data;
  }
}

export interface IGetAllSubscriptionsOutput {
  webhookUri: string | undefined;
  isActive: boolean;
  webhooks: string[] | undefined;
  id: string;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
  items!: GetAllSubscriptionsOutput[] | undefined;

  constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfGetAllSubscriptionsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
  items: GetAllSubscriptionsOutput[] | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
  tenantId!: number | undefined;
  webhookUri!: string | undefined;
  secret!: string | undefined;
  isActive!: boolean;
  webhooks!: string[] | undefined;
  headers!: { [key: string]: string } | undefined;
  id!: string;

  constructor(data?: IWebhookSubscription) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.webhookUri = _data['webhookUri'];
      this.secret = _data['secret'];
      this.isActive = _data['isActive'];
      if (Array.isArray(_data['webhooks'])) {
        this.webhooks = [] as any;
        for (let item of _data['webhooks']) this.webhooks!.push(item);
      }
      if (_data['headers']) {
        this.headers = {} as any;
        for (let key in _data['headers']) {
          if (_data['headers'].hasOwnProperty(key)) this.headers![key] = _data['headers'][key];
        }
      }
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): WebhookSubscription {
    data = typeof data === 'object' ? data : {};
    let result = new WebhookSubscription();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['webhookUri'] = this.webhookUri;
    data['secret'] = this.secret;
    data['isActive'] = this.isActive;
    if (Array.isArray(this.webhooks)) {
      data['webhooks'] = [];
      for (let item of this.webhooks) data['webhooks'].push(item);
    }
    if (this.headers) {
      data['headers'] = {};
      for (let key in this.headers) {
        if (this.headers.hasOwnProperty(key)) data['headers'][key] = this.headers[key];
      }
    }
    data['id'] = this.id;
    return data;
  }
}

export interface IWebhookSubscription {
  tenantId: number | undefined;
  webhookUri: string | undefined;
  secret: string | undefined;
  isActive: boolean;
  webhooks: string[] | undefined;
  headers: { [key: string]: string } | undefined;
  id: string;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
  subscriptionId!: string;
  isActive!: boolean;

  constructor(data?: IActivateWebhookSubscriptionInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.subscriptionId = _data['subscriptionId'];
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): ActivateWebhookSubscriptionInput {
    data = typeof data === 'object' ? data : {};
    let result = new ActivateWebhookSubscriptionInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['subscriptionId'] = this.subscriptionId;
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface IActivateWebhookSubscriptionInput {
  subscriptionId: string;
  isActive: boolean;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;

  constructor(data?: IGetAllAvailableWebhooksOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): GetAllAvailableWebhooksOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllAvailableWebhooksOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    return data;
  }
}

export interface IGetAllAvailableWebhooksOutput {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
  items!: GetAllAvailableWebhooksOutput[] | undefined;

  constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
  items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
  latestWebLogLines!: string[] | undefined;

  constructor(data?: IGetLatestWebLogsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['latestWebLogLines'])) {
        this.latestWebLogLines = [] as any;
        for (let item of _data['latestWebLogLines']) this.latestWebLogLines!.push(item);
      }
    }
  }

  static fromJS(data: any): GetLatestWebLogsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetLatestWebLogsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.latestWebLogLines)) {
      data['latestWebLogLines'] = [];
      for (let item of this.latestWebLogLines) data['latestWebLogLines'].push(item);
    }
    return data;
  }
}

export interface IGetLatestWebLogsOutput {
  latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
  paypal!: { [key: string]: string };
  stripe!: { [key: string]: string };

  constructor(data?: IAdditionalData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['Paypal']) {
        this.paypal = {} as any;
        for (let key in _data['Paypal']) {
          if (_data['Paypal'].hasOwnProperty(key)) this.paypal![key] = _data['Paypal'][key];
        }
      }
      if (_data['Stripe']) {
        this.stripe = {} as any;
        for (let key in _data['Stripe']) {
          if (_data['Stripe'].hasOwnProperty(key)) this.stripe![key] = _data['Stripe'][key];
        }
      }
    }
  }

  static fromJS(data: any): AdditionalData {
    data = typeof data === 'object' ? data : {};
    let result = new AdditionalData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.paypal) {
      data['Paypal'] = {};
      for (let key in this.paypal) {
        if (this.paypal.hasOwnProperty(key)) data['Paypal'][key] = this.paypal[key];
      }
    }
    if (this.stripe) {
      data['Stripe'] = {};
      for (let key in this.stripe) {
        if (this.stripe.hasOwnProperty(key)) data['Stripe'][key] = this.stripe[key];
      }
    }
    return data;
  }
}

export interface IAdditionalData {
  paypal: { [key: string]: string };
  stripe: { [key: string]: string };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
